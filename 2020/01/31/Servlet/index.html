<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Http Servlet | Cin's Home</title><meta name="keywords" content="JavaEE"><meta name="author" content="承影"><meta name="copyright" content="承影"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Servlet  一、Java Web 开发核心知识点1.1 - 什么是 Web 开发  Web 通信，指两台计算机通过计算机网络进行资源文件共享活动 Web开发确保本次通信顺利执行   1.2 - Web 通信中两台计算机之间的角色  客户端：用于发送请求 服务端：提供共享资源文件   1.3 - 资源文件  理论上来说，计算机上所有的文件都是资源共享文件   1.3.1 - 静态资源文件  文">
<meta property="og:type" content="article">
<meta property="og:title" content="Http Servlet">
<meta property="og:url" content="http://cyingk.github.io/2020/01/31/Servlet/index.html">
<meta property="og:site_name" content="Cin&#39;s Home">
<meta property="og:description" content="Servlet  一、Java Web 开发核心知识点1.1 - 什么是 Web 开发  Web 通信，指两台计算机通过计算机网络进行资源文件共享活动 Web开发确保本次通信顺利执行   1.2 - Web 通信中两台计算机之间的角色  客户端：用于发送请求 服务端：提供共享资源文件   1.3 - 资源文件  理论上来说，计算机上所有的文件都是资源共享文件   1.3.1 - 静态资源文件  文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/CyingK/files/raw/master/images/blog/cover/http-servlet-2020-01-31.jpg">
<meta property="article:published_time" content="2020-01-30T17:26:09.000Z">
<meta property="article:modified_time" content="2021-01-16T01:52:46.936Z">
<meta property="article:author" content="承影">
<meta property="article:tag" content="JavaEE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/CyingK/files/raw/master/images/blog/cover/http-servlet-2020-01-31.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://cyingk.github.io/2020/01/31/Servlet/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "4zndahq92q");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-16 09:52:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = '1'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/CyingK/files/raw/master/images/blog/utils/top.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cin's Home</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Http Servlet</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-01-30T17:26:09.000Z" title="undefined 2020-01-31 01:26:09">2020-01-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><center>Servlet</center></h1>

<h1 id="一、Java-Web-开发核心知识点"><a href="#一、Java-Web-开发核心知识点" class="headerlink" title="一、Java Web 开发核心知识点"></a>一、Java Web 开发核心知识点</h1><h2 id="1-1-什么是-Web-开发"><a href="#1-1-什么是-Web-开发" class="headerlink" title="1.1 - 什么是 Web 开发"></a>1.1 - 什么是 Web 开发</h2><blockquote>
<ul>
<li><code>Web</code> 通信，指两台计算机通过计算机网络进行资源文件共享活动</li>
<li><code>Web</code>开发确保本次通信顺利执行</li>
</ul>
</blockquote>
<h2 id="1-2-Web-通信中两台计算机之间的角色"><a href="#1-2-Web-通信中两台计算机之间的角色" class="headerlink" title="1.2 - Web 通信中两台计算机之间的角色"></a>1.2 - Web 通信中两台计算机之间的角色</h2><blockquote>
<ul>
<li>客户端：用于发送请求</li>
<li>服务端：提供共享资源文件</li>
</ul>
</blockquote>
<h2 id="1-3-资源文件"><a href="#1-3-资源文件" class="headerlink" title="1.3 - 资源文件"></a>1.3 - 资源文件</h2><blockquote>
<ul>
<li>理论上来说，计算机上所有的文件都是资源共享文件</li>
</ul>
</blockquote>
<h3 id="1-3-1-静态资源文件"><a href="#1-3-1-静态资源文件" class="headerlink" title="1.3.1 - 静态资源文件"></a>1.3.1 - 静态资源文件</h3><blockquote>
<ul>
<li>文件内容是固定的，不能随请求的变化而变化</li>
<li>服务端计算机直接将<strong>静态资源文件</strong>推给<strong>客户端</strong>，所有被共享的<strong>静态资源文件</strong>最终是在<strong>客户端</strong>运行</li>
</ul>
</blockquote>
<h3 id="1-3-2-动态资源文件"><a href="#1-3-2-动态资源文件" class="headerlink" title="1.3.2 - 动态资源文件"></a>1.3.2 - 动态资源文件</h3><blockquote>
<ul>
<li>文件内容可以根据用户提供需求变化而产生不同变化内容</li>
<li>服务端会调用执行<strong>动态资源文件</strong>，服务端将<strong>动态资源文件的运行结果</strong>交给客户端</li>
</ul>
</blockquote>
<h2 id="1-4-Web-通信中，两台计算机如何进行通信"><a href="#1-4-Web-通信中，两台计算机如何进行通信" class="headerlink" title="1.4 - Web 通信中，两台计算机如何进行通信"></a>1.4 - Web 通信中，两台计算机如何进行通信</h2><h3 id="1-4-1-C-S-结构通信方式"><a href="#1-4-1-C-S-结构通信方式" class="headerlink" title="1.4.1 - C/S 结构通信方式"></a>1.4.1 - <code>C/S</code> 结构通信方式</h3><blockquote>
<p>C - <code>Client</code>，客户端计算机安装特定<strong>客户端程序</strong>，可以帮助客户端向指定服务器发送请求</p>
<p>S - <code>Server</code>，在服务端计算机安装一种特定<strong>资源调度软件</strong>接收特定客户端程序发送请求，将请求需要的资源文件推送回客户端上的<strong>客户端程序</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>可以有效的保护服务端计算机</li>
<li>可以分摊服务端计算机工作压力</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>增加客户获得服务的成本</li>
<li>增加服务端维护成本</li>
</ul>
</blockquote>
<h3 id="1-4-2-B-S"><a href="#1-4-2-B-S" class="headerlink" title="1.4.2 - B/S"></a>1.4.2 - <code>B/S</code></h3><blockquote>
<p>B - <code>Browser</code>，可以帮助客户端向任意服务端发送请求</p>
<p>S - <code>Server</code>， 在服务端安装一种特定<strong>资源调度软件</strong>，可以接收所有浏览器发送的请求，将请求的资源文件推送给客户端浏览器</p>
<p><strong>优点</strong></p>
<ul>
<li>不会增加客户获得服务的成本</li>
<li>不会增加客户端维护的成本</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>无法有效保护服务端计算机</li>
<li>无法通过客户端计算机分摊服务端的计算机压力</li>
</ul>
</blockquote>
<h2 id="1-5-网络协议包"><a href="#1-5-网络协议包" class="headerlink" title="1.5 - 网络协议包"></a>1.5 - 网络协议包</h2><h3 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 - 定义"></a>1.5.1 - 定义</h3><blockquote>
<p>用于包裹在网络中传输二进制</p>
</blockquote>
<h3 id="1-5-2-分类"><a href="#1-5-2-分类" class="headerlink" title="1.5.2 - 分类"></a>1.5.2 - 分类</h3><blockquote>
<ul>
<li><code>FTP</code></li>
<li><code>HTTP</code></li>
</ul>
</blockquote>
<h3 id="1-5-3-注意事项"><a href="#1-5-3-注意事项" class="headerlink" title="1.5.3 - 注意事项"></a>1.5.3 - 注意事项</h3><blockquote>
<p><code>B/S</code> 到目前为止指使用<code>HTTP</code> 网络协议包</p>
</blockquote>
<h2 id="1-6-HTTP-内部结构"><a href="#1-6-HTTP-内部结构" class="headerlink" title="1.6 - HTTP 内部结构"></a>1.6 - HTTP 内部结构</h2><h3 id="1-6-1-请求协议包"><a href="#1-6-1-请求协议包" class="headerlink" title="1.6.1 - 请求协议包"></a>1.6.1 - 请求协议包</h3><blockquote>
<ul>
<li>是浏览器在发送请求时创建的</li>
<li>是浏览器负责将请求信息，写入到请求协议包</li>
<li><code>HTTP</code> 请求协议包内部自上而下有四层结构</li>
</ul>
</blockquote>
<h4 id="1-6-1-1-请求行"><a href="#1-6-1-1-请求行" class="headerlink" title="1.6.1.1 - 请求行"></a>1.6.1.1 - 请求行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	URL: 请求的资源文件地址</span><br><span class="line">	METHOD: 浏览器采用的请求方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-1-2-请求头"><a href="#1-6-1-2-请求头" class="headerlink" title="1.6.1.2 - 请求头"></a>1.6.1.2 - 请求头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	浏览器希望获得资源文件类型</span><br><span class="line">	浏览器希望获得资源文件内容依赖字符集</span><br><span class="line">	如果浏览器采用 GET 方式，本次关联请求参数需要保存在请求头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-1-3-空白行"><a href="#1-6-1-3-空白行" class="headerlink" title="1.6.1.3 - 空白行"></a>1.6.1.3 - 空白行</h4><blockquote>
<p>隔离层</p>
</blockquote>
<h4 id="1-6-1-4-请求体"><a href="#1-6-1-4-请求体" class="headerlink" title="1.6.1.4 - 请求体"></a>1.6.1.4 - 请求体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	如果浏览器采用 POST 方式发送请求，本次关联请求参数保存在请求体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-响应协议包"><a href="#1-6-2-响应协议包" class="headerlink" title="1.6.2 - 响应协议包"></a>1.6.2 - 响应协议包</h3><blockquote>
<ul>
<li>在服务端计算机的<strong>资源调度软件</strong>准备推送文件时负责创建</li>
<li><strong>响应协议包内容</strong>可以有<strong>资源调度软件</strong>写入，可以由 <code>Java</code> 命令写入</li>
<li><code>HTTP</code> 请求协议包内部自上而下有四层结构</li>
</ul>
</blockquote>
<h4 id="1-6-2-1-状态行"><a href="#1-6-2-1-状态行" class="headerlink" title="1.6.2.1 - 状态行"></a>1.6.2.1 - 状态行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	状态码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-2-2-响应头"><a href="#1-6-2-2-响应头" class="headerlink" title="1.6.2.2 - 响应头"></a>1.6.2.2 - 响应头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	返回文件内容类型 (doc,text,html,text&#x2F;html)</span><br><span class="line">	返回文件内容依赖字符集</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-2-3-空白行"><a href="#1-6-2-3-空白行" class="headerlink" title="1.6.2.3 - 空白行"></a>1.6.2.3 - 空白行</h4><h4 id="1-6-2-4-响应体"><a href="#1-6-2-4-响应体" class="headerlink" title="1.6.2.4 - 响应体"></a>1.6.2.4 - 响应体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	静态资源文件也可能时动态资源文件运行结果 (二进制)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-请求方式"><a href="#1-7-请求方式" class="headerlink" title="1.7 - 请求方式"></a>1.7 - 请求方式</h2><h3 id="1-7-1-GET"><a href="#1-7-1-GET" class="headerlink" title="1.7.1 - GET"></a>1.7.1 - GET</h3><blockquote>
<ul>
<li>要求浏览器发送请求时，携带请求参数数量不能操作 4<code>K</code></li>
<li>要求浏览器将请求参数写入到<strong>请求头</strong></li>
<li>要求浏览器将请求参数信息在地址栏显示出来</li>
<li>要求浏览器对接收的资源文件必须缓存到内存</li>
</ul>
</blockquote>
<h3 id="1-7-2-POST"><a href="#1-7-2-POST" class="headerlink" title="1.7.2 - POST"></a>1.7.2 - POST</h3><blockquote>
<ul>
<li>不会限制浏览器发送请求时，携带请求参数数量</li>
<li>要求浏览器将请求参数写入<strong>请求体</strong></li>
<li>要求浏览器将请求参数在地址栏隐藏</li>
<li>要求浏览器对接收的文件不能保存到缓存</li>
</ul>
</blockquote>
<h2 id="1-8-控制浏览器的请求方式"><a href="#1-8-控制浏览器的请求方式" class="headerlink" title="1.8 - 控制浏览器的请求方式"></a>1.8 - 控制浏览器的请求方式</h2><h3 id="1-8-1-GET"><a href="#1-8-1-GET" class="headerlink" title="1.8.1 - GET"></a>1.8.1 - GET</h3><blockquote>
<ul>
<li>超链接</li>
<li><code>localtion</code> 对象</li>
<li>表单中的 <code>Method</code> 属性可以设置为 <code>GET</code></li>
</ul>
</blockquote>
<h3 id="1-8-2-POST"><a href="#1-8-2-POST" class="headerlink" title="1.8.2 - POST"></a>1.8.2 - POST</h3><blockquote>
<ul>
<li>表单中的 <code>Method</code> 属性可以设置为 <code>POST</code></li>
</ul>
</blockquote>
<h1 id="二、HTTP-服务器"><a href="#二、HTTP-服务器" class="headerlink" title="二、HTTP 服务器"></a>二、HTTP 服务器</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 - 介绍"></a>2.1 - 介绍</h2><blockquote>
<ul>
<li>安装在服务端计算机上的一种软件</li>
<li>可以解析来自于浏览器发送的<strong>请求协议包</strong></li>
<li>调用服务端上被请求的<strong>资源共享文件</strong></li>
<li>负责生成一个<strong>响应协议包</strong></li>
<li>负责将<strong>文件内容</strong>或者<strong>文件运行结果</strong>写入到<strong>响应体</strong></li>
<li>负责将<strong>响应协议包</strong>推送给<strong>当前浏览器</strong></li>
</ul>
</blockquote>
<h2 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 - 分类"></a>2.2 - 分类</h2><blockquote>
<ul>
<li>德国 – SAP</li>
<li>IBM – WebLogic</li>
<li>JBOSS – JBOSS</li>
<li>Apache – Tomcat – 单位时间内大约 1200 次请求</li>
</ul>
</blockquote>
<h2 id="2-3-Tomcat-介绍"><a href="#2-3-Tomcat-介绍" class="headerlink" title="2.3 - Tomcat 介绍"></a>2.3 - Tomcat 介绍</h2><blockquote>
<ul>
<li>是一个由 <code>Java</code> 应用程序编写的资源文件调度器</li>
<li>可以调用服务端静态资源文件和<strong>动态资源文件</strong></li>
<li><code>Tomcat</code> 负责生成响应协议包，负责将响应协议包推送到浏览器</li>
<li><code>Tomcat</code> 属于 <code>Apache</code></li>
</ul>
</blockquote>
<h2 id="2-4-网站"><a href="#2-4-网站" class="headerlink" title="2.4 - 网站"></a>2.4 - 网站</h2><blockquote>
<ul>
<li>全称：网络中的资源站点</li>
<li>作用：仓库，存储可以共享<strong>静态资源文件</strong>和<strong>动态资源文件</strong></li>
<li>文件管理：由 <code>HTTP</code> 服务器来调用内部共享资源文件</li>
<li>本质：就是一个文件夹</li>
</ul>
</blockquote>
<h2 id="2-5-网站分类"><a href="#2-5-网站分类" class="headerlink" title="2.5 - 网站分类"></a>2.5 - 网站分类</h2><blockquote>
<ul>
<li>静态资源网站：存储都是静态资源文件</li>
<li>动态资源网站：存储的是静态资源和动态资源</li>
</ul>
</blockquote>
<h1 id="三、Servlet-规范"><a href="#三、Servlet-规范" class="headerlink" title="三、Servlet 规范"></a>三、Servlet 规范</h1><h2 id="3-1-JavaEE-与-JavaSE-的区别"><a href="#3-1-JavaEE-与-JavaSE-的区别" class="headerlink" title="3.1 - JavaEE 与 JavaSE 的区别"></a>3.1 - JavaEE 与 JavaSE 的区别</h2><blockquote>
<ul>
<li><code>JavaEE</code> – 企业级开发规范</li>
<li><code>JavaSE</code> – 基本开发规范，制定了管理系统与 13 类系统之间的交流规则</li>
</ul>
</blockquote>
<h2 id="3-2-Servlet-规范"><a href="#3-2-Servlet-规范" class="headerlink" title="3.2 - Servlet 规范"></a>3.2 - Servlet 规范</h2><blockquote>
<ul>
<li><code>Servlet</code> 规范是 <code>JavaEE</code> 规范中的一种</li>
<li><code>Servlet</code> 规范中设置 <code>JVM</code> 与 <code>Http</code> 服务器的交流规则<ul>
<li>定义何种 <code>Java</code> 类可以被 <code>HTTP</code> 服务器调用<ul>
<li>只有 <code>Servlet</code> 的实现类才有资格作为**动态共享资源文件</li>
<li><code>Servlet</code> 实现类由开发人员创建</li>
</ul>
</li>
<li><code>HTTP</code> 服务器应该如何管理 <strong>动态资源文件</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-3-创建-Servlet-实现类"><a href="#3-3-创建-Servlet-实现类" class="headerlink" title="3.3 - 创建 Servlet 实现类"></a>3.3 - 创建 Servlet 实现类</h2><blockquote>
<ul>
<li>创建一个实现类，继承 <code>HttpServlet</code></li>
<li><code>HttpServlet</code> 存在于 <code>Tomcat/lib/servlet-api.jar</code></li>
<li>根据来访的浏览器采用的请求方式，重写对应 doGet 或者 doPost</li>
<li>在 <code>WEB-INF/lib/web.xml</code> 中注册实现类，并创建匹配的对外路径</li>
</ul>
</blockquote>
<h2 id="3-4-Tomcat-调用-Serlvet-接口实现类流程"><a href="#3-4-Tomcat-调用-Serlvet-接口实现类流程" class="headerlink" title="3.4 - Tomcat 调用 Serlvet 接口实现类流程"></a>3.4 - Tomcat 调用 Serlvet 接口实现类流程</h2><p><strong>浏览器向服务器发送请求</strong></p>
<p><strong><code>Tomcat</code> 接收到这个请求</strong></p>
<blockquote>
<p>首先将请求资源文件作为动态资源文件。到 <code>web.xml</code> 进行文件定位。如果有则调用，如果没有找到对应的动态资源文件，此时 <code>Tomcat</code> 认为本次请求的是一个静态资源文件，从 <code>web</code> 下进行定位。如果有则返回，如果还是没有，则返回 <code>404</code> </p>
</blockquote>
<p><strong><code>Tomcat</code> 定位到 <code>web.xml</code> 根据 <code>&lt;url-pattern/&gt;</code> 进行定位 <code>&lt;servlet-name/&gt;</code></strong></p>
<p><strong><code>&lt;servlet-name/&gt;</code> 定位 <code>&lt;servlet-class/&gt;</code> 找到本次请求的 <code>Servlet</code></strong></p>
<p><strong><code>Tomcat</code> 根据浏览器采用的请求方式，调用 <code>Servlet</code> 的 <code>doGet</code> 或者 <code>doPost</code> 方法</strong></p>
<p><strong>当 <code>doGet</code> 或者 <code>doPost</code> 调用完毕，<code>Tomcat</code> 负责将相应包推送给浏览器</strong></p>
<h2 id="3-5-Servlet-请求路径写法规则"><a href="#3-5-Servlet-请求路径写法规则" class="headerlink" title="3.5 - Servlet 请求路径写法规则"></a>3.5 - Servlet 请求路径写法规则</h2><h3 id="3-5-1-具体请求路径"><a href="#3-5-1-具体请求路径" class="headerlink" title="3.5.1 - 具体请求路径"></a>3.5.1 - 具体请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;/path&lt;/url-partter&gt;</code></p>
<p>浏览器请求的 <strong>资源文件地址</strong> 与 <code>&lt;url-partter/&gt;</code> 的内容完全一致</p>
<p><strong>优先级最高</strong></p>
</blockquote>
<h3 id="3-5-2-前置请求路径"><a href="#3-5-2-前置请求路径" class="headerlink" title="3.5.2 - 前置请求路径"></a>3.5.2 - 前置请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;/path/*&lt;/url-partter&gt;</code></p>
<p>浏览器请求的 <strong>资源文件地址</strong> 以 <code>&lt;url-partter/&gt;</code> 的内容开头</p>
<p><strong>优先级第二</strong></p>
</blockquote>
<h3 id="3-5-3-后置请求路径"><a href="#3-5-3-后置请求路径" class="headerlink" title="3.5.3 - 后置请求路径"></a>3.5.3 - 后置请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;*path&lt;/url-partter&gt;</code></p>
<p>浏览器请求的 <strong>资源文件地址</strong> 以 <code>&lt;url-parttern/&gt;</code> 的内容结尾</p>
<p><strong>优先级最低</strong></p>
</blockquote>
<h3 id="3-5-4-通配符请求路径"><a href="#3-5-4-通配符请求路径" class="headerlink" title="3.5.4 - 通配符请求路径"></a>3.5.4 - 通配符请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;/*&lt;/url-partter&gt;</code></p>
<p>接收来自浏览器的所有请求</p>
<p><strong>优先级第三</strong></p>
</blockquote>
<h2 id="3-6-Servlet-实例对象的生命周期"><a href="#3-6-Servlet-实例对象的生命周期" class="headerlink" title="3.6 - Servlet 实例对象的生命周期"></a>3.6 - Servlet 实例对象的生命周期</h2><blockquote>
<ul>
<li><p>项目中所有的 <code>Servlet</code> 的实例对象都是 <code>Tomcat</code> 创建的，开发人员没有权利创建</p>
</li>
<li><p>创建时机</p>
<ul>
<li><p>默认情况：当第一个用户来访问这个 <code>Servlet</code> 时，<code>Tomcat</code> 负责创建</p>
</li>
<li><p>人工干预：要求 <code>Tomcat</code> 在启动时，创建 <code>Servlet</code> 的实例对象</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>任一大于0的数<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>Tomcat</code> 运行器件，一个 <code>Servlet</code> 实现类只能被创建一个对象</p>
</li>
<li><p>在 <code>Tomcat</code> 关闭时，由 <code>Tomcat</code> 负责销毁所有 <code>Servlet</code> 实例类对象</p>
</li>
</ul>
</blockquote>
<h2 id="3-7-请求对象与响应对象生命周期"><a href="#3-7-请求对象与响应对象生命周期" class="headerlink" title="3.7 - 请求对象与响应对象生命周期"></a>3.7 - 请求对象与响应对象生命周期</h2><blockquote>
<ul>
<li>都是由 <code>Tomcat</code> 负责创建</li>
<li>每当一个 <code>Tomcat</code> 收到一个 <strong>请求协议包</strong>，就会为这个请求协议包创建一对 <strong>请求对象和响应对象</strong></li>
<li>一次请求对应一对 <strong>请求对象和响应对象</strong></li>
<li>在 <code>Tomcat</code> 调用被请求的 <code>Servlet</code> 中的 <code>doGet</code> 和 <code>doPost</code> 方法时，负责将本次 <strong>请求对象和响应对象</strong> 作为参数传入到服务方法</li>
<li>在服务方法完毕后，<code>Tomcat</code> 销毁本次请求相关的 <code>request</code> 和 <code>response</code></li>
<li>最后，<code>Tomcat</code> 负责将 <strong>相应包</strong> 推送到服务器上</li>
</ul>
</blockquote>
<h1 id="四、HttpServletResponse"><a href="#四、HttpServletResponse" class="headerlink" title="四、HttpServletResponse"></a>四、HttpServletResponse</h1><blockquote>
<p>负责将运行结果写入到相应包</p>
</blockquote>
<h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 - 介绍"></a>4.1 - 介绍</h2><blockquote>
<ul>
<li>一个来自于 <code>Servlet</code> 规范中的接口，由 <code>Tomcat</code> 负责提供这个接口实现类</li>
<li>负责在 <code>Servlet</code> 运行完毕后，将相关的数据写入到 <strong>响应头</strong> 和 <strong>响应体</strong></li>
<li>开发人员习惯于将 <code>HttpServletResponse</code> 接口修饰对象称为 <strong>响应对象</strong></li>
</ul>
</blockquote>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 - 方法"></a>4.2 - 方法</h2><h3 id="setCharacterEncoding"><a href="#setCharacterEncoding" class="headerlink" title=".setCharacterEncoding()"></a>.setCharacterEncoding()</h3><blockquote>
<p>设置字符编码</p>
<p><strong>key</strong> – 字符编码</p>
</blockquote>
<h3 id="getWriter"><a href="#getWriter" class="headerlink" title=".getWriter()"></a>.getWriter()</h3><blockquote>
<p>获取输出流</p>
</blockquote>
<h3 id="setContentType"><a href="#setContentType" class="headerlink" title=".setContentType()"></a>.setContentType()</h3><blockquote>
<p>设置响应的类型</p>
<p><strong>key</strong> – 内容类型，一般为 <code>text/html;charset=&#39;UTF-8&#39;</code></p>
<p>与 <code>.setCharacterEncoding()</code> 的不同处在于 <code>settContentType()</code> 还可以设置内容类型</p>
</blockquote>
<h1 id="五、HttpServletRequest"><a href="#五、HttpServletRequest" class="headerlink" title="五、HttpServletRequest"></a>五、HttpServletRequest</h1><blockquote>
<p>负责读取请求协议包信息</p>
</blockquote>
<h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 - 介绍"></a>5.1 - 介绍</h2><blockquote>
<ul>
<li>来自于 <code>Servlet</code> 规范中的一个接口，接口实现类由 <code>Tomcat</code> 负责提供</li>
<li>由 <code>HttpServletRequest</code> 接口修饰对象，可以帮助开发人员读取 <strong>请求协议包</strong> 信息</li>
<li>一般习惯于将 <code>HttpServletRequest</code> 接口修饰的丢向称为 <strong>请求对象</strong></li>
</ul>
</blockquote>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 - 方法"></a>5.2 - 方法</h2><h3 id="getRequestURL"><a href="#getRequestURL" class="headerlink" title=".getRequestURL()"></a>.getRequestURL()</h3><blockquote>
<p>获取请求的 <code>URL</code></p>
</blockquote>
<h3 id="getMethod"><a href="#getMethod" class="headerlink" title=".getMethod()"></a>.getMethod()</h3><blockquote>
<p>获取请求使用的方法</p>
</blockquote>
<h3 id="getParameterNames"><a href="#getParameterNames" class="headerlink" title=".getParameterNames();"></a>.getParameterNames();</h3><blockquote>
<p>将请求头或请求体中所有的请求参数的名字取出来，保存到一个 <code>Enumeration</code> -枚举类中</p>
</blockquote>
<h3 id="getParameter"><a href="#getParameter" class="headerlink" title=".getParameter()"></a>.getParameter()</h3><blockquote>
<p>根据参数名获取参数</p>
</blockquote>
<h3 id="getParameterValues"><a href="#getParameterValues" class="headerlink" title=".getParameterValues()"></a>.getParameterValues()</h3><blockquote>
<p>根据参数名，获取该参数名对应的所有请求值，放入一个 <code>String[]</code> 中</p>
</blockquote>
<h3 id="setCharacterEncoding-1"><a href="#setCharacterEncoding-1" class="headerlink" title=".setCharacterEncoding()"></a>.setCharacterEncoding()</h3><blockquote>
<p>设置字符编码</p>
</blockquote>
<h2 id="5-3-中文乱码问题"><a href="#5-3-中文乱码问题" class="headerlink" title="5.3 - 中文乱码问题"></a>5.3 - 中文乱码问题</h2><blockquote>
<ul>
<li>如果浏览器以<code>GET</code>方式发送请求，<strong>请求参数</strong> 在 <strong>请求头</strong> 存放在请求协议包到达服务端之后，<strong>请求头</strong> 内容是由<code>Tomcat</code>负责解析，<code>Tomcat</code>在解析数据时，默认采用的字符集<code>utf-8</code>，所以如果浏览器以<code>GET</code>方式发送中文参数，此时在服务端不会出现中文乱码问题</li>
<li>如果浏览器以<code>POST</code>方式发送请求，<strong>请求参数</strong> 在 <strong>请求体</strong> 存放在请求协议包到达服务端之后，<strong>请求体</strong> 内容是由对应请求对象<code>request</code>负责解码的。<code>request</code>对 象默认使用<code>IS0-8859-1</code> 字符集所以如果浏览器以<code>post</code>方式发送中文参数，此时在服务端必须会出现中文乱码问题</li>
</ul>
</blockquote>
<h1 id="六、ServletContext"><a href="#六、ServletContext" class="headerlink" title="六、ServletContext"></a>六、ServletContext</h1><blockquote>
<p>可以为当前网站中所有的 <code>Servlet</code> 提供 <strong>共享数据</strong></p>
</blockquote>
<h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 - 介绍"></a>6.1 - 介绍</h2><blockquote>
<ul>
<li><code>Servlet</code> 规范中的一个接口，接口实现类由 <code>Tomcat</code> 提供</li>
<li>负责为当前工程所有 <code>Servlet</code> 提供 <strong>共享数据</strong></li>
<li>开发人员习惯于将 <code>ServletContext</code> 接口修饰对象称为 <strong>全局作用域对象</strong></li>
</ul>
</blockquote>
<h2 id="6-2-生命周期"><a href="#6-2-生命周期" class="headerlink" title="6.2 - 生命周期"></a>6.2 - 生命周期</h2><blockquote>
<ul>
<li><strong>全局作用域对象</strong> 在 <code>Tomcat</code> 启动时，由 <code>Tomcat</code> 为当前网站来创建</li>
<li>一个网站只能由一个全局作用域对象</li>
<li>从网站启动开始，一直到网站关闭，由 <code>Tomcat</code> 负责销毁当前网站的全局作用域对象</li>
</ul>
</blockquote>
<h2 id="6-3-方法"><a href="#6-3-方法" class="headerlink" title="6.3 - 方法"></a>6.3 - 方法</h2><h3 id="ServletContext-application-request-getServletContext"><a href="#ServletContext-application-request-getServletContext" class="headerlink" title="ServletContext application = request.getServletContext()"></a>ServletContext application = request.getServletContext()</h3><blockquote>
<p>获取 <strong>全局作用域对象</strong></p>
</blockquote>
<h3 id="applicaion-getAttribute"><a href="#applicaion-getAttribute" class="headerlink" title="applicaion.getAttribute()"></a>applicaion.getAttribute()</h3><blockquote>
<p>获取后来由程序写入的对象</p>
</blockquote>
<h3 id="applicaiont-getInitParameter"><a href="#applicaiont-getInitParameter" class="headerlink" title="applicaiont.getInitParameter()"></a>applicaiont.getInitParameter()</h3><blockquote>
<p>获取由配置文件配置的对象</p>
</blockquote>
<h2 id="6-4-配置文件方式创建"><a href="#6-4-配置文件方式创建" class="headerlink" title="6.4 - 配置文件方式创建"></a>6.4 - 配置文件方式创建</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>···<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>···<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- 只能读，不能写</span><br></pre></td></tr></table></figure>
<h2 id="6-5-程序存入来创建"><a href="#6-5-程序存入来创建" class="headerlink" title="6.5 - 程序存入来创建"></a>6.5 - 程序存入来创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;param-name&quot;</span>, <span class="string">&quot;param-value&quot;</span>);</span><br><span class="line"></span><br><span class="line">- 能读能写</span><br></pre></td></tr></table></figure>
<h1 id="七、Cookie"><a href="#七、Cookie" class="headerlink" title="七、Cookie"></a>七、Cookie</h1><blockquote>
<p>在一次会话过程中，存储浏览器在服务端产生的私人数据</p>
</blockquote>
<h2 id="7-1-什么是会话"><a href="#7-1-什么是会话" class="headerlink" title="7.1 - 什么是会话"></a>7.1 - 什么是会话</h2><blockquote>
<ul>
<li>定义：一个浏览器与一个服务端的一次完整的交流</li>
<li>特点：<ul>
<li>在一次会话过程中，经历多次请求与响应</li>
<li>在一次会话过程中，同一个浏览器往往访问多个 <code>Servlet</code></li>
</ul>
</li>
<li>需求：在一次会话过程中，在浏览器要访问的 <code>Servlet</code> 之间进行数据共享</li>
</ul>
</blockquote>
<h2 id="7-2-介绍"><a href="#7-2-介绍" class="headerlink" title="7.2 - 介绍"></a>7.2 - 介绍</h2><blockquote>
<ul>
<li><code>Cookie</code> 是 <code>Servlet</code> 规范提供一个工具类</li>
<li>在参与一个会话过程中 <code>Servlet</code> 之间，进行 <strong>数据共享</strong></li>
<li><code>Cookie</code> 存储在浏览器上，保存本次会话的 <strong>共享数据</strong></li>
</ul>
</blockquote>
<h2 id="7-3-工作原理"><a href="#7-3-工作原理" class="headerlink" title="7.3 - 工作原理"></a>7.3 - 工作原理</h2><blockquote>
<ul>
<li>在浏览器向 <code>Servlet</code> 发送请求时，<code>Servlet</code> 在处理期间，将当前浏览器产生的私人数据保存到 <code>Cookie</code>，然后推送到浏览器</li>
<li>当浏览器再次来访问当前网站时，会无条件将服务端之前推送的 <code>Cookie</code> 附带上，这样服务器的 <code>Servlet</code> 就会得到客户端之前的私人信息</li>
</ul>
</blockquote>
<h2 id="7-4-方法"><a href="#7-4-方法" class="headerlink" title="7.4 - 方法"></a>7.4 - 方法</h2><h3 id="Cookie-c-new-Cookie-“key”-“value”"><a href="#Cookie-c-new-Cookie-“key”-“value”" class="headerlink" title="Cookie c = new Cookie(“key”, “value”);"></a>Cookie c = new Cookie(“key”, “value”);</h3><blockquote>
<p>一个 <code>Cookie</code> 只能由一个键值对，且只能存储 <code>String</code></p>
</blockquote>
<h3 id="response-addCookie-c"><a href="#response-addCookie-c" class="headerlink" title="response.addCookie(c)"></a>response.addCookie(c)</h3><blockquote>
<p>将 <code>Cookie</code> 写入响应头</p>
</blockquote>
<h3 id="Cookie-array-request-getCookies"><a href="#Cookie-array-request-getCookies" class="headerlink" title="Cookie array[ ] = request.getCookies()"></a>Cookie array[ ] = request.getCookies()</h3><blockquote>
<p>从请求中读取 <code>Cookie</code> 数组</p>
</blockquote>
<h3 id="setMaxAge"><a href="#setMaxAge" class="headerlink" title=".setMaxAge()"></a>.setMaxAge()</h3><blockquote>
<p>设置<code>Cookie</code> 的存活时间</p>
</blockquote>
<h2 id="7-5-生命周期"><a href="#7-5-生命周期" class="headerlink" title="7.5 - 生命周期"></a>7.5 - 生命周期</h2><blockquote>
<ul>
<li>默认情况 – <code>Cookie</code> 保存在浏览器内存，浏览器关闭时，<code>Cookie</code> 会被 <code>Windows</code> 销毁</li>
<li>人工干预 – 将 <code>Cookie</code> 保存在客户端存储器上，同时设置 <code>Cookie</code> 的存活时间 (单位：s)</li>
</ul>
</blockquote>
<h1 id="八、HttpSession"><a href="#八、HttpSession" class="headerlink" title="八、HttpSession"></a>八、HttpSession</h1><blockquote>
<p>在一次会话过程中，存储浏览器在服务端产生的私人数据</p>
</blockquote>
<h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 - 介绍"></a>8.1 - 介绍</h2><blockquote>
<ul>
<li>来自于 <code>Servlet</code> 规范中的接口，接口实现类来自于 <code>Tomcat</code></li>
<li>为参与同一个会话的 <code>Servlet</code> 之间提供共享数据</li>
<li>开发人员习惯于将 <code>HttpSession</code> 接口修饰的对象称为 <strong>会话作用域对象</strong> 或 <strong>session对象</strong> </li>
</ul>
</blockquote>
<h2 id="8-2-与-Cookie-的区别"><a href="#8-2-与-Cookie-的区别" class="headerlink" title="8.2 - 与 Cookie 的区别"></a>8.2 - 与 Cookie 的区别</h2><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>为参与同一个会话的 <code>Servlet</code> 之间提供共享数据</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><code>Cookie</code> 存在于客户端的浏览器或存储器</li>
<li><code>HttpSession</code>存在于服务端计算机的内存</li>
<li><code>Cookie</code> 只能存储 <code>String</code> 型</li>
<li><code>HttpSession</code> 可以存储任意类型</li>
<li><code>Cookie</code> 只能存储一个键值对</li>
<li><code>HttpSession</code> 可以存储任意个数的键值对</li>
</ul>
</blockquote>
<h2 id="8-3-方法"><a href="#8-3-方法" class="headerlink" title="8.3 - 方法"></a>8.3 - 方法</h2><blockquote>
<ul>
<li>在浏览器来访时，<code>Tomcat</code>不会主动为当前浏览器创建对应的<code>HttpSession</code>对象</li>
<li>只有一个浏览器所访问的 <code>Servlet</code> 向 <code>Tomcat</code> 提出要求时，<code>Tomcat</code> 才会为当前浏览器创建一个<code>HttpSession</code> 对象</li>
<li>如何在<code>Servlet</code>中为当前浏览器申请一个<code>HttpSession</code>对象</li>
</ul>
</blockquote>
<h3 id="getSession-getSession-true"><a href="#getSession-getSession-true" class="headerlink" title=".getSession() / .getSession(true)"></a>.getSession() / .getSession(true)</h3><blockquote>
<ul>
<li>如果当前浏览器在服务端已经有了一个<code>Session</code>，则将这个<code>Session</code>对象返回，否则创建一个全新的<code>Session</code>对象返回</li>
<li>一般用于用户身份已经确认合法的情况下</li>
</ul>
</blockquote>
<h3 id="getSession-false"><a href="#getSession-false" class="headerlink" title=".getSession(false)"></a>.getSession(false)</h3><blockquote>
<ul>
<li>如果当前浏览器在服务端已经有了一个<code>Session</code>，则将这个<code>Session</code>对象返回，否则返回一个<code>null</code></li>
<li>一般用于用户身份不确认的情况下</li>
</ul>
</blockquote>
<h3 id="setAttribute-“key”-value"><a href="#setAttribute-“key”-value" class="headerlink" title=".setAttribute(“key”, value)"></a>.setAttribute(“key”, value)</h3><blockquote>
<p>将键值对放入 <code>Session</code>对象</p>
</blockquote>
<h3 id="getAttribute-“key”"><a href="#getAttribute-“key”" class="headerlink" title=".getAttribute(“key”)"></a>.getAttribute(“key”)</h3><blockquote>
<p>根据<code>key</code>从<code>Seesion</code>对象获取数据</p>
</blockquote>
<h1 id="九、HTTP-状态码"><a href="#九、HTTP-状态码" class="headerlink" title="九、HTTP 状态码"></a>九、HTTP 状态码</h1><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 - 介绍"></a>9.1 - 介绍</h2><blockquote>
<ul>
<li><code>Http</code>状态码是由一个三位数字组成的符号</li>
<li><code>Http</code> 状态码由<code>Tomcat</code> 负责创建生成</li>
<li><code>Http</code> 状态码由<code>Tomcat</code> 写入到状态行</li>
<li><code>Http</code> 状态码通知浏览器在接到相应包之后的行为</li>
<li><code>Http</code> 状态码通知浏览器服务端无法提供本次服务的原因</li>
</ul>
</blockquote>
<h2 id="9-2-1××"><a href="#9-2-1××" class="headerlink" title="9.2 - 1××"></a>9.2 - 1××</h2><blockquote>
<p>通知浏览器本次返回的资源文件并不完整，需要浏览器继续向服务器发送申请</p>
</blockquote>
<h2 id="9-3-2××"><a href="#9-3-2××" class="headerlink" title="9.3 - 2××"></a>9.3 - 2××</h2><blockquote>
<p>通知浏览器，服务端将一个完整的文件推给了浏览器</p>
<ul>
<li>200 – 完美状态</li>
</ul>
</blockquote>
<h2 id="9-4-3××"><a href="#9-4-3××" class="headerlink" title="9.4 - 3××"></a>9.4 - 3××</h2><blockquote>
<p>服务端推给浏览器的是一个网址，要求浏览器在接收到这个网址后立刻自动向这个网址发送请求</p>
</blockquote>
<h2 id="9-5-4××"><a href="#9-5-4××" class="headerlink" title="9.5 - 4××"></a>9.5 - 4××</h2><blockquote>
<p>通知浏览器服务端本次未能提供服务的原因，是由于服务端没有对应的资源文件</p>
<ul>
<li>404 - 服务端没有对应的资源文件</li>
<li>405 - 服务端有本次请求对应的<code>Servlet</code>但是<code>Servlet</code>不负责处理这个请求</li>
</ul>
</blockquote>
<h2 id="9-6-5××"><a href="#9-6-5××" class="headerlink" title="9.6 - 5××"></a>9.6 - 5××</h2><blockquote>
<p>通知浏览器服务端本次未能提供服务的原因，被调用<code>Servlet</code>在运行中出了异常</p>
</blockquote>
<h1 id="十、重定向与请求转发"><a href="#十、重定向与请求转发" class="headerlink" title="十、重定向与请求转发"></a>十、重定向与请求转发</h1><h2 id="10-1-前提"><a href="#10-1-前提" class="headerlink" title="10.1 - 前提"></a>10.1 - 前提</h2><blockquote>
<ul>
<li>一个<code>Servlet</code>只负责实现一个功能</li>
<li>浏览器在一次请求时，只能请求一个资源文件</li>
<li>如果浏览器的请求需要由多个<code>Servlet</code>协同完成，需要用户多次手动提交，这样降低服务质量</li>
</ul>
</blockquote>
<h2 id="10-2-方案"><a href="#10-2-方案" class="headerlink" title="10.2 - 方案"></a>10.2 - 方案</h2><blockquote>
<ul>
<li>重定向方案</li>
<li>请求转发方案</li>
</ul>
</blockquote>
<h2 id="10-3-重定向"><a href="#10-3-重定向" class="headerlink" title="10.3 - 重定向"></a>10.3 - 重定向</h2><h3 id="10-3-1-原理"><a href="#10-3-1-原理" class="headerlink" title="10.3.1 - 原理"></a>10.3.1 - 原理</h3><blockquote>
<p>在第一个<code>Servlet</code>工作完毕后，将第二个<code>Servlet</code>地址推送给浏览器，由用户浏览器根据这个地址来自动向第二个<code>Servlet</code>发送请求</p>
</blockquote>
<h3 id="10-3-2-特征"><a href="#10-3-2-特征" class="headerlink" title="10.3.2 - 特征"></a>10.3.2 - 特征</h3><blockquote>
<ul>
<li><strong>发生为止</strong> – 客户端浏览器</li>
<li><strong>浏览器发送的请求次数</strong> – 多次</li>
<li><strong>地址栏变化</strong> – 是</li>
<li><strong>重定向采取的请求方式</strong> – <code>GET</code></li>
<li><strong>重定向时访问资源文件的范围</strong> – 可以是同一个网站的资源，也可以是其他网站的资源</li>
</ul>
</blockquote>
<h3 id="10-3-3-response-sendRedirect-第二个-Servlet-地址"><a href="#10-3-3-response-sendRedirect-第二个-Servlet-地址" class="headerlink" title="10.3.3 - response.sendRedirect(第二个 Servlet 地址);"></a>10.3.3 - response.sendRedirect(第二个 Servlet 地址);</h3><blockquote>
<p>将一个地址写入到 <strong>响应头</strong> 中 <code>Location</code> ，浏览器接收到响应包之后，自动根据 <code>Location</code> 地址发送第二次请求，这样的好处是避免用户多次手动发送请求</p>
</blockquote>
<h2 id="10-4-请求转发"><a href="#10-4-请求转发" class="headerlink" title="10.4 - 请求转发"></a>10.4 - 请求转发</h2><h3 id="10-4-1-原理"><a href="#10-4-1-原理" class="headerlink" title="10.4.1 - 原理"></a>10.4.1 - 原理</h3><blockquote>
<ul>
<li>在第一个<code>Servlet</code>工作完毕后，代替当前浏览器向<code>Tomcat</code>申请调用第二个<code>Servlet</code></li>
<li><code>Tomcat</code>在接收到申请之后，调用第二个<code>Servlet</code>来完成本次请求中剩余任务</li>
</ul>
</blockquote>
<h3 id="10-4-2-特征"><a href="#10-4-2-特征" class="headerlink" title="10.4.2 - 特征"></a>10.4.2 - 特征</h3><blockquote>
<ul>
<li><strong>发生位置</strong> – 服务器</li>
<li><strong>浏览器发送请求次数</strong> – 一次</li>
<li><strong>地址栏变化</strong> – 否</li>
<li><strong>调用文件范围</strong> – 只能访问同一网站的内部资源文件</li>
<li><strong>请求转发的请求方式</strong> – 与浏览器第一次发送的方式保持一致，参与同义词请求转发的所有<code>Servlet</code>接收的请求都是一样的</li>
<li><strong>如何共享数据</strong> – 全局作用域对象、会话作用域对象、请求作用域对象</li>
</ul>
</blockquote>
<h3 id="10-4-3-request-getRequestDisoatcher-第二个-Servlet-地址-forward-request-response"><a href="#10-4-3-request-getRequestDisoatcher-第二个-Servlet-地址-forward-request-response" class="headerlink" title="10.4.3 - request.getRequestDisoatcher(第二个 Servlet 地址).forward(request, response)"></a>10.4.3 - request.getRequestDisoatcher(第二个 Servlet 地址).forward(request, response)</h3><blockquote>
<p>从响应头获取<code>RequestDisoatcher</code>对象，写入第二个<code>Servlet</code>地址并转发请求</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">承影</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cyingk.github.io/2020/01/31/Servlet/">http://cyingk.github.io/2020/01/31/Servlet/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cyingk.github.io" target="_blank">Cin's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaEE/">JavaEE</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/01/Struts2/"><img class="prev-cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/struts2-2020-02-01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Struts2框架</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/27/Spring/"><img class="next-cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/springframework-2020-01-27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring框架</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/08/06/初识·Docker/" title="初识·Docker"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/docker-2020-08-06.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-06</div><div class="title">初识·Docker</div></div></a></div><div><a href="/2020/05/05/SpringCloud/" title="SpringCloud微服务"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/SpringCloud-2020-05-05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-05</div><div class="title">SpringCloud微服务</div></div></a></div><div><a href="/2020/04/05/SpringBoot/" title="SpringBoot框架"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/springboot-2020-04-05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-05</div><div class="title">SpringBoot框架</div></div></a></div><div><a href="/2020/02/20/Mybatis/" title="MyBatis"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/mybatis-2020-02-20.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-20</div><div class="title">MyBatis</div></div></a></div><div><a href="/2020/02/16/SpringMVC/" title="SpringMVC框架"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/springmvc-2020-02-16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-16</div><div class="title">SpringMVC框架</div></div></a></div><div><a href="/2020/02/15/Hibernate/" title="Hibernate"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/hibernate-2020-02-15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">Hibernate</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Servlet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-Web-%E5%BC%80%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">一、Java Web 开发核心知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-Web-%E5%BC%80%E5%8F%91"><span class="toc-text">1.1 - 什么是 Web 开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Web-%E9%80%9A%E4%BF%A1%E4%B8%AD%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">1.2 - Web 通信中两台计算机之间的角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">1.3 - 资源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">1.3.1 - 静态资源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">1.3.2 - 动态资源文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Web-%E9%80%9A%E4%BF%A1%E4%B8%AD%EF%BC%8C%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">1.4 - Web 通信中，两台计算机如何进行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-C-S-%E7%BB%93%E6%9E%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">1.4.1 - C&#x2F;S 结构通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-B-S"><span class="toc-text">1.4.2 - B&#x2F;S</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85"><span class="toc-text">1.5 - 网络协议包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.5.1 - 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E5%88%86%E7%B1%BB"><span class="toc-text">1.5.2 - 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.5.3 - 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-HTTP-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1.6 - HTTP 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%8C%85"><span class="toc-text">1.6.1 - 请求协议包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-1-%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-text">1.6.1.1 - 请求行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-2-%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">1.6.1.2 - 请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-3-%E7%A9%BA%E7%99%BD%E8%A1%8C"><span class="toc-text">1.6.1.3 - 空白行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-4-%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">1.6.1.4 - 请求体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%8C%85"><span class="toc-text">1.6.2 - 响应协议包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-1-%E7%8A%B6%E6%80%81%E8%A1%8C"><span class="toc-text">1.6.2.1 - 状态行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-2-%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">1.6.2.2 - 响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-3-%E7%A9%BA%E7%99%BD%E8%A1%8C"><span class="toc-text">1.6.2.3 - 空白行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-4-%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-text">1.6.2.4 - 响应体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-text">1.7 - 请求方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-1-GET"><span class="toc-text">1.7.1 - GET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-2-POST"><span class="toc-text">1.7.2 - POST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-text">1.8 - 控制浏览器的请求方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-GET"><span class="toc-text">1.8.1 - GET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-POST"><span class="toc-text">1.8.2 - POST</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">二、HTTP 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%88%86%E7%B1%BB"><span class="toc-text">2.2 - 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Tomcat-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.3 - Tomcat 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BD%91%E7%AB%99"><span class="toc-text">2.4 - 网站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%BD%91%E7%AB%99%E5%88%86%E7%B1%BB"><span class="toc-text">2.5 - 网站分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Servlet-%E8%A7%84%E8%8C%83"><span class="toc-text">三、Servlet 规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-JavaEE-%E4%B8%8E-JavaSE-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.1 - JavaEE 与 JavaSE 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Servlet-%E8%A7%84%E8%8C%83"><span class="toc-text">3.2 - Servlet 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%88%9B%E5%BB%BA-Servlet-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">3.3 - 创建 Servlet 实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Tomcat-%E8%B0%83%E7%94%A8-Serlvet-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">3.4 - Tomcat 调用 Serlvet 接口实现类流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Servlet-%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%86%99%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-text">3.5 - Servlet 请求路径写法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%85%B7%E4%BD%93%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84"><span class="toc-text">3.5.1 - 具体请求路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%89%8D%E7%BD%AE%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84"><span class="toc-text">3.5.2 - 前置请求路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E5%90%8E%E7%BD%AE%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84"><span class="toc-text">3.5.3 - 后置请求路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84"><span class="toc-text">3.5.4 - 通配符请求路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Servlet-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.6 - Servlet 实例对象的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.7 - 请求对象与响应对象生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81HttpServletResponse"><span class="toc-text">四、HttpServletResponse</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.1 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%96%B9%E6%B3%95"><span class="toc-text">4.2 - 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setCharacterEncoding"><span class="toc-text">.setCharacterEncoding()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getWriter"><span class="toc-text">.getWriter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setContentType"><span class="toc-text">.setContentType()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81HttpServletRequest"><span class="toc-text">五、HttpServletRequest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.1 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%96%B9%E6%B3%95"><span class="toc-text">5.2 - 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getRequestURL"><span class="toc-text">.getRequestURL()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getMethod"><span class="toc-text">.getMethod()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getParameterNames"><span class="toc-text">.getParameterNames();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getParameter"><span class="toc-text">.getParameter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getParameterValues"><span class="toc-text">.getParameterValues()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setCharacterEncoding-1"><span class="toc-text">.setCharacterEncoding()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">5.3 - 中文乱码问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81ServletContext"><span class="toc-text">六、ServletContext</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">6.1 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">6.2 - 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%96%B9%E6%B3%95"><span class="toc-text">6.3 - 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ServletContext-application-request-getServletContext"><span class="toc-text">ServletContext application &#x3D; request.getServletContext()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicaion-getAttribute"><span class="toc-text">applicaion.getAttribute()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicaiont-getInitParameter"><span class="toc-text">applicaiont.getInitParameter()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="toc-text">6.4 - 配置文件方式创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%85%A5%E6%9D%A5%E5%88%9B%E5%BB%BA"><span class="toc-text">6.5 - 程序存入来创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Cookie"><span class="toc-text">七、Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D"><span class="toc-text">7.1 - 什么是会话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.2 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">7.3 - 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E6%96%B9%E6%B3%95"><span class="toc-text">7.4 - 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-c-new-Cookie-%E2%80%9Ckey%E2%80%9D-%E2%80%9Cvalue%E2%80%9D"><span class="toc-text">Cookie c &#x3D; new Cookie(“key”, “value”);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#response-addCookie-c"><span class="toc-text">response.addCookie(c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-array-request-getCookies"><span class="toc-text">Cookie array[ ] &#x3D; request.getCookies()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setMaxAge"><span class="toc-text">.setMaxAge()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">7.5 - 生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81HttpSession"><span class="toc-text">八、HttpSession</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">8.1 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E4%B8%8E-Cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.2 - 与 Cookie 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%96%B9%E6%B3%95"><span class="toc-text">8.3 - 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getSession-getSession-true"><span class="toc-text">.getSession() &#x2F; .getSession(true)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSession-false"><span class="toc-text">.getSession(false)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setAttribute-%E2%80%9Ckey%E2%80%9D-value"><span class="toc-text">.setAttribute(“key”, value)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getAttribute-%E2%80%9Ckey%E2%80%9D"><span class="toc-text">.getAttribute(“key”)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">九、HTTP 状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">9.1 - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-1%C3%97%C3%97"><span class="toc-text">9.2 - 1××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-2%C3%97%C3%97"><span class="toc-text">9.3 - 2××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-3%C3%97%C3%97"><span class="toc-text">9.4 - 3××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-4%C3%97%C3%97"><span class="toc-text">9.5 - 4××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-5%C3%97%C3%97"><span class="toc-text">9.6 - 5××</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91"><span class="toc-text">十、重定向与请求转发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%89%8D%E6%8F%90"><span class="toc-text">10.1 - 前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%96%B9%E6%A1%88"><span class="toc-text">10.2 - 方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">10.3 - 重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-1-%E5%8E%9F%E7%90%86"><span class="toc-text">10.3.1 - 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-2-%E7%89%B9%E5%BE%81"><span class="toc-text">10.3.2 - 特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-3-response-sendRedirect-%E7%AC%AC%E4%BA%8C%E4%B8%AA-Servlet-%E5%9C%B0%E5%9D%80"><span class="toc-text">10.3.3 - response.sendRedirect(第二个 Servlet 地址);</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91"><span class="toc-text">10.4 - 请求转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-1-%E5%8E%9F%E7%90%86"><span class="toc-text">10.4.1 - 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-2-%E7%89%B9%E5%BE%81"><span class="toc-text">10.4.2 - 特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-3-request-getRequestDisoatcher-%E7%AC%AC%E4%BA%8C%E4%B8%AA-Servlet-%E5%9C%B0%E5%9D%80-forward-request-response"><span class="toc-text">10.4.3 - request.getRequestDisoatcher(第二个 Servlet 地址).forward(request, response)</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">爱你所爱 | 行你所行 | 听从你心 | 无问西东</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>