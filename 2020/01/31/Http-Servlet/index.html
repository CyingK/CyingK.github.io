<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  

  

  
    <meta name="author" content="Cying-承影">
  

  

  

  <title>Http Servlet | Cying</title>

  

  
    <link rel="icon" href="/favicon.ico">
  

  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.6/styles/default.min.css" rel="stylesheet">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div class="root-container">
    <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          Cying
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
      </ul>
    </div>
  </div>
</nav>

    
<!-- header container -->
<header class="header-container post">

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-image" style="background-image: url(https://5b0988e595225.cdn.sohucs.com/images/20190831/84729f5c5bb346208416445feb485df6.jpeg)"></div>
      <div class="post-text">
        <div class="type-wrap">
          <a class="article-category-link" href="/categories/Frame/">Frame</a>
        </div>
        <h1 class="title-wrap">Http Servlet</h1>
        <h2 class="title-sub-wrap">
          <strong>Cying-承影</strong>
          <span>发布于</span>
          
  <a href="javascript:;" class="article-date">
    <time datetime="2020-01-30T17:26:09.000Z" itemprop="datePublished">2020-01-31</time>
  </a>

        </h2>
      </div>
    </div>
  

  
  

  </header>

    <!-- 文章 -->

<!-- 文章内容 -->

<div class="body-container">
  <article class="content-container article-container">
    <div class="article-content">
      
      

      <div class="article-entry">
        <h1><center>Servlet</center></h1>

<h1 id="一、Java-Web-开发核心知识点"><a href="#一、Java-Web-开发核心知识点" class="headerlink" title="一、Java Web 开发核心知识点"></a>一、Java Web 开发核心知识点</h1><h2 id="1-1-什么是-Web-开发"><a href="#1-1-什么是-Web-开发" class="headerlink" title="1.1 - 什么是 Web 开发"></a>1.1 - 什么是 Web 开发</h2><blockquote>
<ul>
<li><code>Web</code> 通信，指两台计算机通过计算机网络进行资源文件共享活动</li>
<li><code>Web</code>开发确保本次通信顺利执行</li>
</ul>
</blockquote>
<h2 id="1-2-Web-通信中两台计算机之间的角色"><a href="#1-2-Web-通信中两台计算机之间的角色" class="headerlink" title="1.2 - Web 通信中两台计算机之间的角色"></a>1.2 - Web 通信中两台计算机之间的角色</h2><blockquote>
<ul>
<li>客户端：用于发送请求</li>
<li>服务端：提供共享资源文件</li>
</ul>
</blockquote>
<h2 id="1-3-资源文件"><a href="#1-3-资源文件" class="headerlink" title="1.3 - 资源文件"></a>1.3 - 资源文件</h2><blockquote>
<ul>
<li>理论上来说，计算机上所有的文件都是资源共享文件</li>
</ul>
</blockquote>
<h3 id="1-3-1-静态资源文件"><a href="#1-3-1-静态资源文件" class="headerlink" title="1.3.1 - 静态资源文件"></a>1.3.1 - 静态资源文件</h3><blockquote>
<ul>
<li>文件内容是固定的，不能随请求的变化而变化</li>
<li>服务端计算机直接将<strong>静态资源文件</strong>推给<strong>客户端</strong>，所有被共享的<strong>静态资源文件</strong>最终是在<strong>客户端</strong>运行</li>
</ul>
</blockquote>
<h3 id="1-3-2-动态资源文件"><a href="#1-3-2-动态资源文件" class="headerlink" title="1.3.2 - 动态资源文件"></a>1.3.2 - 动态资源文件</h3><blockquote>
<ul>
<li>文件内容可以根据用户提供需求变化而产生不同变化内容</li>
<li>服务端会调用执行<strong>动态资源文件</strong>，服务端将<strong>动态资源文件的运行结果</strong>交给客户端</li>
</ul>
</blockquote>
<h2 id="1-4-Web-通信中，两台计算机如何进行通信"><a href="#1-4-Web-通信中，两台计算机如何进行通信" class="headerlink" title="1.4 - Web 通信中，两台计算机如何进行通信"></a>1.4 - Web 通信中，两台计算机如何进行通信</h2><h3 id="1-4-1-C-S-结构通信方式"><a href="#1-4-1-C-S-结构通信方式" class="headerlink" title="1.4.1 - C/S 结构通信方式"></a>1.4.1 - <code>C/S</code> 结构通信方式</h3><blockquote>
<p>C - <code>Client</code>，客户端计算机安装特定<strong>客户端程序</strong>，可以帮助客户端向指定服务器发送请求</p>
<p>S - <code>Server</code>，在服务端计算机安装一种特定<strong>资源调度软件</strong>接收特定客户端程序发送请求，将请求需要的资源文件推送回客户端上的<strong>客户端程序</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>可以有效的保护服务端计算机</li>
<li>可以分摊服务端计算机工作压力</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>增加客户获得服务的成本</li>
<li>增加服务端维护成本</li>
</ul>
</blockquote>
<h3 id="1-4-2-B-S"><a href="#1-4-2-B-S" class="headerlink" title="1.4.2 - B/S"></a>1.4.2 - <code>B/S</code></h3><blockquote>
<p>B - <code>Browser</code>，可以帮助客户端向任意服务端发送请求</p>
<p>S - <code>Server</code>， 在服务端安装一种特定<strong>资源调度软件</strong>，可以接收所有浏览器发送的请求，将请求的资源文件推送给客户端浏览器</p>
<p><strong>优点</strong></p>
<ul>
<li>不会增加客户获得服务的成本</li>
<li>不会增加客户端维护的成本</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>无法有效保护服务端计算机</li>
<li>无法通过客户端计算机分摊服务端的计算机压力</li>
</ul>
</blockquote>
<h2 id="1-5-网络协议包"><a href="#1-5-网络协议包" class="headerlink" title="1.5 - 网络协议包"></a>1.5 - 网络协议包</h2><h3 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 - 定义"></a>1.5.1 - 定义</h3><blockquote>
<p>用于包裹在网络中传输二进制</p>
</blockquote>
<h3 id="1-5-2-分类"><a href="#1-5-2-分类" class="headerlink" title="1.5.2 - 分类"></a>1.5.2 - 分类</h3><blockquote>
<ul>
<li><code>FTP</code></li>
<li><code>HTTP</code></li>
</ul>
</blockquote>
<h3 id="1-5-3-注意事项"><a href="#1-5-3-注意事项" class="headerlink" title="1.5.3 - 注意事项"></a>1.5.3 - 注意事项</h3><blockquote>
<p><code>B/S</code> 到目前为止指使用<code>HTTP</code> 网络协议包</p>
</blockquote>
<h2 id="1-6-HTTP-内部结构"><a href="#1-6-HTTP-内部结构" class="headerlink" title="1.6 - HTTP 内部结构"></a>1.6 - HTTP 内部结构</h2><h3 id="1-6-1-请求协议包"><a href="#1-6-1-请求协议包" class="headerlink" title="1.6.1 - 请求协议包"></a>1.6.1 - 请求协议包</h3><blockquote>
<ul>
<li>是浏览器在发送请求时创建的</li>
<li>是浏览器负责将请求信息，写入到请求协议包</li>
<li><code>HTTP</code> 请求协议包内部自上而下有四层结构</li>
</ul>
</blockquote>
<h4 id="1-6-1-1-请求行"><a href="#1-6-1-1-请求行" class="headerlink" title="1.6.1.1 - 请求行"></a>1.6.1.1 - 请求行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	URL: 请求的资源文件地址</span><br><span class="line">	METHOD: 浏览器采用的请求方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-2-请求头"><a href="#1-6-1-2-请求头" class="headerlink" title="1.6.1.2 - 请求头"></a>1.6.1.2 - 请求头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	浏览器希望获得资源文件类型</span><br><span class="line">	浏览器希望获得资源文件内容依赖字符集</span><br><span class="line">	如果浏览器采用 GET 方式，本次关联请求参数需要保存在请求头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-3-空白行"><a href="#1-6-1-3-空白行" class="headerlink" title="1.6.1.3 - 空白行"></a>1.6.1.3 - 空白行</h4><blockquote>
<p>隔离层</p>
</blockquote>
<h4 id="1-6-1-4-请求体"><a href="#1-6-1-4-请求体" class="headerlink" title="1.6.1.4 - 请求体"></a>1.6.1.4 - 请求体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	如果浏览器采用 POST 方式发送请求，本次关联请求参数保存在请求体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-响应协议包"><a href="#1-6-2-响应协议包" class="headerlink" title="1.6.2 - 响应协议包"></a>1.6.2 - 响应协议包</h3><blockquote>
<ul>
<li>在服务端计算机的<strong>资源调度软件</strong>准备推送文件时负责创建</li>
<li><strong>响应协议包内容</strong>可以有<strong>资源调度软件</strong>写入，可以由 <code>Java</code> 命令写入</li>
<li><code>HTTP</code> 请求协议包内部自上而下有四层结构</li>
</ul>
</blockquote>
<h4 id="1-6-2-1-状态行"><a href="#1-6-2-1-状态行" class="headerlink" title="1.6.2.1 - 状态行"></a>1.6.2.1 - 状态行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	状态码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-2-响应头"><a href="#1-6-2-2-响应头" class="headerlink" title="1.6.2.2 - 响应头"></a>1.6.2.2 - 响应头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	返回文件内容类型 (doc,text,html,text&#x2F;html)</span><br><span class="line">	返回文件内容依赖字符集</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-3-空白行"><a href="#1-6-2-3-空白行" class="headerlink" title="1.6.2.3 - 空白行"></a>1.6.2.3 - 空白行</h4><h4 id="1-6-2-4-响应体"><a href="#1-6-2-4-响应体" class="headerlink" title="1.6.2.4 - 响应体"></a>1.6.2.4 - 响应体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	静态资源文件也可能时动态资源文件运行结果 (二进制)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-请求方式"><a href="#1-7-请求方式" class="headerlink" title="1.7 - 请求方式"></a>1.7 - 请求方式</h2><h3 id="1-7-1-GET"><a href="#1-7-1-GET" class="headerlink" title="1.7.1 - GET"></a>1.7.1 - GET</h3><blockquote>
<ul>
<li>要求浏览器发送请求时，携带请求参数数量不能操作 4<code>K</code></li>
<li>要求浏览器将请求参数写入到<strong>请求头</strong></li>
<li>要求浏览器将请求参数信息在地址栏显示出来</li>
<li>要求浏览器对接收的资源文件必须缓存到内存</li>
</ul>
</blockquote>
<h3 id="1-7-2-POST"><a href="#1-7-2-POST" class="headerlink" title="1.7.2 - POST"></a>1.7.2 - POST</h3><blockquote>
<ul>
<li>不会限制浏览器发送请求时，携带请求参数数量</li>
<li>要求浏览器将请求参数写入<strong>请求体</strong></li>
<li>要求浏览器将请求参数在地址栏隐藏</li>
<li>要求浏览器对接收的文件不能保存到缓存</li>
</ul>
</blockquote>
<h2 id="1-8-控制浏览器的请求方式"><a href="#1-8-控制浏览器的请求方式" class="headerlink" title="1.8 - 控制浏览器的请求方式"></a>1.8 - 控制浏览器的请求方式</h2><h3 id="1-8-1-GET"><a href="#1-8-1-GET" class="headerlink" title="1.8.1 - GET"></a>1.8.1 - GET</h3><blockquote>
<ul>
<li>超链接</li>
<li><code>localtion</code> 对象</li>
<li>表单中的 <code>Method</code> 属性可以设置为 <code>GET</code></li>
</ul>
</blockquote>
<h3 id="1-8-2-POST"><a href="#1-8-2-POST" class="headerlink" title="1.8.2 - POST"></a>1.8.2 - POST</h3><blockquote>
<ul>
<li>表单中的 <code>Method</code> 属性可以设置为 <code>POST</code></li>
</ul>
</blockquote>
<h1 id="二、HTTP-服务器"><a href="#二、HTTP-服务器" class="headerlink" title="二、HTTP 服务器"></a>二、HTTP 服务器</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 - 介绍"></a>2.1 - 介绍</h2><blockquote>
<ul>
<li>安装在服务端计算机上的一种软件</li>
<li>可以解析来自于浏览器发送的<strong>请求协议包</strong></li>
<li>调用服务端上被请求的<strong>资源共享文件</strong></li>
<li>负责生成一个<strong>响应协议包</strong></li>
<li>负责将<strong>文件内容</strong>或者<strong>文件运行结果</strong>写入到<strong>响应体</strong></li>
<li>负责将<strong>响应协议包</strong>推送给<strong>当前浏览器</strong></li>
</ul>
</blockquote>
<h2 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 - 分类"></a>2.2 - 分类</h2><blockquote>
<ul>
<li>德国 – SAP</li>
<li>IBM – WebLogic</li>
<li>JBOSS – JBOSS</li>
<li>Apache – Tomcat – 单位时间内大约 1200 次请求</li>
</ul>
</blockquote>
<h2 id="2-3-Tomcat-介绍"><a href="#2-3-Tomcat-介绍" class="headerlink" title="2.3 - Tomcat 介绍"></a>2.3 - Tomcat 介绍</h2><blockquote>
<ul>
<li>是一个由 <code>Java</code> 应用程序编写的资源文件调度器</li>
<li>可以调用服务端静态资源文件和<strong>动态资源文件</strong></li>
<li><code>Tomcat</code> 负责生成响应协议包，负责将响应协议包推送到浏览器</li>
<li><code>Tomcat</code> 属于 <code>Apache</code></li>
</ul>
</blockquote>
<h2 id="2-4-网站"><a href="#2-4-网站" class="headerlink" title="2.4 - 网站"></a>2.4 - 网站</h2><blockquote>
<ul>
<li>全称：网络中的资源站点</li>
<li>作用：仓库，存储可以共享<strong>静态资源文件</strong>和<strong>动态资源文件</strong></li>
<li>文件管理：由 <code>HTTP</code> 服务器来调用内部共享资源文件</li>
<li>本质：就是一个文件夹</li>
</ul>
</blockquote>
<h2 id="2-5-网站分类"><a href="#2-5-网站分类" class="headerlink" title="2.5 - 网站分类"></a>2.5 - 网站分类</h2><blockquote>
<ul>
<li>静态资源网站：存储都是静态资源文件</li>
<li>动态资源网站：存储的是静态资源和动态资源</li>
</ul>
</blockquote>
<h1 id="三、Servlet-规范"><a href="#三、Servlet-规范" class="headerlink" title="三、Servlet 规范"></a>三、Servlet 规范</h1><h2 id="3-1-JavaEE-与-JavaSE-的区别"><a href="#3-1-JavaEE-与-JavaSE-的区别" class="headerlink" title="3.1 - JavaEE 与 JavaSE 的区别"></a>3.1 - JavaEE 与 JavaSE 的区别</h2><blockquote>
<ul>
<li><code>JavaEE</code> – 企业级开发规范</li>
<li><code>JavaSE</code> – 基本开发规范，制定了管理系统与 13 类系统之间的交流规则</li>
</ul>
</blockquote>
<h2 id="3-2-Servlet-规范"><a href="#3-2-Servlet-规范" class="headerlink" title="3.2 - Servlet 规范"></a>3.2 - Servlet 规范</h2><blockquote>
<ul>
<li><code>Servlet</code> 规范是 <code>JavaEE</code> 规范中的一种</li>
<li><code>Servlet</code> 规范中设置 <code>JVM</code> 与 <code>Http</code> 服务器的交流规则<ul>
<li>定义何种 <code>Java</code> 类可以被 <code>HTTP</code> 服务器调用<ul>
<li>只有 <code>Servlet</code> 的实现类才有资格作为**动态共享资源文件</li>
<li><code>Servlet</code> 实现类由开发人员创建</li>
</ul>
</li>
<li><code>HTTP</code> 服务器应该如何管理 <strong>动态资源文件</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-3-创建-Servlet-实现类"><a href="#3-3-创建-Servlet-实现类" class="headerlink" title="3.3 - 创建 Servlet 实现类"></a>3.3 - 创建 Servlet 实现类</h2><blockquote>
<ul>
<li>创建一个实现类，继承 <code>HttpServlet</code></li>
<li><code>HttpServlet</code> 存在于 <code>Tomcat/lib/servlet-api.jar</code></li>
<li>根据来访的浏览器采用的请求方式，重写对应 doGet 或者 doPost</li>
<li>在 <code>WEB-INF/lib/web.xml</code> 中注册实现类，并创建匹配的对外路径</li>
</ul>
</blockquote>
<h2 id="3-4-Tomcat-调用-Serlvet-接口实现类流程"><a href="#3-4-Tomcat-调用-Serlvet-接口实现类流程" class="headerlink" title="3.4 - Tomcat 调用 Serlvet 接口实现类流程"></a>3.4 - Tomcat 调用 Serlvet 接口实现类流程</h2><p><strong>浏览器向服务器发送请求</strong></p>
<p><strong><code>Tomcat</code> 接收到这个请求</strong></p>
<blockquote>
<p>首先将请求资源文件作为动态资源文件。到 <code>web.xml</code> 进行文件定位。如果有则调用，如果没有找到对应的动态资源文件，此时 <code>Tomcat</code> 认为本次请求的是一个静态资源文件，从 <code>web</code> 下进行定位。如果有则返回，如果还是没有，则返回 <code>404</code> </p>
</blockquote>
<p><strong><code>Tomcat</code> 定位到 <code>web.xml</code> 根据 <code>&lt;url-pattern/&gt;</code> 进行定位 <code>&lt;servlet-name/&gt;</code></strong></p>
<p><strong><code>&lt;servlet-name/&gt;</code> 定位 <code>&lt;servlet-class/&gt;</code> 找到本次请求的 <code>Servlet</code></strong></p>
<p><strong><code>Tomcat</code> 根据浏览器采用的请求方式，调用 <code>Servlet</code> 的 <code>doGet</code> 或者 <code>doPost</code> 方法</strong></p>
<p><strong>当 <code>doGet</code> 或者 <code>doPost</code> 调用完毕，<code>Tomcat</code> 负责将相应包推送给浏览器</strong></p>
<h2 id="3-5-Servlet-请求路径写法规则"><a href="#3-5-Servlet-请求路径写法规则" class="headerlink" title="3.5 - Servlet 请求路径写法规则"></a>3.5 - Servlet 请求路径写法规则</h2><h3 id="3-5-1-具体请求路径"><a href="#3-5-1-具体请求路径" class="headerlink" title="3.5.1 - 具体请求路径"></a>3.5.1 - 具体请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;/path&lt;/url-partter&gt;</code></p>
<p>浏览器请求的 <strong>资源文件地址</strong> 与 <code>&lt;url-partter/&gt;</code> 的内容完全一致</p>
<p><strong>优先级最高</strong></p>
</blockquote>
<h3 id="3-5-2-前置请求路径"><a href="#3-5-2-前置请求路径" class="headerlink" title="3.5.2 - 前置请求路径"></a>3.5.2 - 前置请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;/path/*&lt;/url-partter&gt;</code></p>
<p>浏览器请求的 <strong>资源文件地址</strong> 以 <code>&lt;url-partter/&gt;</code> 的内容开头</p>
<p><strong>优先级第二</strong></p>
</blockquote>
<h3 id="3-5-3-后置请求路径"><a href="#3-5-3-后置请求路径" class="headerlink" title="3.5.3 - 后置请求路径"></a>3.5.3 - 后置请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;*path&lt;/url-partter&gt;</code></p>
<p>浏览器请求的 <strong>资源文件地址</strong> 以 <code>&lt;url-parttern/&gt;</code> 的内容结尾</p>
<p><strong>优先级最低</strong></p>
</blockquote>
<h3 id="3-5-4-通配符请求路径"><a href="#3-5-4-通配符请求路径" class="headerlink" title="3.5.4 - 通配符请求路径"></a>3.5.4 - 通配符请求路径</h3><blockquote>
<p><code>&lt;url-parttern&gt;/*&lt;/url-partter&gt;</code></p>
<p>接收来自浏览器的所有请求</p>
<p><strong>优先级第三</strong></p>
</blockquote>
<h2 id="3-6-Servlet-实例对象的生命周期"><a href="#3-6-Servlet-实例对象的生命周期" class="headerlink" title="3.6 - Servlet 实例对象的生命周期"></a>3.6 - Servlet 实例对象的生命周期</h2><blockquote>
<ul>
<li><p>项目中所有的 <code>Servlet</code> 的实例对象都是 <code>Tomcat</code> 创建的，开发人员没有权利创建</p>
</li>
<li><p>创建时机</p>
<ul>
<li><p>默认情况：当第一个用户来访问这个 <code>Servlet</code> 时，<code>Tomcat</code> 负责创建</p>
</li>
<li><p>人工干预：要求 <code>Tomcat</code> 在启动时，创建 <code>Servlet</code> 的实例对象</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>任一大于0的数<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>Tomcat</code> 运行器件，一个 <code>Servlet</code> 实现类只能被创建一个对象</p>
</li>
<li><p>在 <code>Tomcat</code> 关闭时，由 <code>Tomcat</code> 负责销毁所有 <code>Servlet</code> 实例类对象</p>
</li>
</ul>
</blockquote>
<h2 id="3-7-请求对象与响应对象生命周期"><a href="#3-7-请求对象与响应对象生命周期" class="headerlink" title="3.7 - 请求对象与响应对象生命周期"></a>3.7 - 请求对象与响应对象生命周期</h2><blockquote>
<ul>
<li>都是由 <code>Tomcat</code> 负责创建</li>
<li>每当一个 <code>Tomcat</code> 收到一个 <strong>请求协议包</strong>，就会为这个请求协议包创建一对 <strong>请求对象和响应对象</strong></li>
<li>一次请求对应一对 <strong>请求对象和响应对象</strong></li>
<li>在 <code>Tomcat</code> 调用被请求的 <code>Servlet</code> 中的 <code>doGet</code> 和 <code>doPost</code> 方法时，负责将本次 <strong>请求对象和响应对象</strong> 作为参数传入到服务方法</li>
<li>在服务方法完毕后，<code>Tomcat</code> 销毁本次请求相关的 <code>request</code> 和 <code>response</code></li>
<li>最后，<code>Tomcat</code> 负责将 <strong>相应包</strong> 推送到服务器上</li>
</ul>
</blockquote>
<h1 id="四、HttpServletResponse"><a href="#四、HttpServletResponse" class="headerlink" title="四、HttpServletResponse"></a>四、HttpServletResponse</h1><blockquote>
<p>负责将运行结果写入到相应包</p>
</blockquote>
<h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 - 介绍"></a>4.1 - 介绍</h2><blockquote>
<ul>
<li>一个来自于 <code>Servlet</code> 规范中的接口，由 <code>Tomcat</code> 负责提供这个接口实现类</li>
<li>负责在 <code>Servlet</code> 运行完毕后，将相关的数据写入到 <strong>响应头</strong> 和 <strong>响应体</strong></li>
<li>开发人员习惯于将 <code>HttpServletResponse</code> 接口修饰对象称为 <strong>响应对象</strong></li>
</ul>
</blockquote>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 - 方法"></a>4.2 - 方法</h2><h3 id="setCharacterEncoding"><a href="#setCharacterEncoding" class="headerlink" title=".setCharacterEncoding()"></a>.setCharacterEncoding()</h3><blockquote>
<p>设置字符编码</p>
<p><strong>key</strong> – 字符编码</p>
</blockquote>
<h3 id="getWriter"><a href="#getWriter" class="headerlink" title=".getWriter()"></a>.getWriter()</h3><blockquote>
<p>获取输出流</p>
</blockquote>
<h3 id="setContentType"><a href="#setContentType" class="headerlink" title=".setContentType()"></a>.setContentType()</h3><blockquote>
<p>设置响应的类型</p>
<p><strong>key</strong> – 内容类型，一般为 <code>text/html;charset=&#39;UTF-8&#39;</code></p>
<p>与 <code>.setCharacterEncoding()</code> 的不同处在于 <code>settContentType()</code> 还可以设置内容类型</p>
</blockquote>
<h1 id="五、HttpServletRequest"><a href="#五、HttpServletRequest" class="headerlink" title="五、HttpServletRequest"></a>五、HttpServletRequest</h1><blockquote>
<p>负责读取请求协议包信息</p>
</blockquote>
<h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 - 介绍"></a>5.1 - 介绍</h2><blockquote>
<ul>
<li>来自于 <code>Servlet</code> 规范中的一个接口，接口实现类由 <code>Tomcat</code> 负责提供</li>
<li>由 <code>HttpServletRequest</code> 接口修饰对象，可以帮助开发人员读取 <strong>请求协议包</strong> 信息</li>
<li>一般习惯于将 <code>HttpServletRequest</code> 接口修饰的丢向称为 <strong>请求对象</strong></li>
</ul>
</blockquote>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 - 方法"></a>5.2 - 方法</h2><h3 id="getRequestURL"><a href="#getRequestURL" class="headerlink" title=".getRequestURL()"></a>.getRequestURL()</h3><blockquote>
<p>获取请求的 <code>URL</code></p>
</blockquote>
<h3 id="getMethod"><a href="#getMethod" class="headerlink" title=".getMethod()"></a>.getMethod()</h3><blockquote>
<p>获取请求使用的方法</p>
</blockquote>
<h3 id="getParameterNames"><a href="#getParameterNames" class="headerlink" title=".getParameterNames();"></a>.getParameterNames();</h3><blockquote>
<p>将请求头或请求体中所有的请求参数的名字取出来，保存到一个 <code>Enumeration</code> -枚举类中</p>
</blockquote>
<h3 id="getParameter"><a href="#getParameter" class="headerlink" title=".getParameter()"></a>.getParameter()</h3><blockquote>
<p>根据参数名获取参数</p>
</blockquote>
<h3 id="getParameterValues"><a href="#getParameterValues" class="headerlink" title=".getParameterValues()"></a>.getParameterValues()</h3><blockquote>
<p>根据参数名，获取该参数名对应的所有请求值，放入一个 <code>String[]</code> 中</p>
</blockquote>
<h3 id="setCharacterEncoding-1"><a href="#setCharacterEncoding-1" class="headerlink" title=".setCharacterEncoding()"></a>.setCharacterEncoding()</h3><blockquote>
<p>设置字符编码</p>
</blockquote>
<h2 id="5-3-中文乱码问题"><a href="#5-3-中文乱码问题" class="headerlink" title="5.3 - 中文乱码问题"></a>5.3 - 中文乱码问题</h2><blockquote>
<ul>
<li>如果浏览器以<code>GET</code>方式发送请求，<strong>请求参数</strong> 在 <strong>请求头</strong> 存放在请求协议包到达服务端之后，<strong>请求头</strong> 内容是由<code>Tomcat</code>负责解析，<code>Tomcat</code>在解析数据时，默认采用的字符集<code>utf-8</code>，所以如果浏览器以<code>GET</code>方式发送中文参数，此时在服务端不会出现中文乱码问题</li>
<li>如果浏览器以<code>POST</code>方式发送请求，<strong>请求参数</strong> 在 <strong>请求体</strong> 存放在请求协议包到达服务端之后，<strong>请求体</strong> 内容是由对应请求对象<code>request</code>负责解码的。<code>request</code>对 象默认使用<code>IS0-8859-1</code> 字符集所以如果浏览器以<code>post</code>方式发送中文参数，此时在服务端必须会出现中文乱码问题</li>
</ul>
</blockquote>
<h1 id="六、ServletContext"><a href="#六、ServletContext" class="headerlink" title="六、ServletContext"></a>六、ServletContext</h1><blockquote>
<p>可以为当前网站中所有的 <code>Servlet</code> 提供 <strong>共享数据</strong></p>
</blockquote>
<h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 - 介绍"></a>6.1 - 介绍</h2><blockquote>
<ul>
<li><code>Servlet</code> 规范中的一个接口，接口实现类由 <code>Tomcat</code> 提供</li>
<li>负责为当前工程所有 <code>Servlet</code> 提供 <strong>共享数据</strong></li>
<li>开发人员习惯于将 <code>ServletContext</code> 接口修饰对象称为 <strong>全局作用域对象</strong></li>
</ul>
</blockquote>
<h2 id="6-2-生命周期"><a href="#6-2-生命周期" class="headerlink" title="6.2 - 生命周期"></a>6.2 - 生命周期</h2><blockquote>
<ul>
<li><strong>全局作用域对象</strong> 在 <code>Tomcat</code> 启动时，由 <code>Tomcat</code> 为当前网站来创建</li>
<li>一个网站只能由一个全局作用域对象</li>
<li>从网站启动开始，一直到网站关闭，由 <code>Tomcat</code> 负责销毁当前网站的全局作用域对象</li>
</ul>
</blockquote>
<h2 id="6-3-方法"><a href="#6-3-方法" class="headerlink" title="6.3 - 方法"></a>6.3 - 方法</h2><h3 id="ServletContext-application-request-getServletContext"><a href="#ServletContext-application-request-getServletContext" class="headerlink" title="ServletContext application = request.getServletContext()"></a>ServletContext application = request.getServletContext()</h3><blockquote>
<p>获取 <strong>全局作用域对象</strong></p>
</blockquote>
<h3 id="applicaion-getAttribute"><a href="#applicaion-getAttribute" class="headerlink" title="applicaion.getAttribute()"></a>applicaion.getAttribute()</h3><blockquote>
<p>获取后来由程序写入的对象</p>
</blockquote>
<h3 id="applicaiont-getInitParameter"><a href="#applicaiont-getInitParameter" class="headerlink" title="applicaiont.getInitParameter()"></a>applicaiont.getInitParameter()</h3><blockquote>
<p>获取由配置文件配置的对象</p>
</blockquote>
<h2 id="6-4-配置文件方式创建"><a href="#6-4-配置文件方式创建" class="headerlink" title="6.4 - 配置文件方式创建"></a>6.4 - 配置文件方式创建</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>···<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>···<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- 只能读，不能写</span><br></pre></td></tr></table></figure>

<h2 id="6-5-程序存入来创建"><a href="#6-5-程序存入来创建" class="headerlink" title="6.5 - 程序存入来创建"></a>6.5 - 程序存入来创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">"param-name"</span>, <span class="string">"param-value"</span>);</span><br><span class="line"></span><br><span class="line">- 能读能写</span><br></pre></td></tr></table></figure>

<h1 id="七、Cookie"><a href="#七、Cookie" class="headerlink" title="七、Cookie"></a>七、Cookie</h1><blockquote>
<p>在一次会话过程中，存储浏览器在服务端产生的私人数据</p>
</blockquote>
<h2 id="7-1-什么是会话"><a href="#7-1-什么是会话" class="headerlink" title="7.1 - 什么是会话"></a>7.1 - 什么是会话</h2><blockquote>
<ul>
<li>定义：一个浏览器与一个服务端的一次完整的交流</li>
<li>特点：<ul>
<li>在一次会话过程中，经历多次请求与响应</li>
<li>在一次会话过程中，同一个浏览器往往访问多个 <code>Servlet</code></li>
</ul>
</li>
<li>需求：在一次会话过程中，在浏览器要访问的 <code>Servlet</code> 之间进行数据共享</li>
</ul>
</blockquote>
<h2 id="7-2-介绍"><a href="#7-2-介绍" class="headerlink" title="7.2 - 介绍"></a>7.2 - 介绍</h2><blockquote>
<ul>
<li><code>Cookie</code> 是 <code>Servlet</code> 规范提供一个工具类</li>
<li>在参与一个会话过程中 <code>Servlet</code> 之间，进行 <strong>数据共享</strong></li>
<li><code>Cookie</code> 存储在浏览器上，保存本次会话的 <strong>共享数据</strong></li>
</ul>
</blockquote>
<h2 id="7-3-工作原理"><a href="#7-3-工作原理" class="headerlink" title="7.3 - 工作原理"></a>7.3 - 工作原理</h2><blockquote>
<ul>
<li>在浏览器向 <code>Servlet</code> 发送请求时，<code>Servlet</code> 在处理期间，将当前浏览器产生的私人数据保存到 <code>Cookie</code>，然后推送到浏览器</li>
<li>当浏览器再次来访问当前网站时，会无条件将服务端之前推送的 <code>Cookie</code> 附带上，这样服务器的 <code>Servlet</code> 就会得到客户端之前的私人信息</li>
</ul>
</blockquote>
<h2 id="7-4-方法"><a href="#7-4-方法" class="headerlink" title="7.4 - 方法"></a>7.4 - 方法</h2><h3 id="Cookie-c-new-Cookie-“key”-“value”"><a href="#Cookie-c-new-Cookie-“key”-“value”" class="headerlink" title="Cookie c = new Cookie(“key”, “value”);"></a>Cookie c = new Cookie(“key”, “value”);</h3><blockquote>
<p>一个 <code>Cookie</code> 只能由一个键值对，且只能存储 <code>String</code></p>
</blockquote>
<h3 id="response-addCookie-c"><a href="#response-addCookie-c" class="headerlink" title="response.addCookie(c)"></a>response.addCookie(c)</h3><blockquote>
<p>将 <code>Cookie</code> 写入响应头</p>
</blockquote>
<h3 id="Cookie-array-request-getCookies"><a href="#Cookie-array-request-getCookies" class="headerlink" title="Cookie array[ ] = request.getCookies()"></a>Cookie array[ ] = request.getCookies()</h3><blockquote>
<p>从请求中读取 <code>Cookie</code> 数组</p>
</blockquote>
<h3 id="setMaxAge"><a href="#setMaxAge" class="headerlink" title=".setMaxAge()"></a>.setMaxAge()</h3><blockquote>
<p>设置<code>Cookie</code> 的存活时间</p>
</blockquote>
<h2 id="7-5-生命周期"><a href="#7-5-生命周期" class="headerlink" title="7.5 - 生命周期"></a>7.5 - 生命周期</h2><blockquote>
<ul>
<li>默认情况 – <code>Cookie</code> 保存在浏览器内存，浏览器关闭时，<code>Cookie</code> 会被 <code>Windows</code> 销毁</li>
<li>人工干预 – 将 <code>Cookie</code> 保存在客户端存储器上，同时设置 <code>Cookie</code> 的存活时间 (单位：s)</li>
</ul>
</blockquote>
<h1 id="八、HttpSession"><a href="#八、HttpSession" class="headerlink" title="八、HttpSession"></a>八、HttpSession</h1><blockquote>
<p>在一次会话过程中，存储浏览器在服务端产生的私人数据</p>
</blockquote>
<h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 - 介绍"></a>8.1 - 介绍</h2><blockquote>
<ul>
<li>来自于 <code>Servlet</code> 规范中的接口，接口实现类来自于 <code>Tomcat</code></li>
<li>为参与同一个会话的 <code>Servlet</code> 之间提供共享数据</li>
<li>开发人员习惯于将 <code>HttpSession</code> 接口修饰的对象称为 <strong>会话作用域对象</strong> 或 <strong>session对象</strong> </li>
</ul>
</blockquote>
<h2 id="8-2-与-Cookie-的区别"><a href="#8-2-与-Cookie-的区别" class="headerlink" title="8.2 - 与 Cookie 的区别"></a>8.2 - 与 Cookie 的区别</h2><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>为参与同一个会话的 <code>Servlet</code> 之间提供共享数据</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><code>Cookie</code> 存在于客户端的浏览器或存储器</li>
<li><code>HttpSession</code>存在于服务端计算机的内存</li>
<li><code>Cookie</code> 只能存储 <code>String</code> 型</li>
<li><code>HttpSession</code> 可以存储任意类型</li>
<li><code>Cookie</code> 只能存储一个键值对</li>
<li><code>HttpSession</code> 可以存储任意个数的键值对</li>
</ul>
</blockquote>
<h2 id="8-3-方法"><a href="#8-3-方法" class="headerlink" title="8.3 - 方法"></a>8.3 - 方法</h2><blockquote>
<ul>
<li>在浏览器来访时，<code>Tomcat</code>不会主动为当前浏览器创建对应的<code>HttpSession</code>对象</li>
<li>只有一个浏览器所访问的 <code>Servlet</code> 向 <code>Tomcat</code> 提出要求时，<code>Tomcat</code> 才会为当前浏览器创建一个<code>HttpSession</code> 对象</li>
<li>如何在<code>Servlet</code>中为当前浏览器申请一个<code>HttpSession</code>对象</li>
</ul>
</blockquote>
<h3 id="getSession-getSession-true"><a href="#getSession-getSession-true" class="headerlink" title=".getSession() / .getSession(true)"></a>.getSession() / .getSession(true)</h3><blockquote>
<ul>
<li>如果当前浏览器在服务端已经有了一个<code>Session</code>，则将这个<code>Session</code>对象返回，否则创建一个全新的<code>Session</code>对象返回</li>
<li>一般用于用户身份已经确认合法的情况下</li>
</ul>
</blockquote>
<h3 id="getSession-false"><a href="#getSession-false" class="headerlink" title=".getSession(false)"></a>.getSession(false)</h3><blockquote>
<ul>
<li>如果当前浏览器在服务端已经有了一个<code>Session</code>，则将这个<code>Session</code>对象返回，否则返回一个<code>null</code></li>
<li>一般用于用户身份不确认的情况下</li>
</ul>
</blockquote>
<h3 id="setAttribute-“key”-value"><a href="#setAttribute-“key”-value" class="headerlink" title=".setAttribute(“key”, value)"></a>.setAttribute(“key”, value)</h3><blockquote>
<p>将键值对放入 <code>Session</code>对象</p>
</blockquote>
<h3 id="getAttribute-“key”"><a href="#getAttribute-“key”" class="headerlink" title=".getAttribute(“key”)"></a>.getAttribute(“key”)</h3><blockquote>
<p>根据<code>key</code>从<code>Seesion</code>对象获取数据</p>
</blockquote>
<h1 id="九、HTTP-状态码"><a href="#九、HTTP-状态码" class="headerlink" title="九、HTTP 状态码"></a>九、HTTP 状态码</h1><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 - 介绍"></a>9.1 - 介绍</h2><blockquote>
<ul>
<li><code>Http</code>状态码是由一个三位数字组成的符号</li>
<li><code>Http</code> 状态码由<code>Tomcat</code> 负责创建生成</li>
<li><code>Http</code> 状态码由<code>Tomcat</code> 写入到状态行</li>
<li><code>Http</code> 状态码通知浏览器在接到相应包之后的行为</li>
<li><code>Http</code> 状态码通知浏览器服务端无法提供本次服务的原因</li>
</ul>
</blockquote>
<h2 id="9-2-1××"><a href="#9-2-1××" class="headerlink" title="9.2 - 1××"></a>9.2 - 1××</h2><blockquote>
<p>通知浏览器本次返回的资源文件并不完整，需要浏览器继续向服务器发送申请</p>
</blockquote>
<h2 id="9-3-2××"><a href="#9-3-2××" class="headerlink" title="9.3 - 2××"></a>9.3 - 2××</h2><blockquote>
<p>通知浏览器，服务端将一个完整的文件推给了浏览器</p>
<ul>
<li>200 – 完美状态</li>
</ul>
</blockquote>
<h2 id="9-4-3××"><a href="#9-4-3××" class="headerlink" title="9.4 - 3××"></a>9.4 - 3××</h2><blockquote>
<p>服务端推给浏览器的是一个网址，要求浏览器在接收到这个网址后立刻自动向这个网址发送请求</p>
</blockquote>
<h2 id="9-5-4××"><a href="#9-5-4××" class="headerlink" title="9.5 - 4××"></a>9.5 - 4××</h2><blockquote>
<p>通知浏览器服务端本次未能提供服务的原因，是由于服务端没有对应的资源文件</p>
<ul>
<li>404 - 服务端没有对应的资源文件</li>
<li>405 - 服务端有本次请求对应的<code>Servlet</code>但是<code>Servlet</code>不负责处理这个请求</li>
</ul>
</blockquote>
<h2 id="9-6-5××"><a href="#9-6-5××" class="headerlink" title="9.6 - 5××"></a>9.6 - 5××</h2><blockquote>
<p>通知浏览器服务端本次未能提供服务的原因，被调用<code>Servlet</code>在运行中出了异常</p>
</blockquote>
<h1 id="十、重定向与请求转发"><a href="#十、重定向与请求转发" class="headerlink" title="十、重定向与请求转发"></a>十、重定向与请求转发</h1><h2 id="10-1-前提"><a href="#10-1-前提" class="headerlink" title="10.1 - 前提"></a>10.1 - 前提</h2><blockquote>
<ul>
<li>一个<code>Servlet</code>只负责实现一个功能</li>
<li>浏览器在一次请求时，只能请求一个资源文件</li>
<li>如果浏览器的请求需要由多个<code>Servlet</code>协同完成，需要用户多次手动提交，这样降低服务质量</li>
</ul>
</blockquote>
<h2 id="10-2-方案"><a href="#10-2-方案" class="headerlink" title="10.2 - 方案"></a>10.2 - 方案</h2><blockquote>
<ul>
<li>重定向方案</li>
<li>请求转发方案</li>
</ul>
</blockquote>
<h2 id="10-3-重定向"><a href="#10-3-重定向" class="headerlink" title="10.3 - 重定向"></a>10.3 - 重定向</h2><h3 id="10-3-1-原理"><a href="#10-3-1-原理" class="headerlink" title="10.3.1 - 原理"></a>10.3.1 - 原理</h3><blockquote>
<p>在第一个<code>Servlet</code>工作完毕后，将第二个<code>Servlet</code>地址推送给浏览器，由用户浏览器根据这个地址来自动向第二个<code>Servlet</code>发送请求</p>
</blockquote>
<h3 id="10-3-2-特征"><a href="#10-3-2-特征" class="headerlink" title="10.3.2 - 特征"></a>10.3.2 - 特征</h3><blockquote>
<ul>
<li><strong>发生为止</strong> – 客户端浏览器</li>
<li><strong>浏览器发送的请求次数</strong> – 多次</li>
<li><strong>地址栏变化</strong> – 是</li>
<li><strong>重定向采取的请求方式</strong> – <code>GET</code></li>
<li><strong>重定向时访问资源文件的范围</strong> – 可以是同一个网站的资源，也可以是其他网站的资源</li>
</ul>
</blockquote>
<h3 id="10-3-3-response-sendRedirect-第二个-Servlet-地址"><a href="#10-3-3-response-sendRedirect-第二个-Servlet-地址" class="headerlink" title="10.3.3 - response.sendRedirect(第二个 Servlet 地址);"></a>10.3.3 - response.sendRedirect(第二个 Servlet 地址);</h3><blockquote>
<p>将一个地址写入到 <strong>响应头</strong> 中 <code>Location</code> ，浏览器接收到响应包之后，自动根据 <code>Location</code> 地址发送第二次请求，这样的好处是避免用户多次手动发送请求</p>
</blockquote>
<h2 id="10-4-请求转发"><a href="#10-4-请求转发" class="headerlink" title="10.4 - 请求转发"></a>10.4 - 请求转发</h2><h3 id="10-4-1-原理"><a href="#10-4-1-原理" class="headerlink" title="10.4.1 - 原理"></a>10.4.1 - 原理</h3><blockquote>
<ul>
<li>在第一个<code>Servlet</code>工作完毕后，代替当前浏览器向<code>Tomcat</code>申请调用第二个<code>Servlet</code></li>
<li><code>Tomcat</code>在接收到申请之后，调用第二个<code>Servlet</code>来完成本次请求中剩余任务</li>
</ul>
</blockquote>
<h3 id="10-4-2-特征"><a href="#10-4-2-特征" class="headerlink" title="10.4.2 - 特征"></a>10.4.2 - 特征</h3><blockquote>
<ul>
<li><strong>发生位置</strong> – 服务器</li>
<li><strong>浏览器发送请求次数</strong> – 一次</li>
<li><strong>地址栏变化</strong> – 否</li>
<li><strong>调用文件范围</strong> – 只能访问同一网站的内部资源文件</li>
<li><strong>请求转发的请求方式</strong> – 与浏览器第一次发送的方式保持一致，参与同义词请求转发的所有<code>Servlet</code>接收的请求都是一样的</li>
<li><strong>如何共享数据</strong> – 全局作用域对象、会话作用域对象、请求作用域对象</li>
</ul>
</blockquote>
<h3 id="10-4-3-request-getRequestDisoatcher-第二个-Servlet-地址-forward-request-response"><a href="#10-4-3-request-getRequestDisoatcher-第二个-Servlet-地址-forward-request-response" class="headerlink" title="10.4.3 - request.getRequestDisoatcher(第二个 Servlet 地址).forward(request, response)"></a>10.4.3 - request.getRequestDisoatcher(第二个 Servlet 地址).forward(request, response)</h3><blockquote>
<p>从响应头获取<code>RequestDisoatcher</code>对象，写入第二个<code>Servlet</code>地址并转发请求</p>
</blockquote>

      </div>

      <div class="article-footer">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaEE/" rel="tag">#JavaEE</a></li></ul>
      </div>

      <div class="article-navs">
        
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
      <div id="article-nav-newer" class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2020/02/01/Struts2-Frame/"></a>
          <strong class="article-nav-caption">Newer</strong>
          <p class="article-nav-title">
            
              Struts2
            
          </p>
        </article>
      </div>
    
    
      <div id="article-nav-older" class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2020/01/27/Spring-Frame/"></a>
          <strong class="article-nav-caption">Older</strong>
          <p class="article-nav-title">
            
              Spring
            
          </p>
        </article>
      </div>
    
  </div>
</nav>

      </div>
      
      

  
  <div class="valine-container">
    <div id="valine_thread" class="valine-thread"></div>
  </div>

  
  


    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    <p>&copy; 2020 <a href="/" target="_blank">Cying-承影</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=a&amp;encode=js&select=%23hitokoto" defer></script>
    

    

    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank">flex-block</a></p>
  </div>
</footer>
  </div>

  
  


  <!-- aplayer 音频 start -->
  
<link rel="stylesheet" href="/lib/APlayer.min.css">

  
<script src="/lib/APlayer.min.js"></script>

  <script type="text/javascript">
    const aplayer = document.querySelectorAll(".aplayer");
    aplayer && initaplayer(aplayer);
    function initaplayer(els) {
      let elsArr = Array.from(els);
      elsArr.forEach(el => {
        new APlayer({
          container: el,
          audio: { ...el.dataset },
          theme: "#b7daff",
          lrcType: 3,
          autoplay: false,
          loop: false,
          mutex: true,
        });
      });
    }
  </script>
  <!-- aplayer 音频 end -->
  

<!-- dplayer 视频 start -->

<link rel="stylesheet" href="/lib/DPlayer.min.css">


<script src="/lib/DPlayer.min.js"></script>

<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      new DPlayer({
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      });
    });
  }
</script>
<!-- dplayer 视频 end -->


<!-- waterfall 瀑布流 start -->

<script src="/lib/waterfall.min.js"></script>

<script type="text/javascript">

const waterfalls = document.querySelectorAll(".waterfall-container");

if (waterfalls && waterfalls.length > 0) {
  waterfalls.forEach((waterfall, index) => {
    let cls = "waterfall-container-" + index;
    waterfall.classList.add(cls);
    initWaterfall(cls, waterfall);
  });
}

function initWaterfall(selector, el) {
  const options = {};
  if (Object.keys(el.dataset).length > 0) {
    for (let k in el.dataset) {
      options[k] = el.dataset[k];
    }
  }
  waterfall(`.${selector}`, options);
}
</script>
<!-- waterfall 瀑布流 end -->


  <!-- zoom start -->
  
<script src="/lib/zoom.min.js"></script>

  <script type="text/javascript">
    document.querySelector(".article-content") && zoom(".article-content");
  </script>
  <!-- zoom end -->
  



  


  


  




<script src="/js/script.js"></script>

  
  <!-- 尾部用户自定义相关内容 -->

</body>
</html>