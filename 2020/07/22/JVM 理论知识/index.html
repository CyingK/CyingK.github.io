<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM理论 | Cin's Home</title><meta name="keywords" content="Java,JVM"><meta name="author" content="承影"><meta name="copyright" content="承影"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java虚拟机的内存布局与垃圾回收">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM理论">
<meta property="og:url" content="http://cyingk.github.io/2020/07/22/JVM%20%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Cin&#39;s Home">
<meta property="og:description" content="Java虚拟机的内存布局与垃圾回收">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/CyingK/files/raw/master/images/blog/cover/jvm-2020-07-22.jpg">
<meta property="article:published_time" content="2020-07-22T03:35:25.000Z">
<meta property="article:modified_time" content="2021-01-16T01:36:16.242Z">
<meta property="article:author" content="承影">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/CyingK/files/raw/master/images/blog/cover/jvm-2020-07-22.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://cyingk.github.io/2020/07/22/JVM%20%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "4zndahq92q");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-16 09:36:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = '1'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/CyingK/files/raw/master/images/blog/utils/top.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cin's Home</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM理论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-07-22T03:35:25.000Z" title="undefined 2020-07-22 11:35:25">2020-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">223</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>1分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><center><h1 style="border:none;">Java 虚拟机概论</h1></center>




<center><h1>
    <div style="margin: 10px 0; font-size: 30px">[ 第一部分 ]</div>
    内存与垃圾回收
    </h1>
</center>


<h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><blockquote>
<ul>
<li>类加载子系统<ul>
<li><code>Loadding</code> 加载：由加载器将字节码文件载入 <code>JVM</code> ，核心加载器有：<ul>
<li><code>Bootstrap ClassLoader</code> （引导类加载器）</li>
<li><code>Extension ClassLoader</code> （扩展类加载器）</li>
<li><code>Application ClassLoader</code> （应用/系统类加载器）</li>
</ul>
</li>
<li><code>Linking</code> 链接：检查合法性</li>
<li><code>Initialization</code> 初始化：主要针对静态变量的显式初始化</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>运行时数据区<ul>
<li><code>Stack Area</code>：线程私有<ul>
<li> <code>LV(Local Variables)</code> - 局部变量表</li>
<li> <code>OS(Operand Stack)</code> - 操作数栈</li>
<li> <code>DL(Dynamic Linking)</code> - 动态链接</li>
<li> <code>RA(Return Address)</code> - 返回地址</li>
</ul>
</li>
<li><code>PC Registers</code>：程序计数器，线程私有 </li>
<li><code>Method Area</code>：存放类的信息、常量、域信息、方法信息</li>
<li><code>Heap Area</code>：对象的存储位置</li>
<li><code>Native Method Stack</code>：主要管辖本地方法接口 </li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>执行引擎<ul>
<li> <code>Interpreter</code>：解释器</li>
<li> <code>JIT Compiler</code>：及时编译器</li>
<li> <code>GC</code>：垃圾回收器</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/JVM%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="JVM架构图"></p>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h2><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="类加载子系统"></p>
<h3 id="2-1、简述"><a href="#2-1、简述" class="headerlink" title="2.1、简述"></a>2.1、简述</h3><blockquote>
<ul>
<li>类加载子系统负责从文件系统或者网络中加载 <code>Class</code> 文件，<code>Class</code> 文件在文件打头有特定的文件标识</li>
<li><code>ClassLoader</code> 只负责 <code>Class</code> 文件的加载，至于它是否可以运行，则由执行引擎决定</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池的信息，可能还包括字符串字面量和数字常量</li>
</ul>
</blockquote>
<h3 id="2-2、类的加载过程"><a href="#2-2、类的加载过程" class="headerlink" title="2.2、类的加载过程"></a>2.2、类的加载过程</h3><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类的加载过程"></p>
<h3 id="2-3、Loading"><a href="#2-3、Loading" class="headerlink" title="2.3、Loading"></a>2.3、Loading</h3><blockquote>
<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
</blockquote>
<h4 id="2-3-2、加载方式"><a href="#2-3-2、加载方式" class="headerlink" title="2.3.2、加载方式"></a>2.3.2、加载方式</h4><blockquote>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取</li>
<li>从 <code>zip</code> 压缩包中读取，成为日后 <code>jar</code>，<code>war</code> 格式的基础</li>
<li>运行时计算生成，使用最多的是动态代理技术</li>
<li>由其他文件生成，如 <code>JSP</code></li>
<li>从专有数据库中提取</li>
<li>从加密文件中获取</li>
</ul>
</blockquote>
<h3 id="2-4、Linking"><a href="#2-4、Linking" class="headerlink" title="2.4、Linking"></a>2.4、Linking</h3><h4 id="2-4-1、Verify"><a href="#2-4-1、Verify" class="headerlink" title="2.4.1、Verify"></a>2.4.1、Verify</h4><blockquote>
<ul>
<li>目的在于确保 <code>Class</code> 文件中的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2-4-2、Prepare"><a href="#2-4-2、Prepare" class="headerlink" title="2.4.2、Prepare"></a>2.4.2、Prepare</h4><blockquote>
<ul>
<li>为类变量分配内存并设置该类变量的默认初始值</li>
<li>这里不包含用 <code>final</code> 修饰的 <code>static</code>，因为 <code>final</code> 在编译的时候就会分配，准备阶段会显式初始化</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，二实例变量会随着对象一起分配到 <code>Java</code> 堆中</li>
</ul>
</blockquote>
<h4 id="2-4-3、Resolve"><a href="#2-4-3、Resolve" class="headerlink" title="2.4.3、Resolve"></a>2.4.3、Resolve</h4><blockquote>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>解析操作往往会伴随着 <code>JVM</code> 在执行完初始化之后再执行</li>
<li>符号引用就是一组符号用来描述所引用的目标。符号引用的字面量形式明确定义在《<code>Java</code> 虚拟机规范》的 <code>Class</code> 文件格式中，直接引用就是直接指向目标的指针、相对偏移量或一个间接位到达目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等，对应常量池中的 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code> 等</li>
</ul>
</blockquote>
<h3 id="2-5、Initialization"><a href="#2-5、Initialization" class="headerlink" title="2.5、Initialization"></a>2.5、Initialization</h3><blockquote>
<ul>
<li>初始化阶段就是执行类构造器 <code>&lt;clinit&gt;()</code> 的过程</li>
<li>此方法不需要定义，是 <code>javac</code> 编译器自动手机类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code> 不同于类的构造器</li>
<li>虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程下被同步加锁</li>
</ul>
</blockquote>
<h3 id="2-6、ClassLoader"><a href="#2-6、ClassLoader" class="headerlink" title="2.6、ClassLoader"></a>2.6、ClassLoader</h3><blockquote>
<ul>
<li><code>Class</code> 文件存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 <code>JVM</code> 当中来根据这个文件实例化出 <code>n</code> 个一模一样的实例</li>
<li><code>Class</code> 文件加载到 <code>JVM</code> 中，被称为 <code>DNA</code> 元数据模块，放在方法区</li>
<li>在 <code>Class</code> 文件 -》<code>JVM</code> -》最终成为元数据模块，此过程就需要 ClassLoader扮演一个快递员的角色</li>
</ul>
</blockquote>
<h4 id="2-6-1、分类"><a href="#2-6-1、分类" class="headerlink" title="2.6.1、分类"></a>2.6.1、分类</h4><blockquote>
<ul>
<li><code>JVM</code> 支持两种类型的类加载器，分别为 <strong>引导类加载器（Bootstrap ClassLoader）</strong> 和 <strong>自定义类加载器（User-Defined ClassLoader）</strong></li>
<li><strong>系统类加载器（Application ClassLoader）</strong> 和 <strong>扩展类加载器（Extension ClassLoader）</strong> 属于 <strong>自定义类加载器（User-Defined ClassLoader）</strong></li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A81.png" alt="类加载器1"></p>
<p><strong><code>ClassLoader</code> 继承树</strong></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A82.png" alt="类加载器2"></p>
</blockquote>
<h4 id="2-6-2、引导类加载器"><a href="#2-6-2、引导类加载器" class="headerlink" title="2.6.2、引导类加载器"></a>2.6.2、引导类加载器</h4><blockquote>
<ul>
<li>这个类加载器使用 <code>C/C++</code> 语言实现，嵌套在 <code>JVM</code> 内部</li>
<li>用来加载 <code>Java</code> 的核心类库（<code>JAVA_HOME/jre/lib/rt.jar</code>），用于提供 <code>JVM</code> 自身需要的类</li>
<li>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</li>
<li>加载 <strong>扩展类加载器</strong> 和 <strong>系统类加载器</strong>，并指定为他们的父类</li>
<li>处于安全考虑，引导类加载器只加载包为 <code>java、javax、sun</code> 等开头的类</li>
</ul>
</blockquote>
<h4 id="2-6-3、自定义类加载器"><a href="#2-6-3、自定义类加载器" class="headerlink" title="2.6.3、自定义类加载器"></a>2.6.3、自定义类加载器</h4><blockquote>
<ul>
<li>作用<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>实现步骤<ul>
<li>继承抽象类 <code>java.lang.ClassLoader</code> 类</li>
<li>在 <code>JDK1.2</code> 之前，在自定义类加载器时，总会去继承 <code>ClassLoader</code> 类并重写 <code>loadClass()</code> 方法，从而实现自定义的类加载类，在 <code>JDK1.2</code> 之后已不再建议用户自己去覆盖 <code>loadClass()</code> 中的方法，而是建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 <code>URLClassLoader</code> 类，这样就可以避免自己去编写 <code>findClass()</code> 方法以及获取器字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-7、双亲委派机制"><a href="#2-7、双亲委派机制" class="headerlink" title="2.7、双亲委派机制"></a>2.7、双亲委派机制</h3><blockquote>
<p><code>Java</code> 虚拟机对 <code>Class</code> 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 <code>Class</code> 文件加载到内存生成 <code>Class</code> 对象。而且加载某个类的 <code>Class</code> 文件时，<code>Java</code> 虚拟机采用的是 <strong>双亲委派机制</strong>，即把请求交由父类处理</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="双亲委派机制"></p>
<ul>
<li>工作原理</li>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，否则交由子加载器进行处理</li>
<li>优势</li>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心 <code>API</code> 被随意篡改</li>
</ul>
</blockquote>
<h3 id="2-8、类的主动使用与被动使用"><a href="#2-8、类的主动使用与被动使用" class="headerlink" title="2.8、类的主动使用与被动使用"></a>2.8、类的主动使用与被动使用</h3><h4 id="2-8-1、主动使用"><a href="#2-8-1、主动使用" class="headerlink" title="2.8.1、主动使用"></a>2.8.1、主动使用</h4><blockquote>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量复制</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li><code>Java</code> 虚拟机启动时被标明为启动类的类</li>
<li><code>JDK 7</code> 开始提供的动态语言支持</li>
</ul>
</blockquote>
<h4 id="2-8-2、被动使用"><a href="#2-8-2、被动使用" class="headerlink" title="2.8.2、被动使用"></a>2.8.2、被动使用</h4><blockquote>
<p>除主动使用之外的所有情况</p>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区"></p>
<p><strong>阿里的运行时数据区：</strong></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E9%98%BF%E9%87%8C-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="阿里-运行时数据区"></p>
<h3 id="3-1、PC-Register"><a href="#3-1、PC-Register" class="headerlink" title="3.1、PC Register"></a>3.1、PC Register</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1">Oracle 官网介绍</a></p>
<blockquote>
<ul>
<li><code>PC</code> 寄存器用来存储指向先弄个一条指令的地址代码。由执行引擎读取下一条指令</li>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域</li>
<li>在 <code>JVM</code> 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 <code>Java</code> 方法的 <code>JVM</code> 指令地址；或者，如果是在执行 <code>native</code> 方法，则是未指定值（<code>undefined</code>）</li>
<li>是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>是唯一一个在 <code>Java</code> 虚拟机规范中没有规定任何 <code>OutofMemoryError</code> 情况的区域</li>
</ul>
</blockquote>
<p><strong>为什么要使用 <code>PC</code> 寄存器记录当前线程的执行地址</strong></p>
<blockquote>
<p>因为 <code>CPU</code> 需要不停的切换各个线程，这时候切换回来以后，就得知道从哪里开始继续执行。。<code>JVM</code> 的字节码解释器就需要通过改变 <code>PC</code> 寄存器的值来明确下一条应该执行什么样的字节指令</p>
</blockquote>
<p><strong><code>PC</code> 寄存器为什么会被设定为线程私有</strong></p>
<blockquote>
<p>由于 <code>CPU</code> 时间片轮转限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程的一条指令。这样必然导致经常终端或恢复，而每个线程在创建后产生自己的程序计数器和栈帧，这样程序计数器在各个线程之间就能互不影响了</p>
</blockquote>
<h3 id="3-2、JVM-Stack-Area"><a href="#3-2、JVM-Stack-Area" class="headerlink" title="3.2、JVM Stack Area"></a>3.2、JVM Stack Area</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2">Oracle 官网介绍</a></p>
<blockquote>
<p><code>Java</code> 虚拟机栈，早期也叫 <code>Java</code> 栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的 <code>Java</code> 方法调用，是线程私有</p>
<ul>
<li>生命周期：和线程保持一致</li>
<li>作用：主管 <code>Java</code> 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回</li>
<li>背景：由于跨平台性的设计，<code>Java</code> 的指令都是根据栈来设计的。不同平台 <code>CPU</code> 架构不同，所以不能设计为基于寄存器的</li>
<li>优点：<ul>
<li>跨平台</li>
<li>指令集小</li>
<li>编译器容易实现</li>
</ul>
</li>
<li>缺点：<ul>
<li>性能下降</li>
<li>实现同样的功能需要更多的指令</li>
</ul>
</li>
<li>特点：<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li><code>JVM</code> 直接对 <code>Java</code> 栈的操作只有入栈和出栈</li>
<li>对于栈来说不存在垃圾回收的问题</li>
</ul>
</li>
<li>设置栈的大小：<ul>
<li><strong><code>-Xss size</code></strong></li>
<li>单位：<code>KB</code>、<code>g/G</code>、<code>m/M</code></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-2-1、栈的存储单位"><a href="#3-2-1、栈的存储单位" class="headerlink" title="3.2.1、栈的存储单位"></a>3.2.1、栈的存储单位</h4><blockquote>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（<code>Stack Frame</code>）的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（<code>Stack Frame</code>）</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
</blockquote>
<h5 id="3-2-1-1、运行原理"><a href="#3-2-1-1、运行原理" class="headerlink" title="3.2.1.1、运行原理"></a>3.2.1.1、运行原理</h5><blockquote>
<ul>
<li><code>JVM</code> 直接对 <code>Java</code> 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循 ”先进后出“ 或者 ”后进先出“ 的原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被成为当前栈帧，与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</li>
<li>不同的线程中所包含的栈帧是不允许存在互相引用的，即不可能在一个栈帧之中引用另一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li><code>Java</code> 方法有两种返回的方式，不管哪种，都会导致栈帧被弹出<ul>
<li>正常的返回，使用 <code>return</code></li>
<li>抛出异常</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="栈运行原理"></p>
</blockquote>
<h4 id="3-2-2、栈帧的内部结构"><a href="#3-2-2、栈帧的内部结构" class="headerlink" title="3.2.2、栈帧的内部结构"></a>3.2.2、栈帧的内部结构</h4><blockquote>
<ul>
<li>局部变量表</li>
<li>操作数栈（表达式栈）</li>
<li>动态链接（指向运行时常量池的方法引用）</li>
<li>方法返回地址（方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
</blockquote>
<h5 id="3-2-2-1、Local-Variables"><a href="#3-2-2-1、Local-Variables" class="headerlink" title="3.2.2.1、Local Variables"></a>3.2.2.1、Local Variables</h5><blockquote>
<ul>
<li>定义<ul>
<li>也称为 <strong>局部变量数组</strong> 或 <strong>本地变量表</strong></li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用，以及 <code>returnAddress</code> 类型</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li>
<li><strong>局部变量表所需的容量大小是在编译器确定下来的</strong>，并保存在方法的 <code>Code</code> 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表大小的 </li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>，一般来说，展越大，<strong>方法嵌套调用次数越多</strong>。对一个方法而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>，在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Slot<ul>
<li>参数值的存放总是在局部变量数组的 <code>index0</code> 开始，到数组长度 -1 索引结束</li>
<li>局部变量表，<strong>最基本的存储单元是 <code>Slot</code> （变量槽）</strong></li>
<li>局部变量表中存放编译期可知的各种基本数据类型，引用类型和 <code>returnAddress</code> 类型的变量</li>
<li>在局部变量表里，<strong>32位以内的类型只占一个 Slot（包括 <code>returnAddress</code> 类型），64位的（<code>long</code> 和 <code>double</code>）占用两个 Slot</strong></li>
<li><code>byte</code>、<code>short</code>、<code>char</code> 在存储前被转换位 <code>int</code></li>
<li><code>boolean</code> 也被转换为 <code>int</code>，0 表示 <code>false</code>，非 0 表示 <code>true</code></li>
<li><code>long</code> 和 <code>double</code> 则占据两个 <code>Slot</code> </li>
<li><code>JVM</code> 会为局部变量表中的每一个 <code>Slot</code> 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量将会 <strong>按照顺序</strong> 复制到局部变量表的每一个 <code>Slot</code> 上</li>
<li>如果需要访问局部变量表中一个 <code>64bit</code> 的局部变量，只需使用起始索引</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么 <strong>该对象引用 <code>this</code> 将会存放在 index 为 0 的 <code>Slot</code> 处</strong>，其余的参数按照参数表顺序继续排列 </li>
<li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会服用过期局部变量的槽位，从而达到 <strong>节省资源</strong> 的目的</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>调优<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li>局部变量表中的变量也是垃圾回收根节点，只要被局部变量中中直接或间接引用的对象都不会被回收 </li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-2-2-2、Operand-Stack"><a href="#3-2-2-2、Operand-Stack" class="headerlink" title="3.2.2.2、Operand Stack"></a>3.2.2.2、Operand Stack</h5><blockquote>
<ul>
<li>定义<ul>
<li>在方法执行过程中，根据字节码指令，往栈里写入数据或提取数据，即<strong>入栈/出栈</strong><ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数去出栈。使用后再把结果压入栈</li>
<li>比如 <code>[8, 15] -&gt; iadd -&gt; [23]</code></li>
</ul>
</li>
<li><strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li>
<li>操作数栈就是 <code>JVM</code> 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong></li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 <code>Code</code> 属性中，为 <code>max_stack</code> 的值</li>
<li>栈中的任何一个元素都可以是任意的 <code>Java</code> 数据类型<ul>
<li><code>32bit</code> 的类型占用一个栈单位深度</li>
<li><code>64bit</code> 的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈 <strong>并非</strong> 采用访问索引的方式来进行数据访问，只能通过标准的入栈、出栈来完成一次数据访问 </li>
<li><strong>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈</strong>，并更新 <code>PC</code> 寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>我们说 <code>Java</code> 虚拟机的 <strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>栈顶缓存技术<ul>
<li>由于操作数是存在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，就有了 <code>ToS, Top-of-Stack Cashing</code>，<strong>将栈顶元素全部缓存到物理 <code>CPU</code> 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>举例1</strong></p>
<blockquote>
<p><code>Java</code> 文件： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">byte</span> a = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">     <span class="keyword">int</span> c = a + b;</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>m1()</code> 字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 10 入栈</span></span><br><span class="line"><span class="number">0</span> bipush <span class="number">10</span>	</span><br><span class="line"><span class="comment">// 存入局部变量表，1 号槽，并出栈</span></span><br><span class="line"><span class="number">2</span> istore_1		</span><br><span class="line"><span class="comment">// 将 20 入栈</span></span><br><span class="line"><span class="number">3</span> bipush <span class="number">20</span></span><br><span class="line"><span class="comment">// 存入局部变量表，2 号槽，并出栈</span></span><br><span class="line"><span class="number">5</span> istore_2</span><br><span class="line"><span class="comment">// 取出局部变量表的 1 号槽内容，入栈</span></span><br><span class="line"><span class="number">6</span> iload_1</span><br><span class="line"><span class="comment">// 取出局部变量表的 2 号槽内容，入栈</span></span><br><span class="line"><span class="number">7</span> iload_2</span><br><span class="line"><span class="comment">// 取出栈里的数据，在两者相加后将结果入栈</span></span><br><span class="line"><span class="number">8</span> iadd</span><br><span class="line"><span class="comment">// 存入局部变量表，3 号槽，并出栈</span></span><br><span class="line"><span class="number">9</span> istore_3</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span>		</span><br><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment">** 关于 push：										 **</span></span><br><span class="line"><span class="comment">** bipush 范围：(-128 ~ 127) 					     **</span></span><br><span class="line"><span class="comment">** sipush 范围：(-32768 ~ 32767)					 **</span></span><br><span class="line"><span class="comment">** ldc 范围：(-2147483648 ~ 2147483647)			 **</span></span><br><span class="line"><span class="comment">****************************************************/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-2-2-3、Dynamic-Linking"><a href="#3-2-2-3、Dynamic-Linking" class="headerlink" title="3.2.2.3、Dynamic Linking"></a>3.2.2.3、Dynamic Linking</h5><blockquote>
<ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前的代码能够实现动态链接，比如 <code>invokeddynamic</code> </li>
<li>在 <code>Java</code> 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在 <code>Class</code> 文件的常量池里。</li>
<li>如描述一个方法调用了另外的其他方法时，就是通过常量池中的指向方法的符号来表示的，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt="动态链接"></p>
</blockquote>
<h5 id="3-2-3-4、Return-Address"><a href="#3-2-3-4、Return-Address" class="headerlink" title="3.2.3.4、Return Address"></a>3.2.3.4、Return Address</h5><blockquote>
<ul>
<li>定义：<ul>
<li>存放调用该方法的 <code>PC</code> 寄存器的值</li>
<li>一个方法的结束，有 <strong>遇到任意一个方法返回的字节码指令 <code>return</code> （正常执行完成）</strong> 和 <strong>出现未处理的异常，（非正常退出）</strong></li>
<li>无论通过那种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的 <code>PC</code> 寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>，而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>正常完成出口：一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需根据方法返回值的实际数据类型而定<ul>
<li>在字节码指令中，返回指令包含 <code>ireturn</code> （当返回值是 <code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code> 和 <code>int</code> 时）、<code>lreturn</code>、<code>freturn</code>、<code>dreturn</code> 以及 <code>areturn</code>，另外还有一个 <code>return</code> 指令供声明为 <code>void</code> 的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>异常完成出口：在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表里没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口<ul>
<li>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 <code>PC</code> 寄存器值等，让调用者方法继续执行下去。</li>
<li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者返回任何返回值</strong></li>
</ul>
</blockquote>
<h5 id="3-2-3-5、方法的调用"><a href="#3-2-3-5、方法的调用" class="headerlink" title="3.2.3.5、方法的调用"></a>3.2.3.5、方法的调用</h5><blockquote>
<ul>
<li>定义：<code>JVM</code> 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关，绑定机制是 <strong>一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong><ul>
<li>静态链接：当一个字节码文件被装载进 <code>JVM</code> 内部时，如果 <strong>被调用的目标方法在编译期可知，且运行期保持不变</strong>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li>早期绑定：<strong>被调用的目标方法在编译期可知，且运行期保持不变</strong>，即可将这个方法与所属的类型进行绑定，这样依赖，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</li>
<li>动态链接：<strong>被调用的目标方法在编译期无法确定下来，只能够在程序运行期将其调用方法的符号引用转换为直接引用</strong>，由于这种引用转换过程具备动态性，因此也就被称为动态链接</li>
<li>晚期绑定：<strong>被调用的对象在编译器无法确定下来，只能够在程序运行期根据实际的类型绑定相关方法</strong>，这种绑定方式也就被称之为晚期绑定</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>虚方法与绑定机制：随着高级语言的横空出世，类似于 <code>Java</code> 一样的就面向对象的编程语言如今越来越多，尽管这类编程语言在语法上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然 <strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种方式</strong>，<code>Java</code> 中任何一个普通方法其实都具备虚函数的特征，它们相当于 <code>C++</code> 语言中的虚函数。如果在 <code>Java</code> 程序中不希望某个方法拥有虚函数的特征，则可以使用关键字 <code>final</code> 来标记这个方法<ul>
<li>如果方法在编译期间就确定了具体的调用版本，这个版本在运行时是不变的，这样的方法称为 <strong>非虚方法</strong>，静态方法、私有方法、<code>final</code> 方法、实例构造器、父类方法都是非虚方法，其他方法称为 <strong>虚方法</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>调用指令：前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 <code>invokedynamic</code> 指令则支持由用户确定方法版本，其中 <strong><code>invokestatic</code> 指令和 <code>invokespecial</code> 指令调用的方法称为非虚方法，其余的（<code>final</code> 修饰的除外）称为虚方法</strong></p>
<ul>
<li><p>普通调用</p>
<ul>
<li><code>invokestatic</code>：调用静态方法，解析阶段确定唯一方法版本</li>
<li><code>invokespecial</code>：调用 <code>&lt;init&gt;</code> 方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li><code>invokevirtual</code>：调用所有虚方法（<code>final</code> 修饰的除外）</li>
<li><code>invokeinterface</code>：调用接口方法</li>
</ul>
</li>
<li><p>动态调用指令</p>
<ul>
<li><code>invokedynamic</code>：动态解析出需要调用的方法，然后执行<ul>
<li><code>Java7</code> 才新增该指令，目的是为了<strong>实现 <code>Java</code> 的 “动态类型语言” 支持而做的改进</strong><ul>
<li>动态类型语言：判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</li>
<li>静态类型语言：判断变量自身的类型信息</li>
<li>区别：在于对类型的检查是在编译期还是在运行期</li>
</ul>
</li>
<li>但是 <code>Java7</code> 中并没有提供直接生成 <code>invokedynamic</code> 指令的方法，需要借助 <code>ASM</code> 这种底层字节码工具来产生 <code>invokedynamic</code> 指令，<strong>直到 <code>Java8</code> 中 <code>Lambda</code> 表达式的出现， <code>invokedynamic</code> 指令的生成，在 <code>Java</code> 中才有了直接的生成方式</strong></li>
<li><code>Java7</code> 中增加的动态语言类型支持的本质是对 <code>Java</code> 虚拟机规范的修改，而不是对<code>Java</code> 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 <code>Java</code> 平台的动态语言的编译器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-2-3-6、方法重写的本质"><a href="#3-2-3-6、方法重写的本质" class="headerlink" title="3.2.3.6、方法重写的本质"></a>3.2.3.6、方法重写的本质</h5><blockquote>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 <code>T</code></li>
<li>如果在类型 <code>T</code> 中找到与常量中描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回 <code>Java.lang.IllegalAccessError</code> 异常</li>
<li>否则按照继承关系从下往上依次对 <code>T</code> 的各个父类进行第 2 步的搜索和验证过程</li>
<li>如果始终没有找到合适的方法，则抛出 <code>java.lang.AbstractMethodError</code> 异常</li>
</ol>
<ul>
<li><code>IllegalAccessError</code>：程序试图访问或修改一个属性或调用一个方法，然而程序没有这个方法或属性的访问权限，一般这个会引起编译器异常，这个错误如果发生在运行时，就说明一个类发生了不兼容的改变</li>
<li>虚方法表：在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就很可能影响到执行效率，因此，<strong>为了提高性能</strong>，<code>JVM</code> 采用在类的方法区建立一个虚方法表，使用索引表来代替查找<ul>
<li>每个类都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>虚方法表会在类加载的链接阶段（解析）被创建并开始初始化，类的变量初始值准备完成之后，<code>JVM</code> 会把该类的方法表也初始化完毕 </li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-2-3、面试题"><a href="#3-2-3、面试题" class="headerlink" title="3.2.3、面试题"></a>3.2.3、面试题</h4><p><strong>举例栈溢出的情况</strong></p>
<blockquote>
<p><code>(StackOverflowError)</code>，通过 <code>-Xss</code> 设置栈的大小，如无限递归</p>
</blockquote>
<p><strong>调整栈的大小，就能保证不出现溢出吗</strong></p>
<blockquote>
<p>不能</p>
</blockquote>
<p><strong>分配的栈内存越大越好吗</strong></p>
<blockquote>
<p>可能会使得线程变少，挤占其他东西的资源</p>
</blockquote>
<p><strong>垃圾回收是否涉及到虚拟机栈</strong></p>
<blockquote>
<p>不会，栈只包含入栈和出栈，没有 <code>GC</code> 可发挥的余地</p>
</blockquote>
<p><strong>方法中定义的局部变量是否线程安全</strong></p>
<blockquote>
<p>具体问题具体分析</p>
<ul>
<li>内部产生，内部消亡则安全</li>
<li>非内部产生或非内部消亡则不安全</li>
</ul>
</blockquote>
<h3 id="3-3、Native-Method-Stack"><a href="#3-3、Native-Method-Stack" class="headerlink" title="3.3、Native Method Stack"></a>3.3、Native Method Stack</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.6">Oracle 官网介绍</a></p>
<blockquote>
<ul>
<li>定义：<ul>
<li><strong><code>Java</code> 虚拟机栈用于管理 <code>Java</code> 方法的调用，而本地方法栈用于管理本地方法的调用</strong></li>
<li>本地方法栈，也是线程私有的</li>
<li>允许被实现成固定或者是可动态扩展的内存大小（在内存移除方面是相同的）<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，<code>Java</code> 虚拟机将会抛出 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的本地方法栈，那么 <code>Java</code> 虚拟机将会抛出一个 <code>OutOfMemoryError</code> 的异常</li>
</ul>
</li>
<li>本地方法是使用 <code>C</code> 语言实现的</li>
<li>它的具体做法是 <code>Native Method Stack</code> 中登记 <code>native</code> 方法，在 <code>Execution Engine</code> 执行时加载本地方法库</li>
<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不在受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong><ul>
<li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li><strong>并不是所有的 <code>JVM</code> 都支持本地方法，因为 <code>Java</code> 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等</strong>。如果 <code>JVM</code> 产品不打算支持 <code>native</code> 方法，也可以无需实现本地方法栈</li>
<li>在 <code>Hotspot JVM</code> 中，直接将本地方法栈和虚拟机栈合二为一</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-4、Heap"><a href="#3-4、Heap" class="headerlink" title="3.4、Heap"></a>3.4、Heap</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3">Oracle 官网介绍</a></p>
<h4 id="3-4-1、堆的核心概述"><a href="#3-4-1、堆的核心概述" class="headerlink" title="3.4.1、堆的核心概述"></a>3.4.1、堆的核心概述</h4><blockquote>
<ul>
<li>一个 <code>JVM</code> 实例只存在一个堆内存，堆也是 <code>Java</code> 内存管理的核心区域</li>
<li><code>Java</code> 堆区在 <code>JVM</code> 启动的时候即被创建，其空间大小也就确定了。是 <code>JVM</code> 管理的最大一块内存空间<ul>
<li>堆内存的大小是可以调节的</li>
</ul>
</li>
<li>《<code>Java</code> 虚拟机规范》规定，堆可以处于 <strong>物理上不连续</strong> 的内存空间中，但在逻辑上它应该被视为连续的</li>
<li>所有的线程共享 <code>Java</code> 堆，在这里还可以划分线程私有的缓冲区<code>(Thread Local Allocation Buffer, TLAB)</code></li>
<li>《<code>Java</code> 虚拟机规范》中对 <code>Java</code> 堆的描述是：所有对象实例以及数组都应当在运行时分配在堆上</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
<li>堆，是 <code>GC(Garbage Collection, 垃圾回收器)</code> 执行垃圾回收的重点区域</li>
</ul>
</blockquote>
<h5 id="3-4-1-1、内存细分"><a href="#3-4-1-1、内存细分" class="headerlink" title="3.4.1.1、内存细分"></a>3.4.1.1、内存细分</h5><blockquote>
<ul>
<li>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：<ul>
<li><code>Java 7</code> 之前，堆内存逻辑上分为：<ul>
<li><strong>新生区</strong>：<code>Young Generation Space</code><ul>
<li><code>Eden</code></li>
<li><code>Survivor</code></li>
</ul>
</li>
<li><strong>养老区</strong>：<code>Tenure Generation Space</code></li>
<li><strong>永久代</strong>：<code>Permanent Space</code></li>
</ul>
</li>
<li><code>Java 8</code> 之后，堆内存逻辑上分为：<ul>
<li><strong>新生区</strong>：<code>Young Generation Space</code><ul>
<li><code>Eden</code></li>
<li><code>Survivor</code></li>
</ul>
</li>
<li><strong>养老区</strong>：<code>Tenure Generation Space</code></li>
<li><strong>元空间</strong>：<code>Meta Space</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-4-2、设置堆内存大小"><a href="#3-4-2、设置堆内存大小" class="headerlink" title="3.4.2、设置堆内存大小"></a>3.4.2、设置堆内存大小</h4><blockquote>
<ul>
<li><code>Java</code> 堆区用于存储 <code>Java</code> 对象实例，堆的大小在 <code>JVM</code> 启动 的时候就已经设定好了，可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 来进行设置<ul>
<li><code>-Xms(X Memory Start)</code> 用于表示堆区的起始内存，等价于 <code>-XX: InitialHeadSize</code></li>
<li><code>-Xmx(X Memory Max)</code> 用于表示堆区的最大内存，等价于 <code>-XX: MaxHeapSize</code></li>
</ul>
</li>
<li>一旦堆区中的内存大小超过 <code>-Xmx</code> 所指定的最大内存时，则会抛出 <code>OutOfMemoryError</code> 异常</li>
<li>通常会将 <code>-Xms</code> 和 <code>-Xmx</code> 两个参数配置相同的值，其目的是 <strong>为了能够在 <code>Java</code> 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong></li>
<li>默认情况下，初始内存大小：<strong>物理电脑内存大小 / 64</strong>，最大内存大小：<strong>物理电脑内存大小 / 4</strong></li>
</ul>
</blockquote>
<h4 id="3-4-3、年轻代与老年代"><a href="#3-4-3、年轻代与老年代" class="headerlink" title="3.4.3、年轻代与老年代"></a>3.4.3、年轻代与老年代</h4><blockquote>
<ul>
<li><p>存储在 <code>JVM</code> 中的 <code>Java</code> 对象可以被划分为两类：</p>
<ul>
<li>生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>生命周期很长，在某些极端的情况下还能与 <code>JVM</code> 的生命周期保持移至</li>
</ul>
</li>
<li><p><code>Java</code> 堆区进一步细分，可分为年轻代和老年代</p>
</li>
<li><p>其中年轻代又可划分成 <code>Eden</code> 空间、<code>S0(from)</code> 和 <code>S1(to)</code> </p>
</li>
<li><p>配置新生代与老年代在堆结构的占比</p>
<ul>
<li>默认：<code>-XX:NewRatio=2</code>，代表新生代占 <code>1</code>，老年代占 <code>2</code>，新生代占整个堆的 <code>1/3</code></li>
</ul>
</li>
<li><p>配置 <code>Eden</code> 和两个 <code>Survivor</code> 的比例</p>
<ul>
<li>默认：<code>-XX:SurvivorRatio=8</code>，代表 <code>Eden</code> 占 <code>8</code>，两个 <code>Survivor</code> 各占 <code>1</code></li>
</ul>
</li>
<li><p><strong>几乎所有的 <code>Java</code> 对象都是在 <code>Eden</code> 区被 <code>new</code> 出来的</strong></p>
</li>
<li><p>绝大部分 <code>Java</code> 对象的销毁都在新生代中进行</p>
<ul>
<li><code>IBM</code> 公司专门研究表明，新生代中 <code>80%</code> 的对象都是 “朝生夕死”</li>
</ul>
</li>
<li><p>可使用 <code>-Xmn</code> 设置新生代最大内存大小</p>
</li>
</ul>
</blockquote>
<h4 id="3-4-4、对象分配过程"><a href="#3-4-4、对象分配过程" class="headerlink" title="3.4.4、对象分配过程"></a>3.4.4、对象分配过程</h4><blockquote>
<p>为新对象分配内存是一件非常严谨和复杂的任务，<code>JVM</code> 的设计者们不进需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 <code>GC</code> 执行完内存回收后是否会在内存空间中产生内存碎片</p>
<ul>
<li><code>new </code> 的对象先放在 <code>Eden</code> 区，此区有大小限制</li>
<li>当 <code>Eden</code> 区的空间填满，程序又需要创建新的对象，<code>JVM</code> 的垃圾回收器对 <code>Eden</code> 区进行垃圾回收 <code>(Minor GC)</code>，将 <code>Eden</code> 区中不再被其他对象所引用的对象进行销毁。再加载新的对象放到 <code>Eden</code> 区</li>
<li>然后将 <code>Eden</code> 中剩余的对象移动到 <code>Survivor 0</code> 区</li>
<li>如果再次出发垃圾回收，此时上次幸存下来的放到 <code>Survivor 0</code> 区的如果没有回收，就会放到 <code>Survivor 1</code> 区</li>
<li>如果再次经历垃圾回收，此时会重新放回 <code>Survivor 0</code> 区，如此反复 </li>
<li>每次放入 <code>Survivor</code> 区，就使对象的年龄计数增加 <code>1</code>，当年龄达到 <code>15</code>，下一次如果仍然没有被回收，就会被放入 <code>Old</code> 区<ul>
<li>修改晋升年龄：<code>-XX:MaxTenuringThreshold</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>常用调优工具</strong></p>
<blockquote>
<ul>
<li><code>JDK</code> 命令行</li>
<li><code>Jconsole</code></li>
<li><code>JVisualVM</code></li>
<li><code>JProfiler</code></li>
<li><code>Java Filght Recorder</code></li>
<li><code>GCViewer</code></li>
<li><code>GC Easy</code></li>
</ul>
</blockquote>
<h4 id="3-4-5、Minor-GC、Major-GC、Full-GC"><a href="#3-4-5、Minor-GC、Major-GC、Full-GC" class="headerlink" title="3.4.5、Minor GC、Major GC、Full GC"></a>3.4.5、Minor GC、Major GC、Full GC</h4><blockquote>
<p><code>JVM</code> 在进行 <code>GC</code> 的时候并非每次都对上面三个内存区域一起回收，大部分时候回收的都是指新生代，针对 <code>HotSpot VM</code> 的实现，它里面的 <code>GC</code> 按照回收区域又分为两大种类型：一种是部分回收 <code>Partial GC</code>，一种是整堆回收 <code>Full GC</code></p>
<ul>
<li>部分回收：不是完整收集整个 <code>Java</code> 堆的垃圾收集<ul>
<li>新生代收集 <code>(Minor GC/Young GC)</code>：只是新生代的垃圾收集</li>
<li>老年代收集 <code>(Major GC/Old GC1)</code>：只是老年代的垃圾收集<ul>
<li>目前，只有 <code>CMS GC</code> 会有单独收集老年代的行为</li>
<li><strong>很多时候 <code>Major GC</code> 会和 <code>Full GC</code> 混淆使用，需要具体分辨是老年代回收还是整堆回收</strong></li>
</ul>
</li>
<li>混合收集 <code>Mixed GC</code>：收集整个新生代以及部分老年代的垃圾收集，目前只有 <code>G1 GC</code> 会有这种行为</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>整堆收集 <code>Full GC</code>：收集整个 <code>Java</code> 堆和方法区的垃圾收集 </li>
</ul>
</blockquote>
<h5 id="3-4-5-1、年轻代-GC-触发机制"><a href="#3-4-5-1、年轻代-GC-触发机制" class="headerlink" title="3.4.5.1、年轻代 GC 触发机制"></a>3.4.5.1、年轻代 GC 触发机制</h5><blockquote>
<ul>
<li>当年轻代空间不足时，就会触发 <code>Minor GC</code>，这里的年轻代满指的是 <code>Eden</code> 区满，且 <code>Survivor</code> 区满时不会触发 <code>GC</code></li>
<li>因为 <code>Java</code> 对象大多都是具备朝生夕死的特性，所以 <code>Minor GC</code> 非常频繁，一般回收速度也比较快</li>
<li><code>Minor GC</code> 会触发 <code>STW</code>，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
</ul>
</blockquote>
<h5 id="3-4-5-2、老年代-GC-触发机制"><a href="#3-4-5-2、老年代-GC-触发机制" class="headerlink" title="3.4.5.2、老年代 GC 触发机制"></a>3.4.5.2、老年代 GC 触发机制</h5><blockquote>
<ul>
<li>指发生在老年代的 <code>GC</code>，对象从老年代消失时，我们说 <code>Major GC</code> 或 <code>Full GC</code> 发生了</li>
<li>出现了 <code>Major GC</code>，经常会伴随至少一次的 <code>Minor GC</code>，但非绝对，在 <code>Parallel Scavenge</code> 收集器的收集策略里就有直接进行 <code>Major GC</code> 的策略选择过程<ul>
<li>也就是在老年代空间不足时，会先尝试触发 <code>Minor GC</code>，如果之后空间还不足，则触发 <code>Major GC</code></li>
</ul>
</li>
<li><code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上，<code>STW</code> 时间更长</li>
<li>如果 <code>Major GC</code> 后，内存还不足，就会报 <code>OOM</code></li>
</ul>
</blockquote>
<h5 id="3-4-5-3、整堆回收-GC-触发机制"><a href="#3-4-5-3、整堆回收-GC-触发机制" class="headerlink" title="3.4.5.3、整堆回收 GC 触发机制"></a>3.4.5.3、整堆回收 GC 触发机制</h5><blockquote>
<ul>
<li>调用 <code>System.gc()</code>，系统建议执行 <code>Full GC</code> 但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过 <code>Minor GC</code> 后进入老年代的平均大小大于老年代的可用内存</li>
<li>由 <code>Eden</code> 区、<code>From</code> 区向 <code>to</code> 区复制时，对象大小大于 <code>to</code> 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象的大小</li>
<li><strong><code>Full GC</code> 是开发或调优中尽量要避免的，这样暂停时间会短一些</strong></li>
</ul>
</blockquote>
<h4 id="3-4-6、堆空间分代思想"><a href="#3-4-6、堆空间分代思想" class="headerlink" title="3.4.6、堆空间分代思想"></a>3.4.6、堆空间分代思想</h4><blockquote>
<p>其实不分代也是完全可以的，分代的唯一理由就是 <strong>优化 <code>GC</code> 的性能</strong>。如果没有分代，那所有的对象都在一块，<code>GC</code> 的时候要找到哪些没用的对象，就需要对整个堆进行扫描。</p>
</blockquote>
<h4 id="3-4-7、内存分配策略"><a href="#3-4-7、内存分配策略" class="headerlink" title="3.4.7、内存分配策略"></a>3.4.7、内存分配策略</h4><blockquote>
<ul>
<li>如果对象在 <code>Eden</code> 区出生并经历过一次 <code>Minor GC</code> 后仍然存活，并且能够被 <code>Survivor</code> 容纳，将被移动到 <code>Survivor</code> 中，并将对象年龄设置为 <code>1</code>，对象在 <code>Survivor</code> 区中每熬过一次 <code>Minor GC</code>，年龄就增加 <code>1</code> 岁，当年龄达到一定程度时，就会被晋升到老年代</li>
</ul>
<hr>
<ul>
<li>官方规则：<ul>
<li>优先分配到 <code>Eden</code></li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果 <code>Survivor</code> 区中相同年龄的所有对象大小的总和大于 <code>Survivor</code> 空间的一半，年龄大于或该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 的要求年龄</li>
</ul>
</li>
<li>空间分配担保<ul>
<li><code>-XX:HandlePromotionFailure</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-4-8、为对象分配内存：TLAB"><a href="#3-4-8、为对象分配内存：TLAB" class="headerlink" title="3.4.8、为对象分配内存：TLAB"></a>3.4.8、为对象分配内存：TLAB</h4><h5 id="3-4-8-1、为什么要有-TLAB"><a href="#3-4-8-1、为什么要有-TLAB" class="headerlink" title="3.4.8.1、为什么要有 TLAB"></a>3.4.8.1、为什么要有 TLAB</h5><blockquote>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在 <code>JVM</code> 中非常频繁，因此在并发的环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用枷锁等机制，进而影响分配速度      </li>
</ul>
</blockquote>
<h5 id="3-4-8-2、什么是-TLAB"><a href="#3-4-8-2、什么是-TLAB" class="headerlink" title="3.4.8.2、什么是 TLAB"></a>3.4.8.2、什么是 TLAB</h5><blockquote>
<ul>
<li>从内存模型而不是垃圾收集的角度，对 <code>Eden</code> 区进行划分，**<code>JVM</code> 为每个线程分配一个私有缓存区域**，它包含在 <code>Eden</code> 空间内</li>
<li>多线程同时分配内存时，使用 <code>TLAB</code> 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为 <strong>快速分配策略</strong></li>
<li>由 <code>OpenJDK</code> 衍生出来的 <code>JVM</code> 都提供了 <code>TLAB</code> 设计</li>
<li>尽管不是所有的对象实例都能够在 <code>TLAB</code> 中成功分配内存，<strong>但 <code>JVM</code> 确实是将 <code>TLAB</code> 作为内存分配的首选</strong></li>
<li>在程序中，开发人员可以通过 <code>-XX:UseTLAB</code> 设置是否开启 <code>TALB</code> 空间</li>
<li>默认情况下，<code>TLAB</code> 空间的内存非常小，**仅占整个 <code>Eden</code> 区的 1%**，<code>-XX:TLABWasteTargetPercent</code> 可以设置其百分比大小</li>
<li>一旦对象在 <code>TLAB</code> 空间分配内存失败，<code>JVM</code> 就会尝试着通过使用 <strong>加锁机制</strong> 确保数据操作的原子性，从而直接在 <code>Eden</code> 空间中分配内存</li>
</ul>
</blockquote>
<h5 id="3-4-8-3、对象分配过程"><a href="#3-4-8-3、对象分配过程" class="headerlink" title="3.4.8.3、对象分配过程"></a>3.4.8.3、对象分配过程</h5><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8BTLAB.png" alt="对象分配过程TLAB"></p>
</blockquote>
<h4 id="3-4-9、堆空间参数设置"><a href="#3-4-9、堆空间参数设置" class="headerlink" title="3.4.9、堆空间参数设置"></a>3.4.9、堆空间参数设置</h4><blockquote>
<ul>
<li><code>-XX:+PrintFlagsInitial</code>：查看所有参数的默认初始值</li>
<li><code>-XX:+PrintFlagsFinal</code>：查看所有参数的最终值</li>
<li><code>-Xms</code>：初始化堆空间大小，**<code>default = 1/64</code>**</li>
<li><code>-Xmx</code>：最大堆空间大小，**<code>default = 1/4</code>**</li>
<li><code>-Xmn</code>：设置新生代的大小</li>
<li><code>-XX:NewRatio</code>：设置新生代与老年代在对结构的占比，**<code>default = 1:2</code>**</li>
<li><code>-XX:SurvivorRatio</code>：设置新生代中 <code>Eden</code> 和 <code>S0</code>、<code>S1</code> 的空间比例，**<code>default = 8:1:1</code>**</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置新生代晋升的年龄</li>
<li><code>-XX:+PrintGCDetails</code>：输出详细的 <code>GC</code> 日志<ul>
<li><code>-XX:+PrintGC</code> 、<code>-verbose:gc</code>：打印简要 <code>GC</code> 信息</li>
</ul>
</li>
<li><code>-XX:HandlePromotionFailure</code>：是否设置空间分配担保</li>
</ul>
</blockquote>
<h4 id="3-4-10、逃逸分析"><a href="#3-4-10、逃逸分析" class="headerlink" title="3.4.10、逃逸分析"></a>3.4.10、逃逸分析</h4><blockquote>
<ul>
<li>随着 <code>JIT</code> 编译器的发展与 <strong>逃逸分析</strong> 技术逐渐成熟，<strong>栈上分配、标量替换优化技术</strong> 将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了</li>
<li>在 <code>Java</code> 虚拟机中，对象是在 <code>Java</code> 堆中分配内存的，这是一个常识。但是，有一种特殊情况，那就是 <strong>如果经过逃逸分析 <code>(Escape Analysis)</code> 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无需进行垃圾回收了</li>
<li>此外，基于 <code>OpenJDK</code> 森都定制的 <code>TaoBaoVM</code>，其中创新的 <code>GCIH(GC invisible heap)</code> 技术实现 <code>off-heap</code>，将生命周期较长的 <code>Java</code> 对象从 <code>heap</code> 中移至 <code>heap</code> 外，并且 <code>GC</code> 不能管理 <code>GCIH</code> 内部的 <code>Java</code> 对象，依次达到降低 <code>GC</code> 回收频率和提升 <code>GC</code> 回收效率的目的</li>
</ul>
</blockquote>
<h5 id="3-4-10-1、逃逸分析"><a href="#3-4-10-1、逃逸分析" class="headerlink" title="3.4.10.1、逃逸分析"></a>3.4.10.1、逃逸分析</h5><blockquote>
<ul>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段</li>
<li>这是一种可以有效减少 <code>Java</code> 程序中同步负载和内存堆分配压力的跨函数全局数据量分析算法</li>
<li>通过逃逸分析，<code>Java HotSpot</code> 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</li>
<li>逃逸分析的基本行为就是分析对象动态作用域<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>代码优化：<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针要永远不会逃逸，对象可能使栈分配的候选，而不是堆分配<ul>
<li><code>JIT</code> 编译器在编译期间根据逃逸分析的结果，发现一个对象并没有逃逸出方法，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无需进行垃圾回收</li>
</ul>
</li>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程访问到，那么对于这个对象的操作可以不考虑同步<ul>
<li>在动态编译同步块的时候，<code>JIT</code> 编译器可以借助逃逸分析来 <strong>判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程</strong>，如果没有，那么 <code>JIT</code> 编译器在编译这个同步块的时候就会取消对这部分代码的同步，这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫 <strong>锁消除</strong></li>
</ul>
</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以不存储在内存，而是存储在 <code>CPU</code> 寄存器<ul>
<li><strong>标量 <code>Scalar</code></strong> 是指一个无法再分解成更小的数据类型的数据。<code>Java</code> 中的原始数据类型就是标量</li>
<li>相对的，哪些还可以分解的数据叫做 **聚合量 <code>(Aggregate)</code>**，<code>Java</code> 中的对象就是聚合量，因为他可以分解成其他聚合量和标量</li>
<li>在 <code>JIT</code> 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 <code>JIT</code> 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替代，这个过程就叫做 <strong>标量替换</strong></li>
<li>开启标量替换：<code>-XX:+EliminateAllocations</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-4-10-2、参数设置"><a href="#3-4-10-2、参数设置" class="headerlink" title="3.4.10.2、参数设置"></a>3.4.10.2、参数设置</h5><blockquote>
<ul>
<li><code>-server</code>：逃逸分析只有在 <code>Server</code> 模式下才可以启用</li>
<li><code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li>
<li><code>-X:+EliminateAllocations</code>：开启了表链那个替换，允许将对象打散分配到栈上，比如对象拥有 <code>id</code> 和 <code>name</code> 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ul>
</blockquote>
<h5 id="3-4-10-3、逃逸分析并不成熟"><a href="#3-4-10-3、逃逸分析并不成熟" class="headerlink" title="3.4.10.3、逃逸分析并不成熟"></a>3.4.10.3、逃逸分析并不成熟</h5><blockquote>
<ul>
<li>关于逃逸分析的论文在 <code>1999</code> 年就已经发表，直到 <code>JDK 1.6</code> 才有实现，而这项技术到如今也并不是十分成熟</li>
<li>其根本原因就是 <strong>无法保证逃逸分析的性能小号一定高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、锁消除。但是逃逸分析自身也是需要进行一些列复杂的分析，这其实也是一个相对耗时的过程</strong></li>
<li>虽然这项技术并不十分成熟，但是他也是 <strong>即时编译器优化技术中一个十分重要的手段</strong></li>
<li>有些观点认为通过逃逸分析，<code>JVM</code> 会在栈上分配哪些不会逃逸的对象，这在理论上是可行的，但是取决于 <code>JVM</code> 设计者的选择，<code>Oracle Hotspot JVM</code> 并未这么做</li>
<li>米钱很多书籍还是基于 <code>JDK 7</code> 以前的版本，<code>JDK</code> 已经发生了很大的变化，<code>intern</code> 字符串的缓存和静态变量曾经都被分配在永久代，而永久代已经被元数据区所取代。但是 <code>intern</code> 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面的结论：<strong>对象实例都是分配在堆上的</strong></li>
</ul>
</blockquote>
<h3 id="3-5、Method-Area"><a href="#3-5、Method-Area" class="headerlink" title="3.5、Method Area"></a>3.5、Method Area</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Oracle 官网介绍</a></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="运行时数据区结构图"></p>
<h4 id="3-5-1、堆、栈、方法区的交互关系"><a href="#3-5-1、堆、栈、方法区的交互关系" class="headerlink" title="3.5.1、堆、栈、方法区的交互关系"></a>3.5.1、堆、栈、方法区的交互关系</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法区  栈		堆</span></span><br><span class="line"><span class="comment">// Person person = new Person();</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法区在哪里：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩，但对于 <code>HotSpot JVM</code> 而言，方法区还有一个别名叫做 <code>Non-Heap</code>，目的就是要和堆分开。<strong>所以，方法区看作是一块独立于 <code>Java</code> 堆的内存空间</strong> </p>
</li>
<li><p>方法区和堆一样，是各个线程共享的内存区域</p>
</li>
<li><p>方法区在 <code>JVM</code> 启动的时候被创建，并且它实际的物理内存空间中和 <code>Java</code> 堆区一样都可以是不连续的</p>
</li>
<li><p>方法区的大小，跟堆空间的一样，可以选择固定大小或者可扩展</p>
</li>
<li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存移除的错误，<code>java.lang.OutOfMemoryError: PermGenspace</code> 或 <code>java.lang.OutOfMemoryError: Metaspace</code></p>
</li>
<li><p>关闭虚拟机就会释放这个内存的区域</p>
</li>
</ul>
</blockquote>
<h5 id="3-5-1-1、Hopspot-JVM-中方法区的演进"><a href="#3-5-1-1、Hopspot-JVM-中方法区的演进" class="headerlink" title="3.5.1.1、Hopspot JVM 中方法区的演进"></a>3.5.1.1、Hopspot JVM 中方法区的演进</h5><blockquote>
<ul>
<li>在 <code>JDK7</code> 以前，习惯上把方法区称为永久代，从 <code>JDK8</code> 开始，使用原空间取代了永久代</li>
<li>本质上，方法区和永久代并不等价，仅对 <code>Hotspot</code> 而言的，对如何实现方法区，不做统一要求。例如：<code>BEA JRockit / IBM J9</code> 中不存在永久代的概念<ul>
<li>现在看来，当年使用永久代，其实并不是一个好主意，导致 <code>Java</code> 程序更容易 <code>OOM</code>，即：容易超过 <code>-XX:MaxPermSize</code> 上限</li>
</ul>
</li>
<li>到了 <code>JDK8</code>，终于完全废弃了永久代的概念，改用 <code>JRocket</code>、<code>J9</code> 一样在本地内存中实现的元空间来代替</li>
<li>元空间的本质和永久代类似，都是对 <code>JVM</code> 规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></li>
<li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li>
<li>根据《<code>Java</code> 虚拟机规范》规定，如果方法区无法满足新的内存分配需求，将抛出 <code>OOM</code> 异常</li>
</ul>
</blockquote>
<h4 id="3-5-2、设置方法区内存的大小"><a href="#3-5-2、设置方法区内存的大小" class="headerlink" title="3.5.2、设置方法区内存的大小"></a>3.5.2、设置方法区内存的大小</h4><blockquote>
<ul>
<li>方法区的大小不必是固定的，<code>JVM</code> 可以根据应用的需要动态调整</li>
</ul>
<hr>
<ul>
<li><code>JDK7</code> 及以前<ul>
<li>通过 <code>-XX:PermSize</code> 来设置永久代初始分配空间。默认 <code>20.75M</code></li>
<li>通过 <code>-XX:MaxPermSize</code> 来设置永久代最大可分配空间。<code>32</code> 位机器默认是 <code>64M</code>，<code>64</code> 位机器默认 <code>82M</code></li>
<li>当 <code>JVM</code> 加载的类信息大小超过这个值，就会抛出异常<code>OutOfMemoryError:PermGen Space</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>JDK8</code> 及以后<ul>
<li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台，**<code>Windows</code> 下，<code>-XX:MetaspaceSize</code> 默认值是 <code>21M</code>，<code>-XX:MaxMetaspaceSize</code> 的值是 <code>-1</code>即没有限制**</li>
<li>与永久代不同，如果不指定大小，默认情况下 <strong>虚拟机会耗尽所有可用的系统内存</strong>，如果元数据区发生溢出，虚拟机一样会抛出异常，即 <code>OutOfMemoryError: Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 <strong>64</strong> 位的服务端 <code>JVM</code> 来说，其默认值为 <code>21M</code>，这就是初始的高水位线，一旦触及这个水位线，<code>Full GC</code> 将被触发并卸载没用的类，<strong>然后这个高水位线将会被重置</strong>。新的高水位线取决于 <code>GC</code> 释放了多少原空间，如果释放空间过多，则适当降低该值</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收的日志可以观察到 <code>Full GC</code> 多次调用，为了频繁地进行垃圾回收，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>如何解决 <code>OOM</code><ul>
<li>要解决 <code>OOM</code> 异常或者 <code>heap space</code> 异常，一般的手段是首先通过内存映像分析工具对 <code>dump</code> 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是先清楚是出现内存泄漏<code>Memory Leak</code> 还是内存溢出 <code>Memory Overflow</code></li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 <code>GC Roots</code> 的用于链。于是就能找到泄漏对象是通过怎样的路径与 <code>GC Roots</code> 相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息，以及 <code>GC Roots</code> 引用链的信息，就可以比较明确地定位出泄漏代码的位置</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实还必须存活者，那就应当检查虚拟机的对参数 <code>(-Xms 与 -Xmx)</code>，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-5-3、方法区的内部结构"><a href="#3-5-3、方法区的内部结构" class="headerlink" title="3.5.3、方法区的内部结构"></a>3.5.3、方法区的内部结构</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88.png" alt="方法区存储什么"></p>
<ul>
<li>用于存储已被虚拟机加载的 <strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存等</strong></li>
</ul>
<hr>
<ul>
<li>类型信息：对每个加载的类型 <code>(类 class、接口 interface、枚举 enum、注解 annotation)</code>，<code>JVM</code> 必须在方法区中存储以下类型信息<ul>
<li>这个类型的完整有效名称（包名.类名）</li>
<li>这个类型直接父类的完整有效名称（对于 <code>interface</code> 和 <code>java.lang.Object</code> 都没有父类）</li>
<li>这个类型的修饰符 <code>(public, abstract, final 的某个子集)</code></li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>域：<code>JVM</code> 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序<ul>
<li>域的相关信息包括：域名称、域类型、域修饰符 <code>(public, private, protected, static, final, volatile, transient 的某个子集)</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>方法：<code>JVM</code> 必须保存所有方法的以下信息，同域信息一样包括声明顺序<ul>
<li>方法名</li>
<li>返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符 <code>(public, private, protected, static, final, synchronized, native, abstract 的某个子集)</code></li>
<li>方法的字节码，操作数栈，局部变量表及大小 <code>(abstract 和 native 方法除外)</code></li>
<li>异常表 <code>(abstract 和 native 方法除外)</code><ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-5-3-1、Non-final-的类变量"><a href="#3-5-3-1、Non-final-的类变量" class="headerlink" title="3.5.3.1、Non-final 的类变量"></a>3.5.3.1、Non-final 的类变量</h5><blockquote>
<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例共享，即使没有类实例时同样可以访问</li>
</ul>
</blockquote>
<h5 id="3-5-3-2、Static-final-的类变量"><a href="#3-5-3-2、Static-final-的类变量" class="headerlink" title="3.5.3.2、Static-final 的类变量"></a>3.5.3.2、Static-final 的类变量</h5><blockquote>
<ul>
<li>被声明为 <code>final</code> 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了</li>
</ul>
</blockquote>
<h5 id="3-5-3-3、常量池与运行时常量长"><a href="#3-5-3-3、常量池与运行时常量长" class="headerlink" title="3.5.3.3、常量池与运行时常量长"></a>3.5.3.3、常量池与运行时常量长</h5><blockquote>
<ul>
<li>方法区内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚 <code>Class</code> 文件，因为加载类的信息都在方法区</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚 <code>Class</code> 文件的常量池</li>
<li>一个有效的字节码文件中出了包含类的版本信息、字段、方法以及接口等描述信息以外，还包含一项信息那就是常量池表 <code>(Constant Pool Table)</code>，包括各种字面量和类型、域和方法的符号引用</li>
</ul>
<hr>
<ul>
<li>为什么要有常量池<ul>
<li>一个 <code>Java</code> 源文件中的类、接口，编译后产生一个字节码文件。而 <code>Java</code> 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里 ，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>常量池有什么<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>运行时常量池<ul>
<li>运行时常量池 <code>(Runtime Constant Pool)</code> 是方法区的一部分</li>
<li>常量池表 <code>(Constant Pool Table)</code> 是 <code>class</code> 文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池</strong></li>
<li>运行时常量池，在加载类和接口到虚拟机以后，就会创建对应的运行时常量池</li>
<li><code>JVM</code> 为每个已加载的类型都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里转换为真实地址<ul>
<li>运行时常量池，相对于 <code>class</code> 文件常量池的另一重要特征是：具备动态性</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富一些</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区能提供的最大值，则 <code>JVM</code> 会抛出 <code>OutOfMemoryError</code> 异常</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-5-4、方法区使用举例"><a href="#3-5-4、方法区使用举例" class="headerlink" title="3.5.4、方法区使用举例"></a>3.5.4、方法区使用举例</h4><blockquote>
<ul>
<li> <code>Java</code> 代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class</code> 字节码</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Classfile /C:/Users/Cying/Desktop/MethodAreaDemo.class</span><br><span class="line">  Last modified 2020-7-12; size 432 bytes</span><br><span class="line">  MD5 checksum b502befbb8c73360f9559bae53ee2e31</span><br><span class="line">  Compiled from &quot;MethodAreaDemo.java&quot;</span><br><span class="line">  </span><br><span class="line">public class MethodAreaDemo</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  </span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #15.#16        // </span><br><span class="line">   </span><br><span class="line"> java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #17.#18        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #19            // MethodAreaDemo</span><br><span class="line">   #5 = Class              #20            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               main</span><br><span class="line">  #11 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #12 = Utf8               SourceFile</span><br><span class="line">  #13 = Utf8               MethodAreaDemo.java</span><br><span class="line">  #14 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #15 = Class              #21            // java/lang/System</span><br><span class="line">  #16 = NameAndType        #22:#23        // out:Ljava/io/PrintStream;</span><br><span class="line">  #17 = Class              #24            // java/io/PrintStream</span><br><span class="line">  #18 = NameAndType        #25:#26        // println:(I)V</span><br><span class="line">  #19 = Utf8               MethodAreaDemo</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">  #21 = Utf8               java/lang/System</span><br><span class="line">  #22 = Utf8               out</span><br><span class="line">  #23 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #24 = Utf8               java/io/PrintStream</span><br><span class="line">  #25 = Utf8               println</span><br><span class="line">  #26 = Utf8               (I)V</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  public MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=5, args_size=1</span><br><span class="line">         0: sipush        500</span><br><span class="line">         3: istore_1</span><br><span class="line">         4: bipush        100</span><br><span class="line">         6: istore_2</span><br><span class="line">         7: iload_1</span><br><span class="line">         8: iload_2</span><br><span class="line">         9: idiv</span><br><span class="line">        10: istore_3</span><br><span class="line">        11: bipush        50</span><br><span class="line">        13: istore        4</span><br><span class="line">        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        18: iload_3</span><br><span class="line">        19: iload         4</span><br><span class="line">        21: iadd</span><br><span class="line">        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        25: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 4</span><br><span class="line">        line 6: 7</span><br><span class="line">        line 7: 11</span><br><span class="line">        line 8: 15</span><br><span class="line">        line 9: 25</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MethodAreaDemo.java&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Init</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B1.png" alt="方法区举例1"></p>
</li>
<li><p><code>Step1</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B2.png" alt="方法区举例2"></p>
</li>
<li><p><code>Step2</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B3.png" alt="方法区举例3"></p>
</li>
<li><p><code>Step3</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B4.png" alt="方法区举例4"></p>
</li>
<li><p><code>Step4</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B5.png" alt="方法区举例5"></p>
</li>
<li><p><code>Step5</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B6.png" alt="方法区举例6"></p>
</li>
<li><p><code>Step6</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B7.png" alt="方法区举例7"></p>
</li>
<li><p><code>Step7</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B8.png" alt="方法区举例8"></p>
</li>
<li><p><code>Step8</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B9.png" alt="方法区举例9"></p>
</li>
<li><p><code>Step9</code></p>
<p> <img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B10.png" alt="方法区举例10"></p>
</li>
<li><p><code>Step10</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B11.png" alt="方法区举例11"></p>
</li>
<li><p><code>Step11</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B12.png" alt="方法区举例12"></p>
</li>
<li><p><code>Step12</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B13.png" alt="方法区举例13"></p>
</li>
<li><p><code>Step13</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B14.png" alt="方法区举例14"></p>
</li>
<li><p><code>Step14</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B15.png" alt="方法区举例15"></p>
</li>
<li><p><code>Step15</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B16.png" alt="方法区举例16"></p>
</li>
</ul>
</blockquote>
<h4 id="3-5-5、方法演进的细节"><a href="#3-5-5、方法演进的细节" class="headerlink" title="3.5.5、方法演进的细节"></a>3.5.5、方法演进的细节</h4><blockquote>
<ul>
<li><p>首先明确：只有 <code>HotSpot</code> 才有永久代，<code>BEA JRockit</code>、<code>IBM J9</code> 事不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《<code>Java</code> 虚拟机规范》约束，并不要求统一</p>
</li>
<li><p><code>HotSpot</code> 中方法区的变化</p>
<table>
<thead>
<tr>
<th>时段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>JDK 1.7</code> 以前</td>
<td>有永久代 <code>(Permanent Generation)</code>，<br/>静态变量存放在永久代<br /><br /><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/JDK6_Method.png" alt="JDK6_Method" style="zoom: 50%;" /></td>
</tr>
<tr>
<td><code>JDK 1.7</code></td>
<td>有永久代，但已经逐步 “去永久代”，字符串常量池、<br/>静态变量溢出，保存在堆中<br /><br /><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/JDK7_Method.png" alt="JDK7_Method" style="zoom: 50%;" /></td>
</tr>
<tr>
<td><code>JDK 1.7</code> 以后</td>
<td>无永久代，类型信息、字段、方法、常量保存在本地的<br/>元空间，但字符串常量池、静态变量仍在堆<br /><br /><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/JDK8_Method.png" alt="JDK8_Method" style="zoom: 50%;" /></td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<h5 id="3-5-5-1、为什么要用元空间替换永久代"><a href="#3-5-5-1、为什么要用元空间替换永久代" class="headerlink" title="3.5.5.1、为什么要用元空间替换永久代"></a>3.5.5.1、为什么要用元空间替换永久代</h5><blockquote>
<ul>
<li>随着 <code>Java 8</code> 的到来，<code>HotSpot VM</code> 中再也见不到永久代了，但是这并不意味着类的元数据信息也消失。这些数据被迁移到一个 <strong>与堆不相连的本地内存区域，这个区域叫做元空间</strong></li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间</li>
<li>这项改动是很有必要的<ul>
<li>为永久代设置空间大小是很难确定的，在某些场景下，如果动态加载类过多，容易产生 <code>Perm</code> 区的 <code>OOM</code>。比如某个实际 <code>Web</code> 工程中，因为功能点比较多，在运行过程中，要不断的动态加载很多类，经常出现致命错误：<br><code>Exception in thread &#39;dubbo client *.* connector&#39; java.lang.OutOfMemoryError: PermGen space</code>，而元空间与永久代之间最大的区别在于 <strong>元空间并不在虚拟机中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制</strong></li>
<li>对永久代进行调优是很困难的</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-5-5-2、为什么要调整-String-Table"><a href="#3-5-5-2、为什么要调整-String-Table" class="headerlink" title="3.5.5.2、为什么要调整 String Table"></a>3.5.5.2、为什么要调整 String Table</h5><blockquote>
<ul>
<li><code>JDK 7</code> 中将 <code>StringTable</code> 放到了堆空间中，因为永久代的回收效率很低，在 <code>Full GC</code> 的时候才会触发。而 <code>Full GC</code> 是老年代或永久代空间不足时才会触发，这就导致 <code>String Table</code> 的回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存</li>
</ul>
</blockquote>
<h4 id="3-5-6、方法区的垃圾回收"><a href="#3-5-6、方法区的垃圾回收" class="headerlink" title="3.5.6、方法区的垃圾回收"></a>3.5.6、方法区的垃圾回收</h4><blockquote>
<ul>
<li>有些人认为方法区，如 <code>HotSpot</code> 虚拟机中的元空间或者永久代，是没有垃圾回收行为的，其实不然，《<code>Java</code> 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾回收，事实上也确实有为实现或未能完整实现方法区类型卸载的收集器存在</li>
<li>一般来说 <strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</strong>。但是这部分区域的回收有时 <strong>又是必须的</strong>。以前 <code>Sun</code> 公司的 <code>Bug</code> 列表中，曾出现过若干的严重的 <code>Bug</code> 就是由于低版本的 <code>HotSpot</code> 虚拟机对此区域未完全回收而导致内存泄漏</li>
<li><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</strong></li>
</ul>
</blockquote>
<h5 id="3-5-6-1、常量回收"><a href="#3-5-6-1、常量回收" class="headerlink" title="3.5.6.1、常量回收"></a>3.5.6.1、常量回收</h5><blockquote>
<ul>
<li>方法区常量池主要存放的两大类常量：<strong>字面量</strong> 和 <strong>符号引用</strong>。字面量比较接近 <code>Java</code> 语言层次的常量概念，如文本字符串，被声明为 <code>final</code> 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三种常量<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li><code>HotSpot</code> 虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收</strong></li>
<li>回收废弃常量与回收 <code>Java</code> 堆中的对象非常类似</li>
</ul>
</blockquote>
<h5 id="3-5-6-2、类信息的回收"><a href="#3-5-6-2、类信息的回收" class="headerlink" title="3.5.6.2、类信息的回收"></a>3.5.6.2、类信息的回收</h5><blockquote>
<ul>
<li>判定一个常量是否 “废弃” 还是相对简单，而要判定一个类型是否属于 “不再被使用的类” 的条件就比较苛刻了，需要同时满足下面三个条件<ul>
<li>该类所有的实例都已经被回收，也就是 <code>Java</code> 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的加载器已被回收，这个条件除非是精心设计的可替换类加载器场景，如 <code>OSGI</code>、<code>JSP</code> 的重加载等，否则通常是很难达成的</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
<li><code>Java</code> 虚拟机被允许对满足上述三个条件的无用类进行回收，这里要说的仅仅是 “被允许”，而并不是和对象一样，没有了引用就必然会回收。关于是否要对类型进行回收，<code>HotSpot</code> 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、<code>CGLib</code> 等字节码框架，动态生成 <code>JSP</code> 以及 <code>OSGI</code> 这类频繁自定义类加载器的场景中，<strong>通常都需要 <code>Java</code> 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</strong></li>
</ul>
</blockquote>
<h3 id="3-6、小结"><a href="#3-6、小结" class="headerlink" title="3.6、小结"></a>3.6、小结</h3><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B0%8F%E7%BB%93.png" alt="运行时数据区-小结"></p>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="四、本地方法接口"><a href="#四、本地方法接口" class="headerlink" title="四、本地方法接口"></a>四、本地方法接口</h2><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3.png" alt="本地方法接口"></p>
<blockquote>
<ul>
<li>定义：简单地讲，<strong>一个 <code>Native Method</code> 就是一个 <code>Java</code> 调用非 <code>Java</code> 代码的接口</strong>，一个 <code>Native Method</code> 是这样的一个 <code>Java</code> 方法：该方法的实现由非 <code>Java</code> 语言实现，比如 <code>C</code>，这个特征并非 <code>Java</code> 特有，很多其他的编程语言都有这一机制，比如在 <code>C++</code> 中，就可以用 <code>extern “C”</code> 告知 <code>C++</code> 编译器去调用一个 <code>C</code> 函数<ul>
<li><code>Native method is a Java method whose implementation is provided by non-java code</code></li>
<li>在定义一个 <code>Native method</code> 时，并不提供实现体（有些像定义一个 <code>Java Interface</code>，因为其实现体是由非 <code>Java</code> 语言在外面实现的</li>
<li>本地接口的作用时融合不同的编程语言为 <code>Java</code> 所用，初衷是融合 <code>C/C++</code> </li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>为什么要使用 <code>Native Method</code>：<code>Java</code> 使用起来非常方便，然而有些层次的任务用 <code>Java</code> 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。<ul>
<li><strong>有时 <code>Java</code> 应用需要与 <code>Java</code> 外面环境交互，这是本地方法存在的主要原因</strong>，本地方法为我们提供了一个非常简洁的接口，而且我们无需去了解 <code>Java</code> 应用之外的繁琐细节</li>
<li><code>JVM</code> 支持着 <code>Java</code> 语言本身的运行时库，它是 <code>Java</code> 程序赖以生存的平台，它由一个解释器和一些连接到本地代码的库组成。然而不管怎样，它不经不是一个完整的系统，他经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用 <code>Java</code> 实现了 <code>JRE</code> 的底层系统的交互，甚至 <code>JVM</code> 的一部分就是用 <code>C</code> 写的</strong>。还有，如果我们要使用一些 <code>Java</code> 语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</li>
<li><strong><code>Sun</code> 的解释器是用 <code>C</code> 实现的，这使得它能像一些普通的 <code>C</code> 一样与外部交互</strong>。<code>JRE</code> 大部分是用 <code>Java</code> 实现的，它也通过一些本地方法与外界交互。例如：类 <code>Java.lang.Thread</code> 的 <code>setPriority()</code> 方法使用 <code>Java</code> 实现，但是它实现调用的是该类里的本地方法 <code>setPriority0()</code>。这个本地方法是用 <code>C</code> 实现的，并被植入 <code>JVM</code> 内部，在 <code>Windows95</code> 的平台上，这个本地方法最终将调用 <code>Win32 SetPriority() API</code>。这是一个本地方法的具体实现由 <code>JVM</code> 直接提供，更多的情况是本地方法由外部的动态链接库 <code>(External Dynamic Link Library)</code> 提供，然后被 <code>JVM</code> 调用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>现状：<strong>目前该方法的使用越来越少了，除非是与硬件有关的应用</strong>，比如通过 <code>Java</code> 程序驱动打印机或者 <code>Java</code> 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 <code>Socket</code> 通信，也可以使用 <code>Web Service</code> 等等</li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="五、对象的实例化、内存布局、访问定位"><a href="#五、对象的实例化、内存布局、访问定位" class="headerlink" title="五、对象的实例化、内存布局、访问定位"></a>五、对象的实例化、内存布局、访问定位</h2><h3 id="5-1、对象的实例化"><a href="#5-1、对象的实例化" class="headerlink" title="5.1、对象的实例化"></a>5.1、对象的实例化</h3><h4 id="5-1-1、创建对象的方式"><a href="#5-1-1、创建对象的方式" class="headerlink" title="5.1.1、创建对象的方式"></a>5.1.1、创建对象的方式</h4><blockquote>
<ul>
<li><code>new</code>：最常见的方式<ul>
<li><code>Xxx</code> 的静态方法</li>
<li><code>XxxBuilder/XxxFactory</code> 的静态方法</li>
</ul>
</li>
<li><code>Class</code> 的 <code>newInstance()</code>：反射的方式，只能调用空参的构造器，权限必须是 <code>public</code></li>
<li><code>Constructor</code> 的 <code>newInstance(Xxx)</code>：反射的方式，可以调用空参、带参的构造器，权限没有要求</li>
<li>使用 <code>clone()</code>：不调用任何构造器，当前类需要实现 <code>Cloneable</code> 接口，实现 <code>clone()</code></li>
<li>使用反序列化：从文件、网络中获取一个对象的二进制流</li>
<li>第三方库 <code>Objenesis</code></li>
</ul>
</blockquote>
<h4 id="5-1-2、创建对象的步骤"><a href="#5-1-2、创建对象的步骤" class="headerlink" title="5.1.2、创建对象的步骤"></a>5.1.2、创建对象的步骤</h4><blockquote>
<ul>
<li>判断对象对应的类是否加载、链接、初始化 <strong>[ 虚拟机遇到一条 <code>new</code> 指令，首先去检查这个指令的参数能否在 <code>Metaspace</code> 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派机制下，使用当前类加载器以 <code>ClassLoader + 包名 + 类名</code> 为关键字进行查找对应的 <code>class</code> 文件，如果没有找到文件，则抛出 <code>ClassNotFoundException</code> 异常，如果找到则进行类加载，并生成对应的 <code>Class</code> 对象 ]</strong></li>
<li>为对象分配内存 <strong>[ 首先计算对象占用空间大小，接着在堆中划分一块内存分配给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 <code>4</code> 个字节大小 ]</strong><ul>
<li>如果内存规整：<ul>
<li>指针碰撞 <strong>[ 如果内存是规整的，那么虚拟机将采用指针碰撞算法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另一边，中间存放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空间那边挪动一段与对象大小相等的距离罢了，如果垃圾收集器选择的是 <code>Serial</code>、<code>PerNew</code> 这种基于压缩算法的，虚拟机采用这种分配方式，一般使用带有 <code>Compact</code> 过程的收集器时，使用指针碰撞 ]</strong></li>
</ul>
</li>
<li>如果内存不规整：<ul>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配 <strong>[ 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存，意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容，这种分配方式称为 “空闲列表” ]</strong></li>
</ul>
</li>
</ul>
</li>
<li>处理并发安全问题：<ul>
<li>采用 <code>CAS</code> 失败重试、区域加锁保证更新的原子性</li>
<li>每个线程预先分配一块 <code>TLAB</code> （通过 <code>-XX:+/-UseTLAB</code> 参数来设定）</li>
</ul>
</li>
<li>初始化分配到的空间：所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</li>
<li>设置对象的对象头 <strong>[ 将对象的所属类（即类的元数据信息）、对象的 <code>HashCode</code> 和对象的 <code>GC</code> 信息、锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于 <code>JVM</code> 的实现 ]</strong></li>
<li>执行 <code>init</code> 方法进行初始化 <strong>[ 在 <code>Java</code> 程序的视角来看，初始化才正式开始，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋给引用变量。因此一般来说（由字节码中是否跟随有 <code>invokespecial</code> 指令所决定），<code>new</code> 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来 ]</strong></li>
</ul>
</blockquote>
<h3 id="5-2、内存布局"><a href="#5-2、内存布局" class="headerlink" title="5.2、内存布局"></a>5.2、内存布局</h3><h4 id="5-2-1、对象头-Header"><a href="#5-2-1、对象头-Header" class="headerlink" title="5.2.1、对象头 Header"></a>5.2.1、对象头 Header</h4><blockquote>
<ul>
<li>包含：<ul>
<li>运行时元数据<ul>
<li>哈希值</li>
<li><code>GC</code> 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程 <code>ID</code> </li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针：指向类元数据 <code>InstanceKlass</code>，确定该对象所属的类型</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>说明：如果是数组，还有记录数组的长度</li>
</ul>
</blockquote>
<h4 id="5-2-2、实例数据-Instance-Data"><a href="#5-2-2、实例数据-Instance-Data" class="headerlink" title="5.2.2、实例数据 Instance Data"></a>5.2.2、实例数据 Instance Data</h4><blockquote>
<ul>
<li>规则<ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果 <code>CompactFields</code> 参数为 <code>true</code> **(默认为 <code>true</code>)**：子类的窄变量可能插入到父类变量的空隙</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>说明：它是对象真正存储的有效信息， 包括程序代码中顶一个各种类型的字段（包括从父类继承下来的和本身拥有的字段）</li>
</ul>
</blockquote>
<h4 id="5-2-3、对其填充-Padding"><a href="#5-2-3、对其填充-Padding" class="headerlink" title="5.2.3、对其填充 Padding"></a>5.2.3、对其填充 Padding</h4><blockquote>
<p>不是必须的，也没有特别含义，仅仅起到占位符的作用</p>
</blockquote>
<h4 id="5-2-4、图示"><a href="#5-2-4、图示" class="headerlink" title="5.2.4、图示"></a>5.2.4、图示</h4><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE%E7%A4%BA.png" alt="内存布局图示"></p>
<h3 id="5-3、对象访问定位"><a href="#5-3、对象访问定位" class="headerlink" title="5.3、对象访问定位"></a>5.3、对象访问定位</h3><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E5%9B%BE%E7%A4%BA.png" alt="对象访问定位图示"></p>
<ul>
<li><p>创建对象的目的是为了使用它</p>
</li>
<li><p><code>JVM</code> 通过定位，即栈上 <code>reference</code> 访问来访问到其内部的对象实例</p>
</li>
<li><p>对象访问的两种主要方式</p>
<ul>
<li><p>句柄访问</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="句柄访问"></p>
</li>
<li><p>直接指针</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="直接指针"></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="六、直接内存"><a href="#六、直接内存" class="headerlink" title="六、直接内存"></a>六、直接内存</h2><blockquote>
<ul>
<li>不是虚拟机运行时数据区的一部分，也不是《<code>Java</code> 虚拟机规范》中定义的内存区域</li>
<li>直接内存是在 <code>Java</code> 堆外的、直接向系统申请的内存区间</li>
<li>来源于 <code>NIO</code>，通过存在堆中的 <code>DirectByteBuffer</code> 操作 <code>Native</code> 内存</li>
<li>通常，访问直接内存的速度会优于 <code>Java</code> 堆，即读写性能高<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li><code>Java</code> 的 <code>NIO</code> 库允许 <code>Java</code> 程序使用直接内存，用于数据缓冲区</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-1、非直接缓冲区"><a href="#6-1、非直接缓冲区" class="headerlink" title="6.1、非直接缓冲区"></a>6.1、非直接缓冲区</h3><blockquote>
<ul>
<li>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如图所示，使用 <code>I/O</code>，需要两份内存存储重复数据，效率低</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="非直接缓冲区"></p>
</blockquote>
<h3 id="6-2、直接缓冲区"><a href="#6-2、直接缓冲区" class="headerlink" title="6.2、直接缓冲区"></a>6.2、直接缓冲区</h3><blockquote>
<ul>
<li>使用 <code>NIO</code> 时，如图，操作系统划出的直接缓存区可以被 <code>Java</code> 代码直接访问，只有一份。<code>NIO</code> 适合对大文件的读写操作</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="直接缓冲区"></p>
</blockquote>
<h3 id="6-3、直接内存概述"><a href="#6-3、直接内存概述" class="headerlink" title="6.3、直接内存概述"></a>6.3、直接内存概述</h3><blockquote>
<ul>
<li>也可能导致 <code>OutOfMemoryError</code> 异常</li>
<li>优于直接内存在 <code>Java</code> 堆外，因此它的大小不会直接受限于 <code>-Xmx</code> 指定的最大堆大小，但是系统内存是优先的，<code>Java</code> 堆和直接内存的总和依然受限于操作系统能给出的最大内存</li>
<li>缺点<ul>
<li>分配回收成本高</li>
<li>不受 <code>JVM</code> 内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过 <code>MaxDirectMemorySize</code> 来设置</li>
<li>如果不指定，默认与堆的最大值 <code>-Xmx</code> 参数保持一致</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%847VS8.png" alt="JVM内存结构7VS8"></p>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="七、执行引擎"><a href="#七、执行引擎" class="headerlink" title="七、执行引擎"></a>七、执行引擎</h2><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.png" alt="执行引擎"></p>
<h3 id="7-1、执行引擎概述"><a href="#7-1、执行引擎概述" class="headerlink" title="7.1、执行引擎概述"></a>7.1、执行引擎概述</h3><blockquote>
<ul>
<li><code>JVM</code> 的主要任务是负责 <strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能够被 <code>JVM</code> 所识别的字节码指令、符号表，以及其他辅助信息</li>
<li>那么，如果想要让一个 <code>Java</code> 程序运行起来，执行引擎的任务就是 <strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>，简单来说，<code>JVM</code> 中的执行引擎充当了将高级语言翻译为机器语言的译者</li>
</ul>
</blockquote>
<h4 id="7-1-2、执行引擎工作过程"><a href="#7-1-2、执行引擎工作过程" class="headerlink" title="7.1.2、执行引擎工作过程"></a>7.1.2、执行引擎工作过程</h4><blockquote>
<ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 <code>PC</code> 寄存器</li>
<li>每当执行完一项指令后，<code>PC</code> 寄存器就会更新下一条需要被执行的指令地址</li>
<li>当然，方法在执行过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 <code>Java</code> 堆区中的对象实例信息以及通过对象头中的元数据指针定位到目标对象的类型信息</li>
<li>从外观上来看，所有的 <code>Java</code> 虚拟机的执行引擎输入、输出都是一致的，输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="执行引擎工作过程"></p>
</blockquote>
<h3 id="7-2、Java-代码编译和执行的过程"><a href="#7-2、Java-代码编译和执行的过程" class="headerlink" title="7.2、Java 代码编译和执行的过程"></a>7.2、Java 代码编译和执行的过程</h3><blockquote>
<ul>
<li>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤<ul>
<li>绿色：解释的过程</li>
<li>蓝色：编译的过程</li>
</ul>
</li>
</ul>
<p>![Java 代码编译和执行的过程](<a target="_blank" rel="noopener" href="https://gitee.com/CyingK/files/raw/master/images/JVM/Java">https://gitee.com/CyingK/files/raw/master/images/JVM/Java</a> 代码编译和执行的过程.png)</p>
<ul>
<li><code>Javac</code> 前端编译器过程</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/Java%E6%BA%90%E7%A0%81%E7%BA%A7%E7%BC%96%E8%AF%91%E5%99%A8.png" alt="Java源码级编译器"></p>
<ul>
<li>后端编译器过程</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="执行引擎流程图"></p>
<hr>
<ul>
<li>解释器：当 <code>Java</code> 虚拟机启动时会根据预定的规范 <strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行</li>
<li><code>JIT(Just In Time Compiler)</code> 编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li>
</ul>
<hr>
<ul>
<li>为什么说 <code>Java</code> 是半编译半解释型语言<ul>
<li><code>JDK1.0</code> 时代，将 <code>Java</code> 语言定位为 “解释执行” 还是比较准确的。再后来 <code>Java</code> 也发展出可以直接生成本地代码的编译器</li>
<li>现在 <code>JVM</code> 在执行 <code>Java</code> 代码的时候，通常都会将解释执行与编译执行二者结合起来进行</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-3、机器码、指令、汇编语言"><a href="#7-3、机器码、指令、汇编语言" class="headerlink" title="7.3、机器码、指令、汇编语言"></a>7.3、机器码、指令、汇编语言</h3><p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%81%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4.png" alt="高级语言、汇编语言、机器指令"></p>
<h4 id="7-3-1、机器码"><a href="#7-3-1、机器码" class="headerlink" title="7.3.1、机器码"></a>7.3.1、机器码</h4><blockquote>
<ul>
<li>各种用二进制彪马方式表示的指令，叫做机器指令码。开始，人们就采用它编写程序，这就是机器语言</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错</li>
<li>用它编写的程序一经输入计算机，<code>CPU</code> 直接读取运行，因此和其他语言编的程序相比，执行速度最快</li>
<li>机器指令与 <code>CPU</code> 紧密相关，所以不同种类的 <code>CPU</code> 所对应的机器指令也就不同</li>
</ul>
</blockquote>
<h4 id="7-3-2、指令"><a href="#7-3-2、指令" class="headerlink" title="7.3.2、指令"></a>7.3.2、指令</h4><blockquote>
<ul>
<li>由于机器码是由 <code>0</code> 和 <code>1</code> 组成的二进制序列，可读性实在太差，于是人们发明了指令</li>
<li>指令就是把机器码中特定的 <code>0</code> 和 <code>1</code> 序列简化成对应的指令（一般为英文简写，如 <code>MOV</code>、<code>INC</code>），可读性稍好</li>
<li>由于不同的硬件平台执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令，对应的机器码也可能不同</li>
</ul>
</blockquote>
<h4 id="7-3-3、指令集"><a href="#7-3-3、指令集" class="headerlink" title="7.3.3、指令集"></a>7.3.3、指令集</h4><blockquote>
<ul>
<li>不同的硬件平台，各自支持的指令是有差别的，因此每个平台所支持的指令，称之为对应平台的指令集</li>
</ul>
</blockquote>
<h4 id="7-3-4、汇编语言"><a href="#7-3-4、汇编语言" class="headerlink" title="7.3.4、汇编语言"></a>7.3.4、汇编语言</h4><blockquote>
<ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言</li>
<li>在汇编语言中，用 <strong>助记符 <code>(Mnemonics)</code></strong> 代替 <strong>机器指令的操作码</strong>，用 <strong>地址符号 <code>(Symbol)</code> 或标号 <code>(Label)</code></strong> 代替 <strong>指令或操作数的地址</strong></li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令，由于计算机只认识指令码，所以用 <strong>汇编语言编写的程序还需翻译成机器指令码，</strong> 计算机才能识别和执行</li>
</ul>
</blockquote>
<h4 id="7-3-5、高级语言"><a href="#7-3-5、高级语言" class="headerlink" title="7.3.5、高级语言"></a>7.3.5、高级语言</h4><blockquote>
<ul>
<li>为了使编程更加容易，就出现了各种高级计算机语言，高级语言比起机器指令、汇编语言 <strong>更接近人的语言</strong></li>
<li>当计算机执行高级语言编写的程序时，<strong>仍需把程序解释和编译成机器的指令码</strong>。完成这个过程的程序就叫做解释程序或编译程序</li>
</ul>
</blockquote>
<h4 id="7-3-6、字节码"><a href="#7-3-6、字节码" class="headerlink" title="7.3.6、字节码"></a>7.3.6、字节码</h4><blockquote>
<ul>
<li>字节码是一种中间状态的二进制代码，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要是为了实现特定软件运行和软件环境，<strong>与硬件环境无关</strong></li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令</li>
<li>字节码的典型应用为 <code>Java Bytecode</code></li>
</ul>
</blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.png" alt="理解执行引擎"> </p>
<h3 id="7-4、解释器"><a href="#7-4、解释器" class="headerlink" title="7.4、解释器"></a>7.4、解释器</h3><blockquote>
<ul>
<li><code>JVM</code> 设计者们的初中仅仅是单纯地 <strong>为了满足 <code>Java</code> 程序实现快平台特性</strong>，因此避免采用静态编译地方式直接生成机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序地想法</li>
<li>解释器真正意义上所担任的角色就是一个运行时的翻译者，将字节码文件中的内容翻译为对应平台的本地机器指令执行</li>
<li>当一条字节码指令被解释执行完成后，接着再根据 <code>PC</code> 寄存器中记录的下一条需要被执行的字节码指令执行解释操作</li>
</ul>
</blockquote>
<h4 id="7-4-1、解释器的分类"><a href="#7-4-1、解释器的分类" class="headerlink" title="7.4.1、解释器的分类"></a>7.4.1、解释器的分类</h4><blockquote>
<p>在 <code>Java</code> 的发展历史中，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的 <strong>模板解释器</strong></p>
<ul>
<li>字节码解释器在执行时通过 <strong>纯软件代码</strong> 模拟字节码的执行，效率非常地下</li>
<li>而面板解释器将 <strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能<ul>
<li>在 <code>HotSpot</code> 中，解释器主要由 <code>Interpreter</code> 模块和 <code>Code</code> 模块构成<ul>
<li><code>Interpreter</code> 模块：实现了解释器的核心公共</li>
<li><code>Code</code> 模块：用于管理 <code>HotSpot</code> 在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
<li>由于解释器在设计和是线上非常简单，因此除了 <code>Java</code> 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 <code>Python</code>、<code>Perl</code>、<code>Ruby</code> 等，但今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些 <code>C/C++</code> 程序员所调侃</li>
<li>为了解决这个问题，<code>JVM</code> 平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是将 <strong>整个函数体编译为机器码，每函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升</li>
<li>不过无论无何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献</li>
</ul>
</blockquote>
<h3 id="7-5、JIT-编译器"><a href="#7-5、JIT-编译器" class="headerlink" title="7.5、JIT 编译器"></a>7.5、JIT 编译器</h3><blockquote>
<ul>
<li><code>HotSpot</code> 虚拟机是目前市面上高性能虚拟机的代表作之一。<strong>采用解释器与即时编译器并存的架构</strong>。在 <code>Java</code> 虚拟机运行时，解释器和即时编译器能够互相协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间</li>
</ul>
<hr>
<ul>
<li>既然 <code>HotSpot</code> 虚拟机已经内置了 <code>JIT</code> 编译器，为什么还需要使用解释器来 <strong>“拖累”</strong> 程序的执行型嫩<ul>
<li>首先明确：解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率很高</li>
<li>所以：尽管 <code>JRocket</code> 虚拟机程序的执行性能非常高效，但程序在启动时必然需要花费更长的时间来进行编译，对于服务端应用来说，启动时间并非是关注重点，但对于哪些看重启动时间的应用场景而言，或许需要采用编译器与即时编译去共存的架构来换取一个平衡点。在此模式下，<strong>当 <code>Java</code> 虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率</strong></li>
<li>同时，解释执行再编译器进行激进优化不成立的时候，作为编译器的 “逃生门”</li>
<li>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以 <strong>省去许多不必要的编译时间</strong>，并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<strong>将有价值的字节码编译为本地机器指令</strong>，以换取更高的程序执行效率</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>概念解释：<ul>
<li><code>Java</code> 语言的 “编译期” 其实是一段 “不确定” 的操作过程，因为它可能是指一个编译器的前端把 <code>.java</code> 文件转换为 <code>.class</code> 文件的过程</li>
<li>也可能是只虚拟机的后端运行期编译器 <code>(JIT, Just In Time)</code>，把字节码转变为机器码的过程</li>
<li>还可能是指使用静态提前编译器 <code>(AOT, Ahead Of Time)</code>，直接把 <code>.java</code> 文件编译成本地机器码的过程</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="7-5-1、Java-代码的执行分类"><a href="#7-5-1、Java-代码的执行分类" class="headerlink" title="7.5.1、Java 代码的执行分类"></a>7.5.1、Java 代码的执行分类</h4><blockquote>
<ul>
<li>将源代码编译成字节码文件，然后再运行时通过解释器将字节码文件转为机器码执行</li>
<li>编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率会使用即时编译技术，将方法编译成机器码后再执行</li>
</ul>
</blockquote>
<h4 id="7-5-2、热点代码和探测"><a href="#7-5-2、热点代码和探测" class="headerlink" title="7.5.2、热点代码和探测"></a>7.5.2、热点代码和探测</h4><blockquote>
<ul>
<li>是否需要启动 <code>JIT</code> 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据 <strong>代码被调用的频率</strong> 来顶。关于那些需要被编译为本地代码的字节码，也被称之为 <strong>热点代码</strong>，<code>JIT</code> 编译器在运行时会针对那些频繁被调用的 “热点代码” 做出 <strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升 <code>Java</code> 程序的执行性能</li>
</ul>
<hr>
<ul>
<li><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为 “热点代码”，因此都可以通过 <code>JIT</code> 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为 <code>OSR(On Stack Replacement)</code></p>
</li>
<li><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以到达这个标准，必须明确一个阈值，<code>JIT</code> 编译器才会将这些 “热点代码” 编译为本地机器指令执行。这里主要依靠 <strong>热点探测功能</strong></p>
</li>
<li><p><strong>目前 <code>HotSpot</code> 虚拟机所采用的热点探测方式是基于计数器的热点探测</strong></p>
</li>
<li><p>采用基于计数器的热点探测，<code>HotSpot</code> 虚拟机将会为每一个方法都建立 <code>2</code> 个不同类型的计数器，分别为方法调用计数器 <code>(Invocation Counter)</code> 和回边计数器 <code>(Back Edge Counter)</code></p>
<ul>
<li><p>方法调用计数器用于统计方法的调用次数</p>
<ul>
<li>这个计数器就用于统计方法被调用的次数，默认阈值在 <code>Client</code> 模式下是 <code>1500</code> 次，在 <code>Server</code> 模式下是 <code>10000</code> 次。超过这个阈值，就会触发 <code>JIT</code> 编译</li>
<li>这个阈值可以通过 <code>-XX:CompileThreshold</code> 来设置</li>
<li>当一个方法被调用时，会先检查该方法是否存在被 <code>JIT</code> 编译过的版本，如果存在则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 <code>1</code>，然后判断 <strong>方法调用计数器与回边计数器之和</strong> 是否超过方法调用计数器的阈值。如果已经超过，那么将会向即时编译器提交一个该方法的代码编译请求</li>
<li>热度衰减：<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即 <strong>一段时间之内方法被调用的次数</strong>。当超过 <strong>一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被 <strong>减少一半</strong>，这个过程称为方法调用计数器的热度衰减 <code>(Counter Decay)</code>，而这段时间就称为此方法的半衰周期 <code>(Counter Half Life Time)</code></li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分的代码都会被编译成本地代码</li>
<li>另外，可以使用 <code>-XX:CounterHalfLifeTime</code> 参数设置半衰周期的时间，单位是秒</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="方法调用计数器"></p>
</li>
<li><p>回边计数器则用于统计循环体执行的循环次数</p>
<ul>
<li><p>统计一个方法中 <strong>循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为 “回边”，显然建立回边的目的就是为了触发 <code>OSR</code> 编译</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="回边计数器"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="7-5-3、模式设置"><a href="#7-5-3、模式设置" class="headerlink" title="7.5.3、模式设置"></a>7.5.3、模式设置</h4><blockquote>
<ul>
<li>缺省情况下 <code>HotSpot</code> 虚拟机采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 <code>Java</code> 虚拟机指定在运行时到底是 <strong>完全采用解释器</strong> 执行，还是 <strong>完全采用即时编译器</strong> 执行<ul>
<li><code>-Xint</code>：完全采用解释器模式</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式，如果即时编译出现问题，解释器会介入执行</li>
<li><code>-Xmixed</code>：采用 <strong>解释器 + 即时编译器</strong> 地混合模式共同执行程序</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>JIT</code> 分类<ul>
<li>在 <code>HotSpot</code> 虚拟机中内嵌了两个 <code>JIT</code> 编译器，分别为 <code>Client Compiler</code> 和 <code>Server Compiler</code>，但大多数情况下我们简称为 <code>C1</code> 编译器、<code>C2</code> 编译器<ul>
<li><code>-client</code>：指定 <code>Java</code> 虚拟机运行在 <code>Client</code> 模式下，并使用 <code>C1</code> 编译器。<code>C1</code> 编译器回对字节码进行 <strong>简单和可靠的优化，耗时短</strong>。以达到更快的编译速度</li>
<li><code>-server</code>：指定 <code>Java</code> 虚拟机运行在 <code>Server</code> 模式下，并使用 <code>C2</code> 编译器。<code>C2</code> 编译器进行 <strong>耗时较长，以及激进优化</strong>。但优化的代码执行效率更高</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>C1</code> 和 <code>C2</code> 编译器不同的优化策略：<ul>
<li><code>C1</code> <ul>
<li><strong>方法内联</strong>：将引用的函数代码编译到引用点处，可减少栈帧的生成，减少参数传递以及跳转过程</li>
<li><strong>去虚拟化</strong>：对唯一的实现类进行内联</li>
<li><strong>冗余消除</strong>：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li><code>C2</code> 的优化主要是在全局层面，逃逸分析是优化的基础，基于逃逸分析在 <code>C2</code> 上有如下几种优化<ul>
<li><strong>标量替换</strong>：用标量值代替聚合对象的属性值</li>
<li><strong>栈上分配</strong>：对于未逃逸的对象分配对象在栈而不是堆</li>
<li><strong>同步消除</strong>：清除同步操作，通常指 <code>Synchronized</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-6、其他编译器"><a href="#7-6、其他编译器" class="headerlink" title="7.6、其他编译器"></a>7.6、其他编译器</h3><blockquote>
<ul>
<li><code>Graal</code>：<code>JDK10</code> 引入，编译效果短短几年就追平了 <code>C2</code> 编译器，目前还处于实验阶段，用以下两条指令进行激活才可使用<ul>
<li><code>-XX:UnlockExperimentalVMOptions</code></li>
<li><code>-XX:UseJVMCICompiler</code></li>
</ul>
</li>
<li><code>AOT(Ahead Of Time)</code>：<code>JDK9</code> 引入了实验性 <code>AOT</code> 编译工具 <code>jaotc</code>。它借助了 <code>Graal</code> 编译器，将所输入的 <code>Java</code> 类文件转换为机器码，并存放至生成的动态共享库之中，是与即时编译相对立的一个概念。<ul>
<li>我们知道即时编译指的是在 <strong>程序运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署到托管环境中的过程。而 <code>AOT</code> 编译指的是在 <strong>程序运行之前</strong>，便将字节码转换为机器码的过程</li>
<li>好处：<ul>
<li><code>Java</code> 虚拟机加载已经预编译的二进制库，可以直接执行。不必等待即时编译器的预热，减少 <code>Java</code> 应用给人带来 “第一次运行慢” 的不良体验</li>
</ul>
</li>
<li>缺点：<ul>
<li>破坏了 <code>Java</code> “一次编译，处处运行”，必须为每个不同硬件、<code>OS</code> 编译对应的发行包</li>
<li>降低了 <code>Java</code> 链接过程的动态性，加载的代码在编译期就必须全部已知</li>
<li>还需要继续优化中，最初只支持 <code>Linux x64 Java Base</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="八、String-Table"><a href="#八、String-Table" class="headerlink" title="八、String Table"></a>八、String Table</h2><h3 id="8-1、String-的基本特性"><a href="#8-1、String-的基本特性" class="headerlink" title="8.1、String 的基本特性"></a>8.1、String 的基本特性</h3><blockquote>
<ul>
<li><p><code>String</code> 使用一对 “” 来表示</p>
</li>
<li><p><code>String</code> 声明为 <code>final</code>，不可被继承</p>
</li>
<li><p><code>String</code> 实现了 <code>Serializable</code> 接口（表示字符串是支持序列化的），实现了 <code>Comparable</code> 接口（表示字符串是可以比较大小的）</p>
</li>
<li><p><code>String</code> 在 <code>JDK8</code> 及以前内部定义了 <code>private final char[] value;</code>，用于存储字符串数据，<code>JDK9</code> 时改为 <code>private final byte[] value;</code></p>
<ul>
<li>修改的动机：<ul>
<li><code>String</code> 类的当前（<code>JDK8</code>）实现将字符存储在 <code>char</code> 数组中，每个字符使用两个字节（16位）。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含 <code>Latin-1</code> 字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部 <code>char</code> 数组中有一半的空间将不会使用。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>修改的描述：<ul>
<li>我们建议将字符串类的内部表示形式从 <code>UTF-16</code> 字符数组改为字节数组加上编码标记字段。新的 <code>String</code> 类将根据字符串的内容存储编码为 <code>ISO-8859-1/Latin-1</code> （每个字符一个字节）或 <code>UTF-16</code> （每个字符两个字节）的字符。编码标志将指示使用哪种编码。</li>
<li>与字符串相关的类，如 <code>AbstractStringBuilder</code>、<code>StringBuilder</code> 和 <code>StringBuffer</code>，将被更新以使用相同的表示，<code>HotSpot VM</code> 的固有字符串操作也将如此。</li>
<li>这纯粹是实现更改，对现有的公共接口没有更改。目前还没有添加任何新的公共 <code>api</code> 或其他接口的计划。</li>
<li>到目前为止所做的原型工作证实了预期的内存占用减少、<code>GC</code> 活动的大量减少以及在某些极端情况下的少量性能退化。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>String</code> 代表不可变的字符序列，简称 <strong>不可变性</strong></p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 <code>value</code> 进行赋值</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 <code>value</code> 进行赋值</li>
<li>当调用 <code>String</code> 的 <code>replace()</code> 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 <code>value</code> 进行赋值</li>
</ul>
</li>
<li><p>通过字面量的方式给一个字符串赋值，此时的字符串值生命在字符串常量池中</p>
</li>
<li><p>字符串常量池中是不会存储相同内容的字符串的</p>
<ul>
<li><code>String</code> 的 <code>String Pool</code> 是一个固定大小的 <code>HashTable</code>，默认值长度是 <code>1009</code>。如果放进 <code>String Pool</code> 的 <code>String</code> 非常多，就会造成 <code>Hash</code> 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 <code>String.intern()</code> 时性能会大幅下降</li>
<li>使用 <code>-XX:StringTableSize</code> 可设置 <code>StringTable</code> 的长度</li>
<li>在 <code>JDK6</code> 中 <code>StringTable</code> 是固定的，就是 <code>1009</code> 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。<code>StringTableSize</code> 设置没有要求</li>
<li>在 <code>JDK7</code> 中，<code>StringTable</code> 的长度默认值是 <code>60013</code>，</li>
<li>在 <code>JDK8</code> 中，<code>1009</code> 是可设置的最小值</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-2、String-的内存分配"><a href="#8-2、String-的内存分配" class="headerlink" title="8.2、String 的内存分配"></a>8.2、String 的内存分配</h3><blockquote>
<ul>
<li>在 <code>Java</code> 语言中有 8 种基本数据类型和一种比较特殊的类型 <code>String</code>。这些类型为了使他们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念</li>
<li>常量池就类似一个 <code>Java</code> 系统级别提供的缓存，<code>8</code> 种基本数据类型的常量池都是系统协调的，**<code>String</code> 的常量池比较特殊。它的主要使用方法有两种**<ul>
<li>直接使用双引号声明出来的 <code>String</code> 对象会直接存储在常量池中</li>
<li>如果不是用双引号声明的 <code>String</code> 对象，可以是使用 <code>String</code> 提供的 <code>intern()</code> 方法</li>
</ul>
</li>
<li><code>JDK7</code> 以前，字符串常量池存放在永久代</li>
<li><code>JDK7</code> 时，<code>Oracle</code> 的工程师对字符串池的逻辑做了很大的改变，即：<strong>将字符串常量池的位置调整到 <code>Java</code> 堆中</strong><ul>
<li>所有的字符串都保存在堆中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了</li>
<li>字符串常量池概念原本使用的比较多，但这个改动使得我们有足够的理由让我们重新考虑 在 <code>Java 7</code> 中使用 <code>Sting.intern()</code></li>
</ul>
</li>
<li><code>JDK7</code> 以后，元空间取代永久代，字符串常量池仍放在堆中</li>
</ul>
<hr>
<ul>
<li><code>StringTable</code> 为什么要调整<ul>
<li><code>PermSize</code> 默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-3、字符串拼接操作"><a href="#8-3、字符串拼接操作" class="headerlink" title="8.3、字符串拼接操作"></a>8.3、字符串拼接操作</h3><blockquote>
<ul>
<li><p>常量与常量的拼接结果在常量池，原理是编译期优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量池中不会存在相同内容的变量</p>
</li>
<li><p>只要其中有一个是变量，结果就在堆中。变量拼接的原理是 <code>StringBuilder</code></p>
<ul>
<li><code>String s1 = &quot;a&quot;; String s2 = &quot;b&quot;; s1 + s2</code> 的过程：<ol>
<li><code>StringBuilder s = new StringBuilder();</code></li>
<li><code>s.append(&quot;a&quot;);</code></li>
<li><code>s.append(&quot;b&quot;);</code></li>
<li><code>s.toString();</code> 约等于 <code>new String(&quot;ab&quot;);</code></li>
</ol>
</li>
<li>字符串拼接操作不一定是 <code>StringBuilder</code>，<strong>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化</strong></li>
<li>针对于 <code>final</code> 修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上 <code>final</code> 的时候建议使用上</li>
</ul>
</li>
<li><p>如果拼接的结果调用 <code>intern()</code> 方法，则主动将常量池中还没有字符串对象放入池中，并返回此对象地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String javaEE = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String hadoop = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s3 = javaEE + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;javaEE&quot;</span> + hadoop;</span><br><span class="line">    String s5 = javaEE + hadoop;</span><br><span class="line">    String s6 = s5.intern();</span><br><span class="line">    </span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1 == s4); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1 == s5); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1 == s6); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s4 == s5); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="8-4、intern-的使用"><a href="#8-4、intern-的使用" class="headerlink" title="8.4、intern() 的使用"></a>8.4、intern() 的使用</h3><blockquote>
<ul>
<li>如果不是用双引号声明的 <code>String</code> 对象，可以使用 <code>String</code> 提供的 <code>intern</code> 方法。<code>intern</code> 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
<li>也就是说，如果在任意字符串上调用 <code>String.intern</code> 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 <code>true</code><ul>
<li><code>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;</code></li>
</ul>
</li>
<li>通俗来说，<code>Interned String</code> 就是确保字符串在内存里只有一份数据，这样也可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池 <code>String Intern Pool</code></li>
</ul>
<hr>
<ul>
<li><code>JDK 1.7</code> 之前：<ul>
<li>如果字符串常量池中有，则并不会放入，返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，会把 <strong>此对象复制一份</strong>，放入字符串常量池并返回字符串常量池中的对象地址</li>
</ul>
</li>
<li><code>JDK 1.7</code> 及之后：<ul>
<li>如果字符串常量池中有，则并不会放入，返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，则会把 <strong>对象的引用地址复制一份</strong>，放入字符串常量池，并返回字符串常量池中的引用地址</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="8-4-1、new-String-“ab”-会创建几个对象"><a href="#8-4-1、new-String-“ab”-会创建几个对象" class="headerlink" title="8.4.1、new String(“ab”) 会创建几个对象"></a>8.4.1、new String(“ab”) 会创建几个对象</h4><blockquote>
<ul>
<li><p>对象 ① <code>Line 0</code>：<code>String</code> 对象</p>
</li>
<li><p>对象 ② <code>Line 3</code>：字符串常量池 <code>&quot;ab&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 new 				#2 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 ldc 				#3 &lt;ab&gt;</span><br><span class="line">6 invokespecial 	#4 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="8-4-2、new-String-“a”-new-String-“b”-会创建几个对象"><a href="#8-4-2、new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="8.4.2、new String(“a”) + new String(“b”) 会创建几个对象"></a>8.4.2、new String(“a”) + new String(“b”) 会创建几个对象</h4><blockquote>
<ul>
<li><p>对象 ① <code>Line 0</code>：<code>StringBuilder</code> 对象</p>
</li>
<li><p>对象 ② <code>Line 7</code>：<code>String</code> 对象</p>
</li>
<li><p>对象 ③ <code>Line 11</code>：字符串常量池 <code>&quot;a&quot;</code></p>
</li>
<li><p>对象 ④ <code>Line 19</code>：<code>String</code> 对象</p>
</li>
<li><p>对象 ⑤ <code>Line 23</code>：字符串常量池 <code>&quot;b&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 0 new 			   #2 &lt;java&#x2F;lang&#x2F;StringBuilder&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial   #3 &lt;java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"> 7 new 			   #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc 			   #5 &lt;a&gt;</span><br><span class="line">13 invokespecial   #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual   #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">19 new 			   #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc 			   #8 &lt;b&gt;</span><br><span class="line">25 invokespecial   #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual   #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual   #9 &lt;java&#x2F;lang&#x2F;StringBuilder.toString&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象 ⑥ <code>Line 0</code>：<code>String</code> 对象 <strong>// 此对象直接放在堆空间，并未放入字符串常量池</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0 new 				#80 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 aload_0</span><br><span class="line"> 5 getfield 		#234 &lt;java&#x2F;lang&#x2F;StringBuilder.value&gt;</span><br><span class="line"> 8 iconst_0</span><br><span class="line"> 9 aload_0</span><br><span class="line">10 getfield 		#233 &lt;java&#x2F;lang&#x2F;StringBuilder.count&gt;</span><br><span class="line">13 invokespecial 	#291 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">16 areturn</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="8-4-3、重点面试题"><a href="#8-4-3、重点面试题" class="headerlink" title="8.4.3、重点面试题"></a>8.4.3、重点面试题</h4><blockquote>
<ul>
<li><pre><code class="java">public void test() &#123;

    /*
    ** - 字符串常量池生成字符串 &quot;1&quot;
    ** - 并创建 String 对象
    ** 两者地址并不相同
    */
    String s1 = new String(&quot;1&quot;); 

    /*
    ** 在这之前，字符串已有 &quot;1&quot;
    ** 故不再做操作
    */
    s1.intern();

    /*
    ** 从字符串常量池取出 &quot;1&quot;，存入变量 s2
    ** 此时 s2 的地址就是字符串常量池中 &quot;1&quot; 的地址
    */
    String s2 = &quot;1&quot;;

    /*
    ** 相当于将 s1 中 String 对象的地址与字符串常量池中 &quot;1&quot; 的地址比较
    ** JDK 1.7 之前：  false
    ** JDK 1.7 及之后: false
    */
    System.out.println(s1 == s2);

&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public void test() &#123;</span><br><span class="line">      </span><br><span class="line">      &#x2F;*</span><br><span class="line">      ** - 右侧表达式的结果相当于 new String(&quot;11&quot;)</span><br><span class="line">      ** - 这里是通过 StringBuilder 进行拼接</span><br><span class="line">      ** - &quot;11&quot; 并不在字符串常量池中</span><br><span class="line">      ** 所以 s1 就是 String 对象的地址</span><br><span class="line">      *&#x2F;</span><br><span class="line">      String s1 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">      </span><br><span class="line">      &#x2F;*</span><br><span class="line">      ** 在此之前字符串常量池并没有 &quot;11&quot;</span><br><span class="line">      ** 在字符串常量池生成字符串 &quot;11&quot;</span><br><span class="line">      **   - JDK 1.7 之前：</span><br><span class="line">      **		直接生成一个新的对象，所以地址也是新的</span><br><span class="line">      **   - JDK 1.7 及之后：</span><br><span class="line">      **		创建一个对象，存放已有的 String 对象引用地址，没有新地址生成</span><br><span class="line">      *&#x2F;</span><br><span class="line">      s1.intern();</span><br><span class="line">      </span><br><span class="line">      &#x2F;*</span><br><span class="line">      ** JDK 1.7 之前：</span><br><span class="line">      ** 		此时 s2 存放的就是字符串常量池中 &quot;11&quot; 的地址</span><br><span class="line">      ** JDK 1.7 及之后：</span><br><span class="line">      **		此时字符串常量池中存放的是 &quot;11&quot; 的 String 对象的引用地址</span><br><span class="line">      **		在查找过程中，根据字符串常量找到了存放 &quot;11&quot; 的 String 对象</span><br><span class="line">      **		将该 String 对象的地址返回</span><br><span class="line">      **		故 s2 亦指向 s1 所指向的 String 对象</span><br><span class="line">      *&#x2F;</span><br><span class="line">      String s2 &#x3D; &quot;11&quot;;</span><br><span class="line">      </span><br><span class="line">      &#x2F;*</span><br><span class="line">      ** JDK 1.7 之前：false</span><br><span class="line">      **   - 相当于字符串常量池中 &quot;11&quot; 的地址与 String 对象的地址进行比较</span><br><span class="line">      ** JDK 1.7 及以后：true</span><br><span class="line">      **   - 两个不同变量，指向的却是同一个 String 对象</span><br><span class="line">      *&#x2F;</span><br><span class="line">      System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="java">public void test() &#123;

    /*
    ** - 右侧表达式的结果相当于 new String(&quot;11&quot;)
    ** - 这里是通过 StringBuilder 进行拼接
    ** - &quot;11&quot; 并不在字符串常量池中
    ** 所以 s1 就是 String 对象的地址
    */
    String s1 = new String(&quot;1&quot;) + new String(&quot;1&quot;); 

    // 字符串常量池生成字符串 &quot;11&quot;
    String s2 = &quot;11&quot;;

    /*
    ** 在这之前，字符串已有 &quot;11&quot;
    ** 直接将字符串常量池 &quot;11&quot; 的地址返回给 s3
    */
    String s3 = s1.intern();

    /*
    ** 相当于将 s1 中 String 对象的地址与字符串常量池中 &quot;11&quot; 的地址比较
    ** JDK 1.7 之前：  false
    ** JDK 1.7 及之后: false
    */
    System.out.println(s1 == s2);

    /*
    ** 两个变量都指向字符串常量池中 &quot;11&quot; 的地址
    ** JDK 1.7 之前：  true
    ** JDK 1.7 及之后：true
    */
    System.out.println(s2 == s3)

&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.5、StringTable 的垃圾回收</span><br><span class="line"></span><br><span class="line">- &#96;-XX:+PrintStringTableStatisics&#96;：打印 &#96;StringTable&#96; 的信息</span><br><span class="line"></span><br><span class="line">### 8.6、G1 的 String 去重操作</span><br><span class="line"></span><br><span class="line">- 许多 &#96;Java&#96; 应用做的测试得出以下结果</span><br><span class="line">  - 堆存活数据集合里 &#96;String&#96; 对象占了 &#96;25%&#96;</span><br><span class="line">  - 堆存活数据集合里洪福的 &#96;String&#96; 对象有 &#96;13.5%&#96;</span><br><span class="line">  - &#96;String&#96; 对象的平均长度是 &#96;45&#96;</span><br><span class="line">- 许多大规模的 &#96;Java&#96; 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，**&#96;Java&#96; 堆中存活的数据集合差不多 &#96;25%&#96; 是 &#96;String&#96; 对象**，更进一步，这里面差不多一半的 &#96;String&#96; 对象是重复的，即 &#96;str1.equals(str2) &#x3D;&#x3D; true&#96;，**堆上存在重复的 &#96;String&#96; 对象必然是一种内存的浪费**，这个项目将在 &#96;G1&#96; 垃圾收集器中实现自动持续对重复的 &#96;String&#96; 对象去重，这样就能避免浪费内存</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">- 实现步骤</span><br><span class="line">  - 当垃圾收集器工作的时候，会访问堆上存活的对象，**对每一个访问的对象都会检查是否是候选的要去重的 &#96;String&#96; 对象**</span><br><span class="line">  - 如果是，把这个对象的一个引用插入到队列中等待后续处理，一个去重的线程在后台执行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 &#96;String&#96; 对象</span><br><span class="line">  - 使用一个 &#96;HashTable&#96; 来记录所有的被 &#96;String&#96; 对象使用的不重复的 &#96;char&#96; 数组。当去重的时候，会查这个 &#96;HashTable&#96;，来看堆上是否已经存在一个一模一样的 &#96;char&#96; 数组</span><br><span class="line">  - 如果存在，&#96;String&#96; 对象会被调整引用那个数组，释放对原来数组的引用，最终会被垃圾收集器回收掉</span><br><span class="line">  - 如果查找失败，&#96;char&#96; 数组会被插入 &#96;HashTable&#96;，这样以后就可以共享这个数组了</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">- 命令行选项</span><br><span class="line">  - &#96;-XX:UseStringDedupliation&#96;：开启 &#96;String&#96; 去重，**默认是不开启的，需要手动开启**</span><br><span class="line">  - &#96;-XX:PrintStringDeduplicaitonStatistics&#96;：打印详细的去重统计信息</span><br><span class="line">  - &#96;-XX:DeduplicationAgeThreshold&#96;：达到这个年龄的 &#96;String&#96; 对象被认为是去重的候选对象</span><br><span class="line"></span><br><span class="line">&lt;div style&#x3D;&quot;text-align: center;</span><br><span class="line">           font-size: 20px; </span><br><span class="line">           margin-top: 30px;</span><br><span class="line">           font-weight: bolder;&quot;</span><br><span class="line"></span><br><span class="line">   &lt;span style&#x3D;&quot;border-top: 1px solid black;</span><br><span class="line">                border-bottom: 1px solid black;</span><br><span class="line">                letter-spacing:5px&quot;</span><br><span class="line"></span><br><span class="line">       &gt;&gt;FINISH&lt;&lt;</span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 九、垃圾回收概述</span><br><span class="line"></span><br><span class="line">- 垃圾收集并不是 &#96;Java&#96; 语言的伴生产物。早在 &#96;1960&#96; 年，第一门开始使用内存动态分配和垃圾收集技术的 &#96;Lisp&#96; 语言诞生</span><br><span class="line">- 关于垃圾收集有三个经典的问题</span><br><span class="line">  - 哪些内存需要回收</span><br><span class="line">  - 什么时候回收</span><br><span class="line">  - 如何回收</span><br><span class="line">- 垃圾收集机制是 &#96;Java&#96; 的招牌能力，**极大的提高了开发效率**，如今垃圾收集几乎称为现代语言的标配，即使经过如此长时间的发展，&#96;Java&#96; 的垃圾收集机制仍在不断地演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是 **面试的热点**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">常见面试题：</span><br><span class="line"></span><br><span class="line">- 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 &#96;CMS&#96; 和 &#96;G1&#96;，包括原理、流程、优缺点、垃圾回收算法的实现原理</span><br><span class="line">- &#96;JVM GC&#96; 算法有哪些，目前的 &#96;JDK&#96; 版本采用什么回收算法</span><br><span class="line">- &#96;G1&#96; 回收期，讲下回收过程</span><br><span class="line">- &#96;GC&#96; 是什么，为什么要有 &#96;GC&#96;</span><br><span class="line">- &#96;GC&#96; 的两种判定方法？&#96;CMS&#96; 收集器与 &#96;G1&#96; 收集器的特点</span><br><span class="line">- 说一下 &#96;GC&#96; 算法，分代回收说下</span><br><span class="line">- 垃圾收集策略和算法</span><br><span class="line">- &#96;JVM GC&#96; 原理，&#96;JVM&#96; 怎么回收内存</span><br><span class="line">- &#96;CMS&#96; 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</span><br><span class="line">- &#96;Java&#96; 的垃圾回收器都有哪些，说下 &#96;G1&#96; 的应用场景，平时你是如何搭配使用垃圾回收器的</span><br><span class="line">- 讲一讲垃圾回收算法</span><br><span class="line">- 什么情况下触发垃圾回收</span><br><span class="line">- 如何选择合适的垃圾收集算法</span><br><span class="line">- &#96;JVM&#96; 有哪三种垃圾回收器</span><br><span class="line">- 常见的垃圾回收器算法有哪些，各有什么优劣</span><br><span class="line">- &#96;System.gc()&#96; 和 &#96;runtime.gc()&#96; 会做什么事情</span><br><span class="line">- &#96;Java GC&#96; 机制？&#96;GC Roots&#96; 有哪些</span><br><span class="line">- &#96;Java&#96; 对象的回收方式，回收算法</span><br><span class="line">- &#96;CMS&#96; 和 &#96;G1&#96; 了解吗，&#96;CMS&#96; 解决了什么问题，说一下回收的过程</span><br><span class="line">- &#96;CMS&#96; 回收停顿了几次，为什么要停顿两次</span><br><span class="line"></span><br><span class="line">### 9.1、什么是垃圾</span><br><span class="line"></span><br><span class="line">- 指 **运行程序中没有任何指针指向的对象**，这个对象就是需要被回收的垃圾</span><br><span class="line">- 如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能 **导致内存溢出**</span><br><span class="line"></span><br><span class="line">### 9.2、为什么需要 GC</span><br><span class="line"></span><br><span class="line">- 对于高级语言来说，一个基本的认知是如果不进行垃圾回收，**内存迟早要被消耗光**，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样</span><br><span class="line">- 除了释放没用的对象，垃圾回收也可以清楚内存里的记录碎片。碎片整理将所占用的内存移动到堆的一段，以便 **&#96;JVM&#96; 将整理出的内存分配给新的对象**</span><br><span class="line">- 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，**没有 &#96;GC&#96; 就不能保证应用程序的正常进行**。而经常造成 &#96;STW&#96; 的 &#96;GC&#96; 又跟不上实际的需求，所以才会不断地尝试对 &#96;GC&#96; 进行优化</span><br><span class="line"></span><br><span class="line">### 9.3、早期垃圾回收</span><br><span class="line"></span><br><span class="line">- 在早期的 &#96;C&#x2F;C++&#96; 时代，垃圾回收基本上是手工进行的，开发人员可以使用 &#96;new&#96; 关键字进行内存申请，并使用 &#96;delete&#96; 关键字进行内存释放</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;C++</span><br><span class="line">  MibBridge *p &#x3D; new MibBridge();</span><br><span class="line">  if (p-&gt;Register(kDestory) !&#x3D; NO_ERROR) &#123;</span><br><span class="line">      delete p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来 <strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生 <strong>内存泄漏</strong>，垃圾对象永远无法被消除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成 <strong>应用程序崩溃</strong>。现在，除了 <code>Java</code> 以外，<code>C#</code>、<code>Python</code>、<code>Ruby</code> 等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式，已经称为了现代开发语言必备的标准。当有了垃圾回收机制，上述代码块极有可能变成如下情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *p = <span class="keyword">new</span> MibBridge();</span><br><span class="line">p-&gt;Register(kDestory);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="9-4、Java-垃圾回收机制"><a href="#9-4、Java-垃圾回收机制" class="headerlink" title="9.4、Java 垃圾回收机制"></a>9.4、Java 垃圾回收机制</h3><blockquote>
<ul>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样 <strong>降低内存泄漏和内存溢出的风险</strong></li>
<li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以 <strong>更专注于业务开发</strong></li>
</ul>
<hr>
<ul>
<li>对于 <code>Java</code> 程序员而言，自动管理就像一个黑匣子，如果过度依赖于自动，那么这将会是一场灾难，最严重的是 <strong>会弱化 <code>Java</code> 开发成员在出现内存溢出时定位问题和解决问题的能力</strong></li>
<li>此时，了解 <code>JVM</code> 的自动内存分配和内存回收原理就显得非常的重要，只有在真正了解 <code>JVM</code> 是如何管理内存后，我们才能够在遇见 <code>OutOfMemoryError</code> 时，快速地根据错误异常日志定位问题和解决问题</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就必须对这些自动化的技术 <strong>实施必要的监控和调节</strong></li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="十、垃圾回收相关算法"><a href="#十、垃圾回收相关算法" class="headerlink" title="十、垃圾回收相关算法"></a>十、垃圾回收相关算法</h2><h3 id="10-1、标记阶段"><a href="#10-1、标记阶段" class="headerlink" title="10.1、标记阶段"></a>10.1、标记阶段</h3><blockquote>
<ul>
<li>在堆里存放着几乎所有的 <code>Java</code> 对象实例，在 <code>GC</code> 执行垃圾回收之前，首先 <strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，<code>GC</code> 才会在执行垃圾回收时释放其所占用的内存空间，因此这个过程我们可以称为 <strong>垃圾标记阶段</strong></li>
<li>那么在 <code>JVM</code> 中究竟是如何标记一个死亡对象的？简单来说，当一个对象不再被任何的存活对象继续引用时，就可以宣判为已经死亡</li>
</ul>
</blockquote>
<h4 id="10-1-1-引用计数算法"><a href="#10-1-1-引用计数算法" class="headerlink" title="10.1.1 引用计数算法"></a>10.1.1 引用计数算法</h4><blockquote>
<ul>
<li><code>Reference Counting</code>，对每个对象保存一个整型的 <strong>引用计数器属性，用于记录对象被引用的情况</strong></li>
<li>对于一个对象 <code>A</code>，只要有任何一个对象引用了 <code>A</code>，则 <code>A</code> 的引用计数器就加一，当引用失效时，引用计数器就减一，只要对象 <code>A</code> 的引用计数器为零，即表示对象 <code>A</code> 不可能再被使用，可进行回收</li>
</ul>
<hr>
<ul>
<li>优点：<ul>
<li><strong>实现简单，垃圾对象便于辨识</strong></li>
<li><strong>判定效率高，回收没有延迟性</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>缺点：</p>
<ul>
<li><p>需要单独的字段存储计数器，这样的作法增加了 <strong>存储空间的开销</strong></p>
</li>
<li><p>每次复制都需要更新计数器，伴随着加法和减法操作，增加了 <strong>时间开销</strong></p>
</li>
<li><p>无法处理循环引用的情况，可能出现 <strong>内存泄漏</strong></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png" alt="引用计数器内存泄漏"></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>小结<ul>
<li>引用计数算法是很多语言的资源回收选择，例如 <code>Python</code>，同时支持引用计数和垃圾回收机制<ul>
<li><code>Python</code> 使用手动解除（在合适的时机，解除引用关系）和弱引用（<code>Weakref</code>，是 <code>Python</code> 提供的标准库，旨在解决循环引用）</li>
</ul>
</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制以提高吞吐量的尝试</li>
<li><code>Java</code> 没有使用引用计数算法，是因为不能处理循环引用</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="10-1-2、可达性分析算法"><a href="#10-1-2、可达性分析算法" class="headerlink" title="10.1.2、可达性分析算法"></a>10.1.2、可达性分析算法</h4><blockquote>
<ul>
<li>又称 <strong>根搜索算法</strong>、<strong>追踪性垃圾收集</strong></li>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地 <strong>解决在引用技术算法中循环引用的问题，防止内存泄漏发生</strong></li>
<li>相较于引用计数算法，这里的可达性分析就是 <code>Java</code>、<code>C#</code> 选择的</li>
</ul>
<hr>
<ul>
<li><p>基本思路</p>
<ul>
<li><p>可达性分析算法是以根对象集合 <code>(GC Roots)</code> 为起始点，按照从上到下的方式 <strong>搜索被根对象集合所连接的目标对象是否可达</strong></p>
<ul>
<li>所谓 <code>GC Roots</code> 根集合就是一组必须活跃的引用 </li>
</ul>
</li>
<li><p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径为 <strong>引用链 <code>(Reference Chain)</code></strong></p>
</li>
<li><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</p>
</li>
<li><p>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="可达性分析算法示意图"></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>GC Roots</code> 包括以下几类元素：<ul>
<li>虚拟机栈中的引用的对象<ul>
<li>如：各个线程被调用的方法中使用到的参数、局部变量等</li>
</ul>
</li>
<li>本地方法栈内 <code>JNI</code> 引用的对象</li>
<li>方法区中静态属性引用的对象<ul>
<li>如：<code>Java</code> 类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>如：字符串常量池 <code>String Table</code> 里的引用</li>
</ul>
</li>
<li>所有被同步锁 <code>Synchronized</code> 所持有的对象</li>
<li><code>Java</code> 虚拟机内部的引用<ul>
<li>如：基本数据类型对象的 <code>Class</code> 对象</li>
<li>如：一些常驻的异常对象（<code>NullPointerException</code>、<code>OutOfMemory</code>）</li>
<li>如：系统类加载器</li>
</ul>
</li>
<li>反射 <code>Java</code> 虚拟机内部情况的 <code>JMXBean</code>、<code>JVMTI</code> 中注册的回调、本地代码缓存等</li>
<li>根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象 “临时性” 地加入，共同构成完整 <code>GC Roots</code> 集合。比如：分代收集和局部回收 <code>Partial GC</code><ul>
<li>如果只针对 <code>Java</code> 堆中的某一块区域进行垃圾回收，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 <code>GC Roots</code> 集合中去考虑，才能保证可达性分析的准确性</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>注意<ul>
<li>如果使用可达性分析算法来判断内存是否可回收，那么分析工作就必须在一个能保障一致性的快照中进行，这点不满足的话分析结果的准确性就无法保证</li>
<li>这点也是导致 <code>GC</code> 进行时必须 <code>Stop The World</code> 的一个重要原因，即使是号称（几乎）不会发生停顿的 <code>CMS</code> 收集其中，<strong>枚举根节点时也是必须要停顿的</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-2、对象的-finalization-机制"><a href="#10-2、对象的-finalization-机制" class="headerlink" title="10.2、对象的 finalization 机制"></a>10.2、对象的 finalization 机制</h3><blockquote>
<ul>
<li><code>Java</code> 语言提供了对象终止机制来允许开发人员提供 <strong>对象被销毁之前的自定义处理逻辑</strong></li>
<li>当垃圾回收器发现一个没有引用指向的对象，会先电泳这个对象的 <code>finalize()</code> 方法</li>
<li><code>finalize()</code> 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件、套接字和数据库连接等</li>
</ul>
<hr>
<ul>
<li>永远不要主动调用某个对象的 <code>finalize()</code> 方法，应该交给垃圾回收机制调用<ul>
<li>在 <code>finalize()</code> 时可能会导致对象复活</li>
<li><code>finalize()</code> 方法的执行时间是没有保障的，完全由 <code>GC</code> 线程决定，极端情况下，若不发生 <code>GC</code>，则 <code>finalize()</code> 方法将没有执行的机会</li>
<li>一个糟糕的 <code>finalize()</code> 会严重影响 <code>GC</code> 的性能</li>
</ul>
</li>
<li>从功能上来说，<code>finalize()</code> 方法与 <code>C++</code> 中的析构函数比较相似，但是 <code>Java</code> 采用的是基于垃圾回收器的自动内存管理机制，所以 <code>finalize()</code> 方法在本质上不同于 <code>C++</code> 中的析构函数</li>
</ul>
<hr>
<ul>
<li>由于 <code>finalize()</code> 方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong></li>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般来说，此对象需要被回收。但事实上，也并非是 “非死不可”，这时候它们暂时处于 “缓刑” 阶段。<strong>一个无法触及的对象有可能在某一条件下 “复活” 自己</strong>，如果是这样，那么对它的回收就是不合理的<ul>
<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 <code>finalize()</code> 中复活</li>
<li><strong>不可触及的</strong>：对象的 <code>finalize()</code> 被调用，并没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 <strong><code>finalize()</code> 只会被调用一次</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>具体过程<ul>
<li>如果对象 <code>ObjA</code> 到 <code>GC Roots</code> 没有引用链，则进行第一次标记</li>
<li>如果筛选，判断此对象是否有必要执行 <code>finalize()</code> 方法<ul>
<li>如果对象 <code>ObjA</code> 没有重写 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过，则虚拟机视为没有必要执行，<code>ObjA</code> 被判定为不可触及</li>
<li>如果对象 <code>ObjA</code> 重写了 <code>finalize()</code> 方法，且还未被执行过，那么 <code>ObjA</code> 会被插入到 <code>F-Queue</code> 队列中，有一个虚拟机自动创建的、低优先级的 <code>Finalizer</code> 线程触发其 <code>finalize()</code> 方法执行</li>
<li><strong><code>finalize()</code> 方法是对象逃脱死亡的最后机会</strong>，稍后 <code>GC</code> 会对 <code>F-Queue</code> 队列中的对象进行二次标记，如果 <code>ObjA</code> 在 <code>finalize()</code> 方法中与引用链上的任一对象建立了联系，那么在第二次标记时，<code>ObjA</code> 就会被移除 <code>F-Queue</code>。之后，对象会在此出现没有引用存在的情况，在这个情况下，<code>finalize()</code> 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 <code>finalize()</code> 方法只会被调用一次</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-3、清除阶段"><a href="#10-3、清除阶段" class="headerlink" title="10.3、清除阶段"></a>10.3、清除阶段</h3><blockquote>
<ul>
<li>当成功区分出内存中存活对象和死亡对象后，<code>GC</code> 接下来的任务就是执行垃圾回收，释放掉无用的对象所占用的内存空间，以便有足够的可用内存空间作为新对象分配内存</li>
<li>目前在 <code>JVM</code> 中比较常见的三种垃圾收集算法是标记清除算法 <code>(Mark-Sweep)</code>，复制算法 <code>(Copying)</code>，标记压缩算法 <code>(Mark-Compact)</code></li>
</ul>
</blockquote>
<h4 id="10-3-1、标记清除算法"><a href="#10-3-1、标记清除算法" class="headerlink" title="10.3.1、标记清除算法"></a>10.3.1、标记清除算法</h4><blockquote>
<ul>
<li>背景：是一种非常基础和常见的垃圾收集算法，该算法被 <code>J·McCarthy</code> 等人在 <code>1960</code> 年提出并应用于 <code>Lisp</code> 语言</li>
</ul>
<hr>
<ul>
<li><p>执行过程：当堆中的有效内存 <code>(Available Memory)</code> 被耗尽的时候，就会停止整个程序 <code>(Stop The World)</code>，然后进行两项工作，即 <strong>标记</strong> 和 <strong>清除</strong></p>
<ul>
<li>标记：<code>Collector</code> 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 <code>Header</code> 中记录为可达对象</li>
<li>清除：<code>Collector</code> 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 <code>Header</code> 中没有标记为可达对象，则将其回收（并非置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否足够，如果够，就存放）</li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p>
</li>
</ul>
<hr>
<ul>
<li>缺点：<ul>
<li>效率不算高</li>
<li>在进行 <code>GC</code> 的时候，需要停止整个应用程序，导致用户体验差</li>
<li>在这种方式清理出来的空闲区是不连续的，产生内存碎片，需要维护一个空闲列表</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="10-3-2、复制算法"><a href="#10-3-2、复制算法" class="headerlink" title="10.3.2、复制算法"></a>10.3.2、复制算法</h4><blockquote>
<ul>
<li>背景：为了解决标记清除算法在垃圾收集效率方面的缺陷，<code>M·L·Minsky</code> 于 <code>1963</code> 年发表了著名的论文，<strong>CALISP Garbage Collector Algorithm Using Serial Secondary Storyage</strong>，<code>M·L·Minsky</code> 在该论文中描述的算法被人们称为复制算法，它也被 <code>M·L·Minsky</code> 本人成功地引入到了 <code>Lisp</code> 语言的一个实现版本中</li>
</ul>
<hr>
<ul>
<li><p>核心思想：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p>
</li>
</ul>
<hr>
<ul>
<li>优点：<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现碎片问题</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>缺点<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间</li>
<li>对于 <code>G1</code> 这种拆分称为大量 <code>region</code> 的 <code>GC</code>，复制而不是移动，意味着 <code>GC</code> 需要维护 <code>region</code> 之间对象的引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>注意：如果系统中的存活对象非常多，效率就会非常低</li>
</ul>
</blockquote>
<h4 id="10-3-3、标记压缩算法"><a href="#10-3-3、标记压缩算法" class="headerlink" title="10.3.3、标记压缩算法"></a>10.3.3、标记压缩算法</h4><blockquote>
<ul>
<li>背景：<ul>
<li>复制算法的高效性是建立在存活对象少、垃圾对象高的前提下，这种情况在新生代经常发生，但在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成品也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法</strong>。</li>
<li>标记清除算法的确可以应用在老年代，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 <code>JVM</code> 的设计者需要再次基础之上进行改进。标记压缩算法由此诞生</li>
<li><code>1970</code> 年前后，<code>G·L·Steele</code>、<code>G·J·Chene</code> 和 <code>D·S·Wise</code> 等研究者发布标记压缩算法。在许多现代的垃圾收集器中，人们都是用标记压缩算法或者其改进版本</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>执行过程：</p>
<ul>
<li><p>从根节点开始标记所有被引用的对象</p>
</li>
<li><p>将所有存活的对象压缩到内存的一段，按顺序排放</p>
</li>
<li><p>清理边界外所有的空间</p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png" alt="标记压缩算法"></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>标记压缩算法的最终效果等同于标记清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称之为标记清除压缩算法</li>
<li>二者的本质差异在于标记清除算法是一种 <strong>非移动式的回收算法</strong>，标记压缩是 <strong>移动式</strong> 的。是否移动后回收的存活对象是一项优缺点并存的风险决策</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址一次排列，而未被标记的内存会被清理掉。如此依赖，但我们需要给新对象分配内存时，<code>JVM</code> 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</li>
</ul>
<hr>
<ul>
<li>优点<ul>
<li>消除了标记清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，<code>JVM</code> 只需要持有一个内存的起始地址即可</li>
<li>消除了复制算法当中内存减半的高额代价</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>缺点<ul>
<li>从效率上来说，标记整理算法要低于复制算法</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需调整引用地址</li>
<li>移动过程中，需要全程暂停用户应用程序，即 <code>STW</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-4、小结"><a href="#10-4、小结" class="headerlink" title="10.4、小结"></a>10.4、小结</h3><blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Mark-Sweep</th>
<th align="center">Mark-Compact</th>
<th align="center">Copying</th>
</tr>
</thead>
<tbody><tr>
<td align="center">速度</td>
<td align="center">中等</td>
<td align="center">最慢</td>
<td align="center">最快</td>
</tr>
<tr>
<td align="center">空间</td>
<td align="center">少（但会堆积碎片）</td>
<td align="center">少（不堆积碎片）</td>
<td align="center">两倍大小（不堆积碎片）</td>
</tr>
<tr>
<td align="center">移动</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<ul>
<li>效率上来说，复制算法是最优的，但是却浪费了太多内存</li>
<li>而为了尽量兼顾上面提到的三个指标，标记整理算法相对来说更平滑以下，但是效率上却不尽人意，比复制算法多了一个标记阶段，比标记清除多了一个整理内存的阶段</li>
</ul>
</blockquote>
<h3 id="10-5、分代收集算法"><a href="#10-5、分代收集算法" class="headerlink" title="10.5、分代收集算法"></a>10.5、分代收集算法</h3><blockquote>
<ul>
<li>前面所有的算法，并没有一种算法可以完全替代其他算法，它们都具有各自独特的优势和特点。分代收集算法应运而生</li>
<li>分代收集算法，是基于这样一个事实：不同的对象生命周期是不一样的，因此，<strong>不同声明周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把 <code>Java</code> 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的垃圾回收算法，提高垃圾回收效率</li>
<li>在 <code>Java</code> 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 <strong><code>Http</code> 请求中的 <code>Session</code> 对象、线程、<code>Socket</code> 连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如 <code>String</code> 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收</li>
</ul>
<hr>
<ul>
<li>目前几乎所有的 <code>GC</code> 都是采用分代收集 <code>(Generational Collecting)</code> 算法执行垃圾回收的</li>
<li>在 <code>HotSpot</code> 中，基于分代的概念，<code>GC</code> 所使用的内存回收算法必须结合年轻代和老年代各自的特点</li>
</ul>
<hr>
<ul>
<li>年轻代：<ul>
<li>特点：区域相对于老年代较小，对象生命周期短、存活率低，回收频繁</li>
<li>这种情况复制算法的回收整理速度是最快的，复制算法的效率只和当前存活对象的大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 <code>HotSpot</code> 中的两个 <code>Survivor</code> 的设计得到缓解</li>
</ul>
</li>
<li>老年代：<ul>
<li>特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</li>
<li>这种情况存在大量存活率高的对象，复制算法明显不合适，一般是由标记清除算法或者标记清除算法、标记整理算法混合实习那<ul>
<li><code>Mark</code> 阶段的开销与存活对象的数量成正比</li>
<li><code>Sweep</code> 阶段的开销与所管理区域的大小成正比</li>
<li><code>Compact</code> 阶段的开销与存活对象的数据成正比</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>以 <code>HotSpot</code> 中的 <code>CMS</code> 回收期为例，<code>CMS</code> 是基于 <code>Mark-Sweep</code> 实现的，对于对象的回收效率很高。而对于碎片问题，<code>CMS</code> 采用基于 <code>Mark-Compact</code> 算法的 <code>Serial Old</code> 回收期作为补偿措施，当内存回收不佳（碎片导致的 <code>Concurrent Mode Failure</code> 时），将采用 <code>Serial Old</code> 执行 <code>Full GC</code> 以达到堆老年代内存的整理</li>
<li>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</li>
</ul>
</blockquote>
<h3 id="10-6、增量收集算法、分区算法"><a href="#10-6、增量收集算法、分区算法" class="headerlink" title="10.6、增量收集算法、分区算法"></a>10.6、增量收集算法、分区算法</h3><h4 id="10-6-1、增量收集算法"><a href="#10-6-1、增量收集算法" class="headerlink" title="10.6.1、增量收集算法"></a>10.6.1、增量收集算法</h4><blockquote>
<ul>
<li>上述现有的算法，在垃圾回收的过程中，应用软件将处于一种 <code>Stop The World</code> 的状态，在这个状态下，应用程序的所有线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量 <code>Incremental Collecting</code> 算法的诞生</li>
<li>基本思想：<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次 <strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，如此反复，直到垃圾收集完成</strong></li>
</ul>
</li>
<li>总的来说，增量收集算法的基础仍是传统的标记清除算法和复制算法，增量收集算法通过 <strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></li>
</ul>
<hr>
<ul>
<li>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是因为线程切换和上下文转换的小号，会使得垃圾回收的总体成本上升，<strong>使得系统吞吐量下降</strong></li>
</ul>
</blockquote>
<h4 id="10-6-2、分区算法"><a href="#10-6-2、分区算法" class="headerlink" title="10.6.2、分区算法"></a>10.6.2、分区算法</h4><blockquote>
<ul>
<li>一般来说，在相同条件下，堆空间越大，一次 <code>GC</code> 时所需要的时间就越长，有关 <code>GC</code> 产生的停顿也越长。为了更好地控制 <code>GC</code> 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 <code>GC</code> 所产生的停顿</li>
<li>分代算法将按照对象的生命周期长短划分成两部分，分区算法将整个堆空间划分成连续的不同小区间</li>
<li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="十一、垃圾回收相关概念"><a href="#十一、垃圾回收相关概念" class="headerlink" title="十一、垃圾回收相关概念"></a>十一、垃圾回收相关概念</h2><h3 id="11-1、System-gc"><a href="#11-1、System-gc" class="headerlink" title="11.1、System.gc()"></a>11.1、System.gc()</h3><blockquote>
<ul>
<li>在默认情况下，通过 <code>System.gc()</code> 或者 <code>Runtime.getRuntime().gc()</code> 的调用，会 **显示触发 <code>Full GC</code>**，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存</li>
<li>然而 <code>System.gc()</code> 调用附带一个免责申明，无法保证对垃圾收集器的调用</li>
<li><code>JVM</code> 实现者可以通过 <code>System.gc()</code> 调用来决定 <code>JVM</code> 的 <code>GC</code> 行为。而一般情况下，垃圾回收应该是主动进行的，<strong>无需手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 <code>System.gc()</code></li>
</ul>
</blockquote>
<h3 id="11-2、内存溢出与内存泄漏"><a href="#11-2、内存溢出与内存泄漏" class="headerlink" title="11.2、内存溢出与内存泄漏"></a>11.2、内存溢出与内存泄漏</h3><h4 id="11-2-1、内存溢出"><a href="#11-2-1、内存溢出" class="headerlink" title="11.2.1、内存溢出"></a>11.2.1、内存溢出</h4><blockquote>
<ul>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发车光绪崩溃的罪魁祸首之一</li>
<li>由于 <code>GC</code> 一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 <code>OOM</code></li>
<li>大多数情况下，<code>GC</code> 会进行各种年龄段的垃圾回收，是在不行就来一次 <code>Full GC</code>，这时候会回收大量的内存，供应用程序使用</li>
<li><code>JavaDoc</code> 中对 <code>OutOfMemoryError</code> 的解释是 <strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong></li>
<li>首先说明没有空闲内存的情况<ul>
<li><strong><code>Java</code> 虚拟机的堆内存设置不够</strong>：比如可能存在内存泄漏的问题，也有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 <code>JVM</code> 堆大小或者指定数值偏小</li>
<li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集</strong>：<ul>
<li>对于老版本的 <code>Oracle JDK</code> 因为永久代的大小是非常有限的，并且 <code>JVM</code> 对永久代垃圾回收非常不积极，所以当我们不断添加新类型的时候，永久代出现 <code>OutOfMemoryError</code> 也非常多见，也会导致 <code>OOM</code>，对应的异常信息会标记出来和永久代相关：<code>java.lang.OutOfMemoryError: PermGen Space</code> </li>
<li>随着元数据区的引入，方法区的内存已经不再那么窘迫，所以相应的 <code>OOM</code> 有所改观，出现 <code>OOM</code>，异常信息则变成了 <code>java.lang.OutOfMemoryError: Metaspace</code>。本地内存不足也会导致 <code>OOM</code></li>
</ul>
</li>
</ul>
</li>
<li>这里面隐含着一层意思是：在抛出 <code>OutOfMemoryError</code> 之前，通常垃圾收集器会被触发，尽其所能去清理空间<ul>
<li>例如在引用机制分析中，涉及到 <code>JVM</code> 回去尝试回收 <strong>软引用指向的对象等</strong></li>
<li>在 <code>java.nio.BIts.reserveMemory()</code> 方法中，我们能清楚的看到，<code>System.gc()</code> 会被调用，以清理空间</li>
</ul>
</li>
<li>当然，也不是在任何情况下垃圾收集器都会被触发<ul>
<li>例如我们分配一个超大对象，大小比堆的最大值还大，<code>JVM</code> 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 <code>OutOfMemory</code></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="11-2-2、内存泄漏"><a href="#11-2-2、内存泄漏" class="headerlink" title="11.2.2、内存泄漏"></a>11.2.2、内存泄漏</h4><blockquote>
<ul>
<li>也称作 “存储渗漏”，严格来说，<strong>只有对象不再被程序用到了，但是 <code>GC</code> 又不能回收它们的情况，才叫内存泄漏</strong></li>
<li>但实际情况很多时候一些不太好的实践会导致对象的生命周期变得很长，甚至导致 <code>OOM</code>，也可以称作广泛意义上的 “内存泄漏”</li>
<li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 <code>OutOfMemory</code> 异常，导致程序崩溃</li>
<li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</li>
</ul>
<hr>
<ul>
<li>举例<ul>
<li>单例模式中引用了后续关联了一些临时的对象</li>
<li>连接未被 <code>close</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="11-3、Stop-The-World"><a href="#11-3、Stop-The-World" class="headerlink" title="11.3、Stop The World"></a>11.3、Stop The World</h3><blockquote>
<ul>
<li>简称 <code>STW</code>，指的是 <code>GC</code> 事件发生过程中，会产生应用程序的停顿，<strong>停顿产生时整个应用程序都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为 <code>STW</code><ul>
<li>可达性分析算法中枚举根节点 <code>(GC Roots)</code> 会导致所有 <code>Java</code> 执行线程停顿<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ul>
</li>
<li>被 <code>STW</code> 中断的应用程序线程会在 <code>GC</code> 完成之后恢复，频繁的中断会让用户感觉像是网速卡顿一样，所以我们需要减少 <code>STW</code> 的发生</li>
<li><code>STW</code> 和采用什么 <code>GC</code> 无关，所有的 <code>GC</code> 都有这个事件</li>
<li>哪怕是 <code>G1</code> 也不能完全避免 <code>Stop-The-World</code> 发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停事件</li>
<li><code>STW</code> 是 <code>JVM</code> 在 <strong>后台自动发起和自动完成</strong> 的，在用户不可见的情况下，把用户正常的工作线程全部停掉</li>
<li>开发中不要用 <code>System.gc()</code>，会导致 <code>Stop-The-World</code></li>
</ul>
</blockquote>
<h3 id="11-4、垃圾回收的并行与并发"><a href="#11-4、垃圾回收的并行与并发" class="headerlink" title="11.4、垃圾回收的并行与并发"></a>11.4、垃圾回收的并行与并发</h3><blockquote>
<ul>
<li>并发指多个事情，在同一时间段发生了</li>
<li>并行指多个事情，在同一时间点发生了</li>
<li>并发的多个任务之间是互相抢占资源的</li>
<li>并行的多个任务之间是不互相抢占资源的</li>
<li>只有在多个 <code>CPU</code> 或者一个 <code>CPU</code> 多个核的情况中，才会发生并行</li>
<li>否则看似同时发生的事情，其实都是并发执行的</li>
</ul>
</blockquote>
<h4 id="11-4-1、并发"><a href="#11-4-1、并发" class="headerlink" title="11.4.1、并发"></a>11.4.1、并发</h4><blockquote>
<ul>
<li>在操作系统中，是指一个时间段中有几个程序都已处于已启动运行到运行完毕之间，且这几个程序都是在一个处理器上进行的</li>
<li>并发并不是真正意义上的 “同时进行”，只是 <code>CPU</code> 把一个时间段划分成几个时间片段，然后在这几个时间区间之间来回切换，由于 <code>CPU</code> 的处理速度非常快，只要时间间隔处理得恰当，即可让用户感觉是多个应用程序同时在进行</li>
</ul>
</blockquote>
<h4 id="11-4-2、并行"><a href="#11-4-2、并行" class="headerlink" title="11.4.2、并行"></a>11.4.2、并行</h4><blockquote>
<ul>
<li>当系统有一个以上 <code>CPU</code> 时，当一个 <code>CPU</code> 执行一个进程时，另一个 <code>CPU</code> 可以执行另一个进程，两个进程互补抢占 <code>CPU</code> 资源，可以同时进行</li>
<li>其实决定并行的因素不是 <code>CPU</code> 的数量，而是 <code>CPU</code> 的核心数量，比如一个 <code>CPU</code> 多个和也可以并行</li>
<li>适合科学计算，后台处理等弱交互场景</li>
</ul>
</blockquote>
<h4 id="11-4-3、垃圾回收的并发与并行"><a href="#11-4-3、垃圾回收的并发与并行" class="headerlink" title="11.4.3、垃圾回收的并发与并行"></a>11.4.3、垃圾回收的并发与并行</h4><blockquote>
<ul>
<li>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下<ul>
<li>并行 <code>(Parallel)</code>：<ul>
<li>指 <strong>多条垃圾收集线程并行工作</strong>，但此时用户线程仍处于等待状态，如 <code>ParNew</code>、<code>Parrallel Scavenge</code>、<code>Parallel Old</code></li>
</ul>
</li>
<li>串行 <code>(Serial)</code>：<ul>
<li>相较于并行的概念，单线程执行</li>
<li>如果内存不够，则程序暂停，启动 <code>JVM</code> 垃圾回收器进行垃圾回收。回收完，再启动程序的线程</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="11-5、安全点与安全区域"><a href="#11-5、安全点与安全区域" class="headerlink" title="11.5、安全点与安全区域"></a>11.5、安全点与安全区域</h3><h4 id="11-5-1、安全点"><a href="#11-5-1、安全点" class="headerlink" title="11.5.1、安全点"></a>11.5.1、安全点</h4><blockquote>
<ul>
<li>程序执行时并非所有地方都能停顿下来开始 <code>GC</code>，只有在特定的位置才能停顿下来开始 <code>GC</code>，这些位置称为安全点</li>
<li>安全点的选择很重要，<strong>如果太少可能导致 <code>GC</code> 等待的时间太长，如果太频繁可能导致运行时的性能问题。</strong>大部分指令的执行时间都非常短暂，通常会根据 <strong>“是否具有让程序长时间执行的特征”</strong> 为标准。比如选择以下执行时间较长的指令作为安全点，<strong>如方法调用、循环跳转和异常跳转等等</strong></li>
</ul>
<hr>
<p>如何在发生 <code>GC</code> 的时候，检查所有线程都跑到最近的安全点停顿下来</p>
<ul>
<li><strong>抢先式中断</strong>：首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点</li>
<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到 <code>Safe Point</code> 的时候主动轮询这个标志，如果中断标志为真，则自行挂起</li>
</ul>
</blockquote>
<h4 id="11-5-2、安全区域"><a href="#11-5-2、安全区域" class="headerlink" title="11.5.2、安全区域"></a>11.5.2、安全区域</h4><blockquote>
<ul>
<li><code>Safe Point</code> 机制保证了程序执行时，在不太长的时间内就会遇到可进入 <code>GC</code> 的 <code>Safe Point</code>，但是程序 “不执行” 的时候呢？例如线程处于 <code>Sleep</code> 状态或者 <code>Blocked</code> 状态，这时候线程无法响应 <code>JVM</code> 的中断请求，走到安全点去中断挂起，<code>JVM</code> 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域来解决</li>
<li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始都是 <code>GC</code> 安全的</strong>。我们也可以把 <code>Safe Region</code> 看作是被扩展了的 <code>Safe Point</code></li>
</ul>
<hr>
<ul>
<li>当线程运行到 <code>Safe Region</code> 的代码时，首先标识已经进入了 <code>Safe Region</code>，如果这段时间内发生 <code>GC</code>，<code>JVM</code> 会忽略表示为 <code>Safe Region</code> 状态的线程</li>
<li>当线程即将离开 <code>Safe Region</code> 时，会检查 <code>JVM</code> 是否已经完成 <code>GC</code>，如果完成了，则继续运行，否则必须等到 <code>GC</code> 结束，才可以离开 <code>Safe Region</code>，即等待继续运行的信号</li>
</ul>
</blockquote>
<h3 id="11-6、引用"><a href="#11-6、引用" class="headerlink" title="11.6、引用"></a>11.6、引用</h3><blockquote>
<ul>
<li><p>我们希望能够描述这样一类对象：当内存空间还足够时，则能保留在内存中，如果内存空间在进行垃圾收集后仍然很紧张，则可以抛弃这些对象</p>
</li>
<li><p><code>JDK1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用，<strong>这四种引用强度依次逐渐减弱</strong></p>
</li>
<li><p>除强引用外，其他三种引用均可以在 <code>java.lang.ref</code> 包中找到 </p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%BC%95%E7%94%A8.png" alt="引用"></p>
</li>
</ul>
<hr>
<ul>
<li><code>Reference</code> 子类中只有终结器引用时包内可见的，其他 <code>3</code> 中引用类型均为 <code>public</code>，可以在应用程序中直接使用<ul>
<li>**强引用 <code>(Strong Reference)</code>**：最传统的 “引用” 定义，是指在程序代码之中最普遍存在的引用复制，即类似于 <code>Object obj = new Object();</code> 这种引用关系，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li>
<li>**软引用 <code>(Soft Reference)</code>**：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之内进行第二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出异常</li>
<li>**弱引用 <code>(Weak Reference)</code>**：被弱引用关联的对象只能生存道下一次垃圾收集之前。当垃圾收集器工作室，无论内存空间是否足够，都会回收弱引用关联的对象</li>
<li><strong>虚引用 <code>Phantom Reference</code>**：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是 **能在这个对象被收集器回收时收到一个系统通知</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="11-6-1、强引用"><a href="#11-6-1、强引用" class="headerlink" title="11.6.1、强引用"></a>11.6.1、强引用</h4><blockquote>
<ul>
<li>在 <code>Java</code> 程序中，最常见的引用类型是强引用，也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong></li>
<li>当在 <code>Java</code> 语言中使用 <code>new</code> 操作符创建一个新的对象，将其赋给一个变量的时候，这个变量就能成为指向该对象的一个强引用</li>
<li><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象</strong></li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应引用赋值为 <code>null</code>，就可以当作垃圾被回收了，当然，具体地回收时机还是要看垃圾收集策略</li>
<li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成 <code>Java</code> 内存泄漏的主要原因之一</strong> </li>
</ul>
<hr>
<ul>
<li>强引用可以直接访问目标对象</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 <code>OOM</code> 也不回收强引用所指向的对象</li>
<li>强引用可能导致内存泄漏</li>
</ul>
</blockquote>
<h4 id="11-6-2、软引用"><a href="#11-6-2、软引用" class="headerlink" title="11.6.2、软引用"></a>11.6.2、软引用</h4><blockquote>
<ul>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li>
<li>软引用通常用来实现内存敏感的缓存，比如高速缓存就有用到软引用，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用滑轮的同时，不会耗尽内存</li>
<li>垃圾回收器在某个时刻决定回收软可达的对象时，会清理软引用，并可选地把引用放到一个引用队列</li>
<li>类似弱引用，只不过 <code>Java</code> 虚拟机会尽量让软引用地存活时间长一些，迫不得已才清理</li>
</ul>
</blockquote>
<h4 id="11-6-3、弱引用"><a href="#11-6-3、弱引用" class="headerlink" title="11.6.3、弱引用"></a>11.6.3、弱引用</h4><blockquote>
<ul>
<li>弱引用也是用来描述那些非必须对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统 <code>GC</code> 时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉只被弱引用关联的对象</li>
<li>但是，由于垃圾回收器的线程通常优先级很低，因此并不一定能很快的发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间</strong></li>
<li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li>
<li><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出，而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</li>
</ul>
</blockquote>
<h4 id="11-6-4、虚引用"><a href="#11-6-4、虚引用" class="headerlink" title="11.6.4、虚引用"></a>11.6.4、虚引用</h4><blockquote>
<ul>
<li>也成为 “幽灵引用” 或者 “幻影引用”，是所有引用类型中最弱的一个</li>
<li>一个对象是否有虚引用存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收期回收</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 <code>get()</code> 方法取得对象时，总是 <code>null</code></li>
<li><strong>为对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知</strong></li>
</ul>
</blockquote>
<h4 id="11-6-5、终结器引用"><a href="#11-6-5、终结器引用" class="headerlink" title="11.6.5、终结器引用"></a>11.6.5、终结器引用</h4><blockquote>
<ul>
<li>用于实现对象的 <code>finalize()</code> 方法</li>
<li>无需手动编码，其内部配合引用队列使用</li>
<li>在 <code>GC</code> 时，终结器引用入队。由 <code>Finalizer</code> 线程通过终结器引用找到被引用对象并调用它的 <code>finalize()</code> 方法，第二次 <code>GC</code> 时才能回收被引用对象</li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>


<h2 id="十二、垃圾回收器"><a href="#十二、垃圾回收器" class="headerlink" title="十二、垃圾回收器"></a>十二、垃圾回收器</h2><blockquote>
<ul>
<li><code>-XX:+PrintCommanLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li><code>jinfo -flag 待查看参数 pid</code>：使用命令行查看指定的参数数值</li>
</ul>
</blockquote>
<h3 id="12-1、GC-分类与性能指标"><a href="#12-1、GC-分类与性能指标" class="headerlink" title="12.1、GC 分类与性能指标"></a>12.1、GC 分类与性能指标</h3><h4 id="12-1-1、垃圾回收器概述"><a href="#12-1-1、垃圾回收器概述" class="headerlink" title="12.1.1、垃圾回收器概述"></a>12.1.1、垃圾回收器概述</h4><blockquote>
<ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同厂商、不同版本的 <code>JVM</code> 来实现</li>
<li>由于 <code>JDK</code> 的版本处于高速迭代过程中，因此 <code>Java</code> 发展至今已经衍生了众多的 <code>GC</code> 版本</li>
<li>从不同角度分析垃圾收集器，可以将 <code>GC</code> 分为不同的类型</li>
</ul>
</blockquote>
<h4 id="12-1-2、分类"><a href="#12-1-2、分类" class="headerlink" title="12.1.2、分类"></a>12.1.2、分类</h4><blockquote>
<ul>
<li>按线程数分<ul>
<li><strong>串行垃圾回收器</strong>：在同一时间内只允许有一个 <code>CPU</code> 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束<ul>
<li>在诸如单 <code>CPU</code> 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的 <code>Client</code> 模式下的 <code>JVM</code> 中</strong></li>
<li>在并发能力比较强的 <code>CPU</code> 上，并行回收器产生的停顿时间要短于串行回收器</li>
</ul>
</li>
<li><strong>并行垃圾回收器</strong>：可以运用多个 <code>CPU</code> 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了 <code>Stop-The-World</code> 机制</li>
</ul>
</li>
<li>按工作模式分<ul>
<li><strong>并发式垃圾回收器</strong>：回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
<li><strong>独占式垃圾回收器</strong>：回收器一旦运行，就停止应用程序中的所有用户线程</li>
</ul>
</li>
<li>按碎片处理方式分<ul>
<li><strong>压缩式垃圾回收器</strong><ul>
<li>在回收完成后，对存活的对象进行压缩整理，消除回收后的碎片</li>
<li>再分配对象空间使用 <strong>指针碰撞</strong></li>
</ul>
</li>
<li><strong>非压缩式回收器</strong><ul>
<li>再分配对象空间使用 <strong>空闲列表</strong></li>
</ul>
</li>
</ul>
</li>
<li>按工作的内存区间分<ul>
<li><strong>年轻代垃圾回收器</strong></li>
<li><strong>老年代垃圾回收器</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="12-1-3、性能指标"><a href="#12-1-3、性能指标" class="headerlink" title="12.1.3、性能指标"></a>12.1.3、性能指标</h4><blockquote>
<ul>
<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例</li>
<li><strong>垃圾收集开销</strong>：垃圾收集所用时间与总运行时间的比例</li>
<li><strong>暂停时间</strong>：执行垃圾收集时程序的工作线程被暂停的时间</li>
<li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率</li>
<li><strong>内存占用</strong>：<code>Java</code> 堆区所占的内存大小</li>
<li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间</li>
</ul>
<hr>
<ul>
<li>吞吐量、暂停时间、内存占用构成了一个 <strong>不可能三角</strong>，三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即使提高了吞吐量。而随着内存的扩大，对延迟反而带来负面效果</li>
<li>简单来说，主要关注 <strong>吞吐量</strong>、<strong>暂停时间</strong></li>
</ul>
</blockquote>
<h5 id="12-1-3-1、吞吐量"><a href="#12-1-3-1、吞吐量" class="headerlink" title="12.1.3.1、吞吐量"></a>12.1.3.1、吞吐量</h5><blockquote>
<ul>
<li><p>吞吐量就是 <code>CPU</code> 用于运行应用代码的时间与 <code>CPU</code> 总消耗时间的比值，即<br>$$<br>吞吐量 = \frac{运行应用代码的时间}{运行应用代码的时间+垃圾收集时间}<br>$$</p>
</li>
<li><p>比如虚拟机总共运行了 <code>100 min</code>，其中垃圾收集耗费 <code>1 min</code>，那么吞吐量就是 <code>99%</code></p>
</li>
<li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
</li>
<li><p>吞吐量优先，意味着再单位时间内，<code>STW</code> 的时间最短 <code>0.2 + 0.2 = 0.4</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%B3%A8%E9%87%8D%E5%90%9E%E5%90%90%E9%87%8F.png" alt="注重吞吐量"></p>
</li>
</ul>
</blockquote>
<h5 id="12-1-3-2、暂停时间"><a href="#12-1-3-2、暂停时间" class="headerlink" title="12.1.3.2、暂停时间"></a>12.1.3.2、暂停时间</h5><blockquote>
<ul>
<li><p>暂停时间是指一个时间段内应用程序线程暂停，让 <code>GC</code> 线程执行的状态</p>
<ul>
<li>例如，<code>GC</code> 期间 <code>100 ms</code> 的暂停时间意味着在这 <code>100 ms</code> 期间内没有应用程序线程是活动的</li>
</ul>
</li>
<li><p>暂停时间优先，意味着尽可能让单次 <code>STW</code> 的时间最短：<code>0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</code></p>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%B3%A8%E9%87%8D%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4.png" alt="注重暂停时间"></p>
</li>
</ul>
</blockquote>
<h5 id="12-1-3-3、吞吐量-VS-暂停时间"><a href="#12-1-3-3、吞吐量-VS-暂停时间" class="headerlink" title="12.1.3.3、吞吐量 VS 暂停时间"></a>12.1.3.3、吞吐量 VS 暂停时间</h5><blockquote>
<ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做 <strong>生产性</strong> 工作，直觉上吞吐量越高，程序运行越快</li>
<li>低暂停时间较好因为从最终用户的角度来看不管是 <code>GC</code> 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<strong>有时候甚至短暂的 <code>200 ms</code> 暂停都能打断中断用户体验</strong>，因此，具有低的较大暂停时间是非常重要的，特别是对于一个 <strong>交互式应用程序</strong></li>
<li>不幸的是 <strong>高吞吐量</strong> 和 <strong>低暂停时间</strong> 是一对竞争关系<ul>
<li>如果选择吞吐量优先，那么必然需要降低 <strong>内存回收的执行频率</strong>，但是这样会导致 <code>GC</code> 需要更长的暂停时间来执行内存回收</li>
<li>如果选择低暂停时间，那么为了降低每次执行内存回收时的暂停时间，也 <strong>只能频繁的执行内存回收</strong>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降</li>
</ul>
</li>
<li>在设计算法时，必须确定我们的目标：一个 <code>GC</code> 算法只可能对一个进行针对，现在的标准是：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></li>
</ul>
</blockquote>
<h3 id="12-2、不同的垃圾回收器概述"><a href="#12-2、不同的垃圾回收器概述" class="headerlink" title="12.2、不同的垃圾回收器概述"></a>12.2、不同的垃圾回收器概述</h3><blockquote>
<ul>
<li>垃圾回收机制是 <code>Java</code> 的招牌能力，极大的提高了开发效率，这样当然也是面试的热点</li>
</ul>
</blockquote>
<h4 id="12-2-1、发展史"><a href="#12-2-1、发展史" class="headerlink" title="12.2.1、发展史"></a>12.2.1、发展史</h4><blockquote>
<ul>
<li><code>1999</code> 年：随着 <code>JDK 1.3.1</code> 一起来的是串行方式的 <code>Serial GC</code>，它是第一款 <code>GC</code>，<code>ParNew</code> 垃圾收集器是 <code>Serial</code> 收集器的多线程版本</li>
<li><code>2002</code> 年：随着 <code>JDK 1.4.2</code> 一起发布的有 <code>Parallel GC</code> 和 <code>Concurrent Mark Sweep GC</code>，其中 <code>Parallel GC</code> 在 <code>JDK 6</code> 之后成为 <code>HotSpot</code> 的默认 <code>GC</code></li>
<li><code>2012</code> 年：在 <code>JDK 1.7u4</code> 版本中，<code>G1</code> 正式启用</li>
<li><code>2017</code> 年：<code>JDK 9</code> 中 <code>G1</code> 变成默认垃圾收集器，以替代 <code>CMS</code></li>
<li><code>2018</code> 年 <code>3</code> 月：<code>JDK 10</code> 中 <code>G1</code> 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟</li>
<li><code>2018</code> 年 <code>9</code> 月：<code>JDK 11</code> 发布，引入 <code>Epsilon</code> 垃圾回收器，又被称为 <code>No-Op</code> （无操作），同时引入 <code>ZGC (Experimental)</code>：可伸缩的低延迟垃圾收集器</li>
<li><code>2019</code> 年 <code>3</code> 月：<code>JDK 12</code> 发布，增强 <code>G1</code>，自动返回未用堆内存给操作系统，同时引入 <code>Shennandoah GC</code>：低停顿时间的 <code>GC (Experimental)</code></li>
<li><code>2019</code> 年 <code>9</code> 月：<code>JDK 13</code> 发布，增强 <code>ZGC</code>，自动返回未用堆内存给操作系统</li>
<li><code>2020</code> 年 <code>3</code> 月：<code>JDK 14</code> 发布，删除 <code>CMS</code> 垃圾回收器，扩展 <code>ZGC</code> 在 <code>MacOS</code> 和 <code>Windows</code> 上的应用</li>
</ul>
</blockquote>
<h4 id="12-2-2、七种经典的垃圾收集器"><a href="#12-2-2、七种经典的垃圾收集器" class="headerlink" title="12.2.2、七种经典的垃圾收集器"></a>12.2.2、七种经典的垃圾收集器</h4><blockquote>
<ul>
<li>串行回收器：<code>Serial</code>、<code>Serial Old</code></li>
<li>并行回收器：<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Parallel Old</code></li>
<li>并发回收器：<code>CMS</code>、<code>G1</code></li>
</ul>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="经典垃圾回收器"></p>
</blockquote>
<h4 id="12-2-3、七种经典垃圾收集器与垃圾分代之间的关系"><a href="#12-2-3、七种经典垃圾收集器与垃圾分代之间的关系" class="headerlink" title="12.2.3、七种经典垃圾收集器与垃圾分代之间的关系"></a>12.2.3、七种经典垃圾收集器与垃圾分代之间的关系</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image-20200719204358719"></p>
<ul>
<li>新生代：<code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code></li>
<li>老年代：<code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code></li>
<li>整堆：<code>G1</code></li>
</ul>
</blockquote>
<h4 id="12-2-4、垃圾收集器的组合关系"><a href="#12-2-4、垃圾收集器的组合关系" class="headerlink" title="12.2.4、垃圾收集器的组合关系"></a>12.2.4、垃圾收集器的组合关系</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="垃圾收集器之间的组合关系"></p>
<ul>
<li>其中，<code>Serial Old</code> 作为 <code>CMS</code> 出现 <code>Concurrent Mode Failure</code> 失败的后背方案</li>
<li>红色虚线：由于维护和兼容性测试的成本，在 <code>JDK 8</code> 时将 <code>Serial + CMS</code>、<code>ParNew + Serial Old</code> 这两组声明为废弃，并在 <code>JDK 9</code> 中完全取消了这些组合的支持</li>
<li>绿色虚线：即 <code>Parallel Scavenge + Serial Old</code> 这个组合，在 <code>JDK 14</code> 中已被弃用</li>
<li><code>CMS GC</code>：在 <code>JDK 14</code> 中已被删除</li>
</ul>
</blockquote>
<h4 id="12-2-5、不同垃圾回收器的概述"><a href="#12-2-5、不同垃圾回收器的概述" class="headerlink" title="12.2.5、不同垃圾回收器的概述"></a>12.2.5、不同垃圾回收器的概述</h4><blockquote>
<ul>
<li>由于 <code>Java</code> 的使用场景很多，移动端，服务器等，所以就需要针对不同的场景，提供不同的垃圾回收器，提高垃圾收集的性能</li>
<li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器。而是在 <strong>选择对具体应用最合适的收集器</strong></li>
</ul>
</blockquote>
<h3 id="12-3、Serial-回收器：串行回收"><a href="#12-3、Serial-回收器：串行回收" class="headerlink" title="12.3、Serial 回收器：串行回收"></a>12.3、Serial 回收器：串行回收</h3><h4 id="12-3-1、概述"><a href="#12-3-1、概述" class="headerlink" title="12.3.1、概述"></a>12.3.1、概述</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p>
<ul>
<li><code>Serial</code> 收集器是最基本、历史最悠久的垃圾收集器，<code>JDK 1.3</code> 之前回收新生代唯一的选择</li>
<li><code>Serial</code> 收集器作为 <code>HotSpot</code> 中 <code>client</code> 模式下的默认新生代垃圾收集器</li>
<li><code>Serial</code> 收集器采用复制算法、串行回收和 <code>Stop-The-World</code> 机制的方式执行内存回收</li>
<li>除了老年代之外，<code>Serial</code> 收集器还提供用于执行老年代的 <code>Serial Old</code> 收集器，**<code>Serial Old</code> 收集器同样也采用了串行回收和 <code>Stop-The-World</code> 机制，只不过内存回收算法使用的是标记压缩算法**<ul>
<li><code>Serial Old</code> 是运行在 <code>Client</code> 模式下默认的老年代垃圾回收器</li>
<li><code>Serial Old</code> 在 <code>Server</code> 模式下主要有两个用途<ul>
<li>与新生代的 <code>Parallel Scavenge</code> 搭配使用</li>
<li>作为老年代 <code>CMS</code> 收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
</li>
<li>这个收集器是一个单线程的收集器，但这并不仅仅说明它 <strong>只会使用一个 <code>CPU</code> 或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong> 知道它收集结束</li>
<li>在用户桌面应用场景中，可用内存一般不大（几十 <code>MB</code> 至一两百 <code>MB</code>），可以在短时间内完成垃圾收集，只要不频繁发生，使用串行收集器是可以接收的</li>
<li>在 <code>HotSpot</code> 虚拟机中，使用 <code>-XX:+UserSerialGC</code> 参数可以指定年轻代和老年代都使用串行收集器</li>
</ul>
</blockquote>
<h4 id="12-3-2、优缺点"><a href="#12-3-2、优缺点" class="headerlink" title="12.3.2、优缺点"></a>12.3.2、优缺点</h4><blockquote>
<ul>
<li><strong>简单而高效</strong>（与其他收集器的单线程比），对于限定单个 <code>CPU</code> 的环境来说，<code>Serial</code> 收集器由于没有线程交互的开销，专心做垃圾收集，自然可以获得最高的单线程收集效率</li>
</ul>
</blockquote>
<h3 id="12-4、ParNew-回收器：并行回收"><a href="#12-4、ParNew-回收器：并行回收" class="headerlink" title="12.4、ParNew 回收器：并行回收"></a>12.4、ParNew 回收器：并行回收</h3><h4 id="12-4-1、概述"><a href="#12-4-1、概述" class="headerlink" title="12.4.1、概述"></a>12.4.1、概述</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p>
<ul>
<li>如果说 <code>Serial GC</code> 是年轻代中的单线程垃圾收集器，那么 <code>ParNew</code> 收集器则是 <code>Serial</code> 收集器的多线程版本<ul>
<li><code>Par</code> 是 <code>Parallel</code> 的缩写，<code>New</code> 表示只能处理新生代</li>
</ul>
</li>
<li><code>ParNew</code> 收集器除了采用 <strong>并行收集</strong> 的方式进行内存回收外，与 <code>Serial</code> 几乎没有任何区别，<code>ParNew</code> 收集器在年轻代中同样也是采用 <strong>复制算法</strong>、<code>Stop-The-World</code> 机制</li>
<li><code>ParNew</code> 是很多 <code>JVM</code> 运行在 <code>Server</code> 模式下新生代的默认垃圾收集器</li>
<li>由于 <code>ParNew</code> 收集器是基于并行回收，那么是否可以判定 <code>ParNew</code> 收集器的回收效率在任何场景下都会比 <code>Serial</code> 收集器更高效<ul>
<li><code>ParNew</code> 收集器运行在多 <code>CPU</code> 的环境下，由于可以充分利用多 <code>CPU</code>、多核等物理硬件资源优势，可以更快速的完成垃圾收集，提升程序的吞吐量</li>
<li>但是 <strong>在单个 <code>CPU</code> 的环境下，<code>ParNew</code> 收集器不比 <code>Serial</code> 收集器高效</strong>。虽然 <code>Serial</code> 收集器是基于串行回收，但是由于 <code>CPU</code> 不需要频繁的做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销</li>
</ul>
</li>
<li>除了 <code>Serial</code> 之外，目前只有 <code>ParNew</code> 能与 <code>CMS</code> 收集器配合工作</li>
</ul>
</blockquote>
<h4 id="12-4-2、参数设置"><a href="#12-4-2、参数设置" class="headerlink" title="12.4.2、参数设置"></a>12.4.2、参数设置</h4><blockquote>
<ul>
<li><code>-XX:UseParNewGC</code>：手动指定使用 <code>ParNew</code> 收集器执行内存回收任务，它表示年轻代使用并行收集器，不影响老年代</li>
<li><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和 <code>CPU</code> 数据相同的线程数</li>
</ul>
</blockquote>
<h3 id="12-5、Parallel-回收器：吞吐量优先"><a href="#12-5、Parallel-回收器：吞吐量优先" class="headerlink" title="12.5、Parallel 回收器：吞吐量优先"></a>12.5、Parallel 回收器：吞吐量优先</h3><h4 id="12-5-1、概述"><a href="#12-5-1、概述" class="headerlink" title="12.5.1、概述"></a>12.5.1、概述</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/Parallel%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel收集器"></p>
<ul>
<li><p><code>HotSpot</code> 的年轻代中除了拥有 <code>ParNew</code> 收集器是基于并行回收的以外，<code>Parallel Scavenge</code> 收集器同样也采用了 <strong>复制算法</strong>、<strong>并行回收</strong> 和 <strong><code>Stop-The-World</code></strong> 机制</p>
</li>
<li><p>那么 <code>Parallel</code> 收集器的出现是否多此一举？</p>
<ul>
<li>和 <code>ParNew</code> 收集器不同，<code>Parallel Scavenge</code> 收集器的目标是达到一个 <strong>可控制的吞吐量</strong>，它也被称为吞吐量优先的垃圾收集器</li>
<li>自适应调节策略也是 <code>Parallel Scavenge</code> 与 <code>ParNew</code> 的一个区别</li>
</ul>
</li>
<li><p>高吞吐量则可以高效率地利用 <code>CPU</code> 时间，尽快完成程序地运算任务，主要 <strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用</p>
</li>
<li><p><code>Parallel</code> 收集器在 <code>JDK 1.6</code> 时提供了用于执行老年代垃圾收集的 <code>Parallel Old</code> 收集器，用来代替老年代的 <code>Serial Old</code> 收集器</p>
</li>
<li><p><code>Parallel Old</code> 收集器采用了 <strong>标记压缩算法</strong>，但同样也是 <strong>并行回收</strong> 和 <strong><code>Stop-The-World</code></strong> 机制</p>
</li>
<li><p>在程序吞吐量优先的应用场景中，<code>Parallel</code> 收集器和 <code>Parallel Old</code> 收集器的组合，在 <code>Server</code> 模式下的内存回收性能很不错</p>
</li>
<li><p>在 <code>Java 8</code> 中，默认是此垃圾收集器</p>
</li>
</ul>
</blockquote>
<h4 id="12-5-2、参数设置"><a href="#12-5-2、参数设置" class="headerlink" title="12.5.2、参数设置"></a>12.5.2、参数设置</h4><blockquote>
<ul>
<li><p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用 <code>Parallel</code> 并行收集器执行内存回收任务</p>
</li>
<li><p><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器</p>
<ul>
<li>分别适用于新生代和老年代，默认 <code>JDK 8</code> 是开启的</li>
<li>上面两个参数，默认开启一个，另一个也会被激活</li>
</ul>
</li>
<li><p><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数，一般地最好与 <code>CPU</code> 数量相等，以避免过多的线程数影响垃圾收集性能</p>
<ul>
<li>在默认情况下，当 <code>CPU</code> 数量小于 <code>8</code> 个，<code>ParallelThreads</code> 的值等于 <code>CPU</code> 数量</li>
<li>当 <code>CPU</code> 数量大于 <code>8</code> 个，<code>ParallelThreads</code> 的值等于：</li>
</ul>
<p>$$<br>3 + \frac{5 * CPUCOUNT}{8}<br>$$</p>
</li>
<li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间，单位是毫秒</p>
<ul>
<li>为了尽可能地把停顿时间控制在 <code>MaxGCPauseMillis</code> 以内，收集器在工作时会调整 <code>Java</code> 堆大小或者其他一些参数</li>
<li>对于用户来讲，停顿时间越短，体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务端适合 <code>Parallel</code> 进行控制</li>
<li>谨慎使用此参数</li>
</ul>
</li>
<li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例，用于衡量吞吐量的大小<br>$$<br>=\frac{1}{N + 1}<br>$$</p>
<ul>
<li>取值范围 <code>(1 ~ 100)</code>，默认 <code>99</code>，也就是垃圾收集时间不超过 <code>1%</code></li>
<li>与 <code>-XX:MaxParallelMillis</code> 有一定矛盾性，暂停时间越长，<code>Ratos</code> 参数就越容易超过设定的比例</li>
</ul>
</li>
<li><p><code>-XX:+UseAdaptiveSizePolicy</code>：设置 <code>Parallel Scavenbe</code> 收集器具有 <strong>自适应调节策略</strong></p>
<ul>
<li>在这种模式下，年轻代的大小、<code>Eden</code> 和 <code>Survivor</code> 的比例、晋升老年代的对象年龄等参数会被自动调整，已到达堆大小、吞吐量和停顿时间之间的平衡点</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，禁止顶虚拟机的最大堆、目标吞吐量和停顿时间，让虚拟机自己完成调优工作</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="12-6、CMS-回收器：低延迟"><a href="#12-6、CMS-回收器：低延迟" class="headerlink" title="12.6、CMS 回收器：低延迟"></a>12.6、CMS 回收器：低延迟</h3><h4 id="12-6-1、概述"><a href="#12-6-1、概述" class="headerlink" title="12.6.1、概述"></a>12.6.1、概述</h4><blockquote>
<p>![CMS 收集器](<a target="_blank" rel="noopener" href="https://gitee.com/CyingK/files/raw/master/images/JVM/CMS">https://gitee.com/CyingK/files/raw/master/images/JVM/CMS</a> 收集器.png)</p>
<ul>
<li>在 <code>JDK 1.5</code> 时期，<code>HotSpot</code> 推出了一款在 <strong>强交互应用</strong> 中几乎可认为有划时代意义的垃圾收集器：<code>CMS(Concurrent-Mark-Sweep)</code> 收集器，<strong>这款收集器是 <code>HotSpot</code> 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong></li>
<li><code>CMS</code> 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短就越是和与用户交互的程序，良好的响应速度能提升用户体验<ul>
<li><strong>目前很大一部分的 <code>Java</code> 应用集中在互联网站或者 <code>B/S</code> 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验</strong>，<code>CMS</code> 收集器就是非常符合这类应用的需求</li>
</ul>
</li>
<li><code>CMS</code> 垃圾收集算法采用 <strong>标记清除</strong> 算法，并且也会 <code>Stop-The-World</code></li>
<li>不幸的是，<code>CMS</code> 作为老年代的收集器，却无法与 <code>JDK 1.4.0</code> 中已经存在的新生代收集器 <code>Parallel Scavenge</code> 配合工作，所以在 <code>JDK 1.5</code> 中使用 <code>CMS</code> 来收集老年代的时候，新生代只能选择 <code>ParNew</code> 或者 <code>Serial</code> 收集器中的一个</li>
<li>在 <code>G1</code> 出现之前，<code>CMS</code> 使用还是非常广泛的，一直到今天，仍有很多系统在使用 <code>CMS GC</code></li>
</ul>
<hr>
<ul>
<li>尽管 <code>CMS</code> 收集器采用并发回收，但是在其 <strong>初始标记</strong> 和 <strong>重新标记</strong> 这两个阶段中仍然执行了 <code>Stop-The-World</code> 机制来暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要 <code>Stop-The-World</code>，只是尽可能地缩短暂停时间</li>
<li><strong>由于最耗费时间地并发标记与并发清除阶段都不需要暂停工作，所以整体地回收是低停顿的</strong></li>
<li>另外，由于在垃圾收集阶段用户线程没有中断，有意在 <strong><code>CMS</code> 回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，<code>CMS</code> 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是在 <strong>堆内存使用到某一阈值时便开始进行回收</strong>，以确保应用程序再 <code>CMS</code> 工作过程中依然有足够的空间支持应用程序运行，要是 <code>CMS</code> 运行期间预留的内存无法满足程序的需要，就会出现一次 <code>Concurrent Mode Failure</code>，这是虚拟机将启动后备方案，即使用 <code>Serial Old</code> 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</li>
<li><code>CMS</code> 收集器的垃圾收集算法采用 <strong>标记清除算法</strong>，这意味着每次进行内存的回收后，由于被执行内存回收的无用对象所占用的空间极有可能是不连续的一些内存块，不可避免的会 <strong>产生一些内存碎片</strong>，那么 <code>CMS</code> 在为新对象分配内存空间时，将无法使用指针碰撞技术，只能选择空闲列表执行内存分配</li>
</ul>
</blockquote>
<h4 id="12-6-2、回收过程"><a href="#12-6-2、回收过程" class="headerlink" title="12.6.2、回收过程"></a>12.6.2、回收过程</h4><blockquote>
<ul>
<li><code>CMS</code> 的整个过程比之前的收集器要复杂得多，整个过程分为 <code>4</code> 个主要阶段<ul>
<li><strong>初始标记 <code>(Initial-Mark)</code>**：在这个阶段，程序中所有的工作进程都会因为 <code>Stop-The-World</code> 机制出现短暂的暂停，这个阶段的主要任务 **仅仅是标记处 <code>GC Root</code> 能直接关联到的对象</strong>，一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的 <strong>速度非常快</strong></li>
<li><strong>并发标记 <code>(Concurrent-Mark)</code>**：从 <code>GC Rotts</code> 的 **直接关联对象开始遍历整个对象图的过程</strong>，这个阶段 <strong>耗时较长</strong>，但是 <strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行</li>
<li><strong>重新标记 <code>(Remark)</code>**：由于在并发标记阶段，程序的工作线程会和垃圾收集线程同时运行或交叉运行，因此为了 **修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常回避初始标记稍长一些，但也远比并发标记阶段时间端</li>
<li><strong>并发清除 <code>(Concurrent-Sweep)</code>**：此阶段 **清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>，由于不需要移动存活对象，所以这个阶段也是可以和用户线程同时并发的</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="12-6-3、优缺点"><a href="#12-6-3、优缺点" class="headerlink" title="12.6.3、优缺点"></a>12.6.3、优缺点</h4><blockquote>
<ul>
<li>优点<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
</li>
<li>弊端<ul>
<li><strong>产生内存碎片</strong>：导致并发清除后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不提前触发 <code>Full GC</code></li>
<li><strong><code>CMS</code> 收集器对 <code>CPU</code> 资源非常敏感</strong>：在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</li>
<li><strong><code>CMS</code> 收集器无法处理浮动垃圾</strong>：可能出现 <code>Concurrent Mode Failure</code> 失败，导致另一次 <code>Full GC</code> 的开始，在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或交叉运行的，那么 <strong>在并发标记阶段如果产生新的垃圾对象，<code>CMS</code> 将无法对这些垃圾进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行 <code>GC</code> 时释放这些之前未被回收的内存空间</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="12-6-4、参数设置"><a href="#12-6-4、参数设置" class="headerlink" title="12.6.4、参数设置"></a>12.6.4、参数设置</h4><blockquote>
<ul>
<li><p><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用 <code>CMS</code> 收集器执行内存回收任务</p>
<ul>
<li>开启该参数后将会自动将 <code>-XX:+UseParNewGC</code> 启动</li>
</ul>
</li>
<li><p><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</p>
<ul>
<li><code>JDK 5</code> 及以前版本的默认值为 <code>68</code>，即当老年代的空间使用率达到 <code>68%</code> 时，会执行一次 <code>CMS</code> 回收，<code>JDK 6</code> 及以上版本的默认值为 <code>92%</code></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 <code>CMS</code> 的触发频率，减少老年代回收的次数，可以较为明显的改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器，因此 <strong>通过该选项便可以有效降低 <code>Full GC</code> 的执行次数</strong></li>
</ul>
</li>
<li><p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 <code>Full GC</code> 后对内存空间进行压缩整理，以此避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，所以带来的问题就是停顿时间更长了</p>
</li>
<li><p><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次 <code>Full GC</code> 之后对内存空间进行压缩整理</p>
</li>
<li><p><code>-XX:ParallelCMSThreads</code>：设置 <code>CMS</code> 的线程数量</p>
<ul>
<li><code>CMS</code> 默认启动的线程数：</li>
</ul>
<p>$$<br>= \frac{ParallelCMSThreads+3}{4}<br>$$</p>
<ul>
<li><code>ParallelGCThreads</code> 时年轻代并行收集器的线程数，当 <code>CPU</code> 资源比较紧张时，收到 <code>CMS</code> 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="12-7、小结"><a href="#12-7、小结" class="headerlink" title="12.7、小结"></a>12.7、小结</h3><blockquote>
<ul>
<li>最小化使用内存和并行开销，选择 <code>Serial GC</code></li>
<li>最大化应用程序的吞吐量，选择 <code>Parallel GC</code></li>
<li>最小化 <code>GC</code> 期间的停顿时间，选择 <code>CMS GC</code></li>
</ul>
<hr>
<ul>
<li><code>JDK 9</code> 新特性：<code>CMS</code> 被标记为 <code>Deprecate</code></li>
<li><code>JDK 14</code> 新特性：删除 <code>CMS</code> 垃圾回收器</li>
</ul>
</blockquote>
<h3 id="12-8、G1-回收器：区域化分代式"><a href="#12-8、G1-回收器：区域化分代式" class="headerlink" title="12.8、G1 回收器：区域化分代式"></a>12.8、G1 回收器：区域化分代式</h3><h4 id="12-8-1、概述"><a href="#12-8-1、概述" class="headerlink" title="12.8.1、概述"></a>12.8.1、概述</h4><blockquote>
<ul>
<li>随着应用程序所应对的 <strong>业务越来越庞大</strong>、<strong>复杂</strong>、<strong>用户越来越多</strong>，没有 <code>GC</code> 就不能保证应用程序正常进行，而经常造成 <code>STW</code> 的 <code>GC</code> 又跟不上实际的需求，所以才会不断尝试对 <code>GC</code> 进行优化，<code>G1</code> 回收器是在 <code>JDK7u4</code> 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一</li>
<li>与此同时，为了适应现在 <strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间，同时兼顾良好的吞吐量</li>
<li><strong>官方给 <code>G1</code> 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起全功能收集器的重任与期望</strong></li>
<li>因为 <code>G1</code> 是一个并行的回收器，把堆内存分割为很多不相关的区域（物理上不连续的）。使用不同的 <code>Region</code> 来表示 <code>Eden</code>、幸存者 <code>0</code> 区、幸存者 <code>1</code> 区、老年代等</li>
<li><code>G1</code> 有计划的避免在整个 <code>Java</code> 堆中进行全区域的垃圾收集，<code>G1</code> 跟踪各个 <code>Region</code> 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需的时间），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 <code>Region</code></strong></li>
<li>由于这种方式的侧重点在于回收垃圾最大量的 <code>Region</code>，所以取了 <code>Garbage First</code> 的名字</li>
<li><code>G1</code> 是一款面向服务端应用的垃圾回收器，<strong>主要针对多核 <code>CPU</code> 及大容量内存的机器</strong>，以及高概率满足 <code>GC</code> 停顿时间的同时，还兼具高吞吐量的性能特征</li>
<li>在 <code>JDK 1.7</code> 正式启用，移除了 <code>Experimental</code> 的标识，<strong>是 <code>JDK 9</code> 以后的默认垃圾回收器</strong>，取代了 <code>CMS</code> 回收器以及 <code>Parallel Old</code> 组合，被官方称为 “全功能的垃圾收集器”</li>
<li>于此同时，<code>CMS</code> 在 <code>JDK 9</code> 中才被废弃，所以在 <code>JDK 8</code> 中需要使用 <code>-XX:+UseG1GC</code> 来启用 <code>G1</code> 回收器</li>
</ul>
</blockquote>
<h4 id="12-8-2、优缺点"><a href="#12-8-2、优缺点" class="headerlink" title="12.8.2、优缺点"></a>12.8.2、优缺点</h4><blockquote>
<ul>
<li>优势<ul>
<li><strong>并行与并发</strong><ul>
<li>并行性：<code>G1</code> 在回收期间，可以有多个 <code>GC</code> 线程同时工作，有效利用多核计算机能力，此时用户线程 <code>STW</code></li>
<li>并发性：<code>G1</code> 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会再整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><strong>分代收集</strong><ul>
<li>从分代上看，<code>G1</code> 依然属于分代型垃圾回收器，会区分年轻代和老年代，年轻代依然有 <code>Eden</code> 区和 <code>Surviver</code> 区。但从堆的结构上来看，它不要求整个 <code>Eden</code> 区、年轻代或者老年代都是连续的，再也不坚持固定大小和固定数量</li>
<li>将 <strong>堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代</strong></li>
<li>和之前的各类回收器不同，它同时 <strong>兼顾年轻代和老年代</strong>。对比其他回收器或者工作在年轻代、或者工作在老年代</li>
</ul>
</li>
<li><strong>空间整合</strong><ul>
<li><code>CMS</code>：标记清除算法、内存碎片、若干次 <code>GC</code> 后进行一次碎片整理</li>
<li><code>G1</code> 将内存划分为一个个的 <code>Region</code>。内存的回收是以 <code>Region</code> 作为基本单位的，**<code>Region</code> 之间是复制算法<strong>。但整体上实力上可看作是 **标记压缩算法</strong>，两种算法都可以避免内存碎片，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 <code>GC</code>，尤其是当 <code>Java</code> 堆非常大的时候，<code>G1</code> 的优势更加明显</li>
</ul>
</li>
<li><strong>可预测的停顿时间模型</strong><ul>
<li>这是 <code>G1</code> 相对于 <code>CMS</code> 的另一大优势，<code>G1</code> 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为 <code>M</code> 毫秒的时间片内，小号在垃圾收集器上的时间不得超过 <code>N</code> 毫秒</li>
<li>由于分区的原因，<code>G1</code> 可以只选取部分区域进行垃圾回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</li>
<li><code>G1</code> 跟踪各个 <code>Region</code> 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>**，保证了 <code>G1</code> 收集器在有限的时间内可以 **获取尽可能高的收集效率</strong></li>
<li>相比于 <code>CMS</code>，<code>G1</code> 未必能做到 <code>CMS</code> 在最好情况下的延时停顿，但最差的情况要好得多</li>
</ul>
</li>
</ul>
</li>
<li>缺点：<ul>
<li>相较于 <code>CMS</code>，<code>G1</code> 还不具备全方面、压倒性优势，比如在用户程序运行过程中，<code>G1</code> 无论是为了垃圾回收产生的内存占用还是程序运行时的额外执行负载都比 <code>CMS</code> 要高</li>
<li>从经验上来说，在小内存应用上 <code>CMS</code> 的表现大概率会优于 <code>G1</code>，而 <code>G1</code> 在大内存应用上则发挥其优势，平衡点在 <code>6~8GB</code> 之间</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="12-8-3、参数设置"><a href="#12-8-3、参数设置" class="headerlink" title="12.8.3、参数设置"></a>12.8.3、参数设置</h4><blockquote>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 <code>G1</code> 收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 <code>Region</code> 的大小，值是 <code>2</code> 的幂，范围是 <code>1~32MB</code>，目标是根据最小的 <code>Java</code> 堆大小划分出越 <code>2048</code> 个区域，默认是堆内存的 <code>1/2000</code></li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 <code>GC</code> 停顿时间指标（<code>JVM</code> 会尽力实现，但不能保证达到）默认值是 <code>200ms</code></li>
<li><code>-XX:ParallelGCThread</code>：设置 <code>STW</code> 工作线程数的值，最多设置为 <code>8</code></li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数，将 <code>n</code> 设置为并行垃圾回收线程数的 <code>1/4</code> 左右</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发 <code>GC</code> 周期的 <code>Java</code> 堆占用率，超过此值就触发 <code>GC</code>，默认值是 <code>45</code></li>
</ul>
</blockquote>
<h4 id="12-8-4、常见的操作步骤"><a href="#12-8-4、常见的操作步骤" class="headerlink" title="12.8.4、常见的操作步骤"></a>12.8.4、常见的操作步骤</h4><blockquote>
<ul>
<li>开启 <code>G1</code> 垃圾收集器</li>
<li>设置堆的最大内存</li>
<li>设置最大的停顿时间</li>
</ul>
</blockquote>
<h4 id="12-8-5、适用场景"><a href="#12-8-5、适用场景" class="headerlink" title="12.8.5、适用场景"></a>12.8.5、适用场景</h4><blockquote>
<ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是需要低 <code>GC</code> 延迟，并且有大堆的应用程序提供解决方案<ul>
<li>如在堆大小约为 <code>6GB</code> 或更大时，可预测的暂停时间可以低于 <code>0.5s</code>（<code>G1</code> 通过每次只清理一部分而不是全部的 <code>Region</code> 的增量式清理来保证每次 <code>GC</code> 停顿的时间不会过长</li>
</ul>
</li>
<li>用来替换 <code>CMS</code>（下面的情况中，使用 <code>G1</code> 可能比 <code>CMS</code> 好）<ul>
<li>超过 <code>50%</code> 的 <code>Java</code> 堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化很大</li>
<li><code>GC</code> 停顿时间过长 <code>&gt; 0.5s ~ 1s</code></li>
</ul>
</li>
<li><code>HotSpot</code> 垃圾收集器里，除了 <code>G1</code> 以外，其他的垃圾收集器使用内置的 <code>JVM</code> 线程执行 <code>GC</code> 的多线程操作，而 <code>G1</code> 回收器可以采用应用线程承担后台的 <code>GC</code> 工作，即当 <code>JVM</code> 的 <code>GC</code> 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</li>
</ul>
</blockquote>
<h4 id="12-8-6、Region"><a href="#12-8-6、Region" class="headerlink" title="12.8.6、Region"></a>12.8.6、Region</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/Region.png" alt="Region"></p>
<ul>
<li>使用 <code>G1</code> 收集器时，它将整个 <code>Java</code> 堆划分成为约 <code>2048</code> 个大小相同的独立 <code>Region</code> 块，每个 <code>Region</code> 块大小根据堆空间的实际大小而定，整体被控制在 <code>1MB</code> 到 <code>32MB</code> 之间，且为 <code>2</code> 的次幂，即 <code>1MB, 2MB, 4MB, 8MB, 16MB, 32MB</code>，可以通过 <code>-XX:G1HeapRegionSize</code> 进行设置，<strong>所有的 <code>Region</code> 大小相同，且在 <code>JVM</code> 生命周期内不会改变</strong></li>
<li>虽然还保留有新生代和老年代的概念，但新生代和老年代已经不再是物理隔离的了，它们都是一部分 <code>Region</code> 的集合，通过 <code>Region</code> 的动态分配方式实现逻辑上的连续</li>
<li>一个 <code>Region</code> 有可能属于 <code>Eden</code>，<code>Survivor</code> 或者 <code>Old/Tenured</code>，但是一个 <code>Region</code> 只可能属于一个角色，即一个 <code>Regoin</code> 里的内存不会跨代</li>
<li><code>G1</code> 垃圾收集器还增加了一种新的内存区域，叫做 <code>Humongous</code> 内存区域，如图中的 <code>H</code> 块，主要用于存储大对象，如果超过 <code>1.5</code> 个 <code>Region</code> 就会放到 <code>H</code><ul>
<li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成影响，为了解决这个问题，<code>G1</code> 划分了 <code>Humongous</code> 区，专门用来存放大对象，<strong>如果一个 <code>H</code> 区装不下一个大对象，那么 <code>G1</code> 会寻找连续的 <code>H</code> 区来存储</strong>。为了能找到连续的 <code>H</code> 区，有时候就不得不进行 <code>Full GC</code>，<code>G1</code> 大多数的行为都把 <code>H</code> 区作为老年代的一部分来看待</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="12-8-7、回收过程"><a href="#12-8-7、回收过程" class="headerlink" title="12.8.7、回收过程"></a>12.8.7、回收过程</h4><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png" alt="回收过程"></p>
<ul>
<li>主要包括 <strong>年轻代</strong>、<strong>并发标记过程</strong>、<strong>混合回收</strong> 三个环节（如果需要，单线程、独占式、高强度的 <code>Full GC</code> 还是继续存在的，它针对 <code>GC</code> 的评估失败提供了一种失败保护机制，即强力回收</li>
</ul>
<hr>
<ul>
<li>应用程序分配内存，<strong>当年轻代的 <code>Eden</code> 区用尽，开始年轻代回收过程</strong>：<code>G1</code> 的年轻代收集阶段是一个 <strong>并行的独占式</strong> 收集器。在年轻代回收期，<code>G1</code> 回收器暂停所有应用程序线程，启动多线程执行年轻代回收。然后 <strong>从年轻代区间移动存活对象到 <code>Survivor</code> 区或 <code>Old</code> 区，也有可能是两个区间都会涉及</strong></li>
<li>当堆内存使用到一定值时，开始老年代并发标记过程</li>
<li>标记完成马上开始混合回收过程，对于一个混合回收期，<code>G1</code> 回收器从老年区间移动对象到空闲区，这些空闲区也就成为了老年代的一部分，和年轻代不同，老年代的 <code>G1</code> 回收器和其他 <code>GC</code> 不同，**<code>G1</code> 的老年代回收器不需要整个老年代被回收，一次只需扫描一小部分老年代的 <code>Region</code> 即可**。同时这个老年代 <code>Region</code> 是和年轻代一起被回收的<ul>
<li>比如：一个 <code>web</code> 服务器，<code>Java</code> 进程最大堆内存为 <code>4G</code>，每分钟响应 <code>2500</code> 个请求，每 <code>45</code> 秒钟会新分配大约 <code>2G</code> 的内存，<code>G1</code> 会每 <code>45</code> 秒钟进行一次年轻代回收，每 <code>31</code> 个小时整个堆的使用率会达到 <code>45%</code>，会开始老年代并发标记过程，标记完后开始四到五次的混合回收</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="12-8-7-1、Remembered-Set"><a href="#12-8-7-1、Remembered-Set" class="headerlink" title="12.8.7.1、Remembered Set"></a>12.8.7.1、Remembered Set</h5><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/RSet.png" alt="RSet"></p>
<ul>
<li>一个对象被不同区域引用的问题</li>
<li>一个 <code>Region</code> 不可能是孤立的，一个 <code>Region</code> 中的对象可能被其他任意 <code>Region</code> 中的对象引用，判断对象存活时是否需要扫描整个 <code>Java</code> 堆才能保证准确？</li>
<li>在其他分代收集器也存在这样的问题，<code>G1</code> 尤为突出</li>
<li>回收新生代也不得不同时扫描老年代？</li>
<li>这样的话会降低 <code>Minor GC</code> 的效率</li>
</ul>
<hr>
<ul>
<li>解决办法<ul>
<li>无论是 <code>G1</code> 还是其他分代收集器，<code>JVM</code> 都是使用 <code>Remembered Set</code> 来避免全局扫描</li>
<li>每个 <code>Region</code> 都有一个对应的 <code>Remembered Set</code></li>
<li>每次 <code>Reference</code> 类型数据写操作时，都会产生一个 <code>Write Barrier</code> 暂停中断操作</li>
<li>然后检查将要写入的引用指向阿对象是否和该 <code>Reference</code> 类型数据在不同的 <code>Region</code>（其他收集器：检查老年代对象是否引用了新生代对象）</li>
<li>如果不同，则通过 <code>CardTable</code> 把相关引用信息记录到引用指向对象所在的 <code>Region</code> 对应的 <code>Rememberd Set</code> 中</li>
<li>当进行垃圾收集时，在 <code>GC</code> 根节点的枚举范围加入 <code>Remembered Set</code> 就可以保证不进行全局扫描，也不会有遗漏</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="12-8-7-2、年轻代-GC"><a href="#12-8-7-2、年轻代-GC" class="headerlink" title="12.8.7.2、年轻代 GC"></a>12.8.7.2、年轻代 GC</h5><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/YoungGC.png" alt="YoungGC"></p>
<ul>
<li><code>JVM</code> 启动时，<code>G1</code> 先准备好 <code>Eden</code> 区，程序在运行过程中不断创建对象到 <code>Eden</code> 区，当 <code>Eden</code> 区空间耗尽，<code>G1</code> 会启动一次年轻代垃圾回收过程</li>
<li><strong>年轻代垃圾回收只会回收 <code>Eden</code> 和 <code>Survivor</code></strong></li>
<li><code>YoungGC</code> 时，首先 <code>G1</code> 停止应用程序的执行，<code>G1</code> 创建回收集，回收集指需要被回收的内存分段的集合，年轻代回收过程的回收集包括 <code>Eden</code> 和 <code>Survivor</code> 区所有的内存分段</li>
</ul>
<hr>
<ul>
<li><strong>第一阶段</strong>，扫描根：根是指 <code>static</code> 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连通 <code>RSet</code> 记录的外部引用作为扫描存活对象的入口</li>
<li><strong>第二阶段</strong>，更新 <code>RSet</code>：处理 <code>dirty card queue</code> 中的 <code>card</code>，更新 <code>RSet</code>，此阶段完成后 <strong><code>RSet</code> 可以准确的反映老年代对所在的内存分段中对象的引用</strong> <ul>
<li>对于应用程序的引用复制语句 <code>object.filed = object</code>，<code>JVM</code> 会在之前和之后执行特殊的操作以在 <code>dirty card queue</code> 中入队保存了对象引用信息的 <code>card</code> 。在年轻代回收的时候，<code>G1</code> 会对 <code>dirty card queue</code> 中所有的 <code>card</code> 进行处理，以更新 <code>RSet</code>，保证 <code>RSet</code> 实时准确的反映引用关系</li>
<li>那为什么不在引用复制语句处直接更新 <code>RSet</code> 呢？这是为了性能的需要，<code>RSet</code> 的处理需要线程同步，开销会很大，使用队列性能会好很多</li>
</ul>
</li>
<li><strong>第三阶段</strong>，处理 <code>RSet</code>：识别被老年代对象指向的 <code>Eden</code> 中的对象，这些被指向的 <code>Eden</code> 中的对象被认为是存活的对象</li>
<li><strong>第四阶段</strong>，复制对象：此阶段，对象树被遍历，<code>Eden</code> 区内存段中存活的对象会被复制到 <code>Survivor</code> 区中空的内存分段，<code>Survivor</code> 区内存段中存活的对象如果年龄未达阈值，年龄会加 <code>1</code>，达到阈值会被复制到 <code>Old</code> 区中空的内存分段。如果 <code>Survivor</code> 空间不够，<code>Eden</code> 空间的部分数据会直接晋升老年代</li>
<li><strong>第五阶段</strong>，处理引用：处理 <code>Soft</code>、<code>Week</code>、<code>Phantom</code>、<code>Final</code>、<code>JNI Week</code> 等引用，最终 <code>Eden</code> 空间的数据为空，<code>GC</code> 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片</li>
</ul>
</blockquote>
<h5 id="12-8-7-3、并发标记过程"><a href="#12-8-7-3、并发标记过程" class="headerlink" title="12.8.7.3、并发标记过程"></a>12.8.7.3、并发标记过程</h5><blockquote>
<ul>
<li><strong>初始阶段</strong>：标记从根节点直接可达的对象，这个阶段是 <code>STW</code> 的，并且会触发一次年轻代 <code>GC</code></li>
<li>**根区域扫描 <code>(Root Region Scanning)</code>**：<code>G1</code> 收集器扫描 <code>Survivor</code> 区直接可达的老年代区域对象，并标记被引用的对象，这一过程必须在 <code>Young GC</code> 之前完成</li>
<li><strong>并发标记 <code>(Concurrent Marking)</code>**：在整个堆中进行并发标记（和应用程序并发执行），此过程可能会被 <code>Young GC</code> 中断，在并发标记阶段，</strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）</li>
<li>**再次标记 <code>(Remark)</code>**：优于应用程序持续进行，需要修正上一次的标记结果，是 <code>STW</code> 的，<code>G1</code> 中采用了比 <code>CMS</code> 更快的初始快照算法 <code>SnapShot-At-The-Beginning (SATB)</code></li>
<li>**独占清理 <code>(Cleanup, STW)</code>**：计算各个区域的存活对象和 <code>GC</code> 回收比例，并进行排序，识别可以混合回收的区域，为下阶段做铺垫，是 <code>STW</code> 的<ul>
<li>这个阶段并不会实际上去做垃圾的收集</li>
</ul>
</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域</li>
</ul>
</blockquote>
<h5 id="12-8-7-4、混合回收"><a href="#12-8-7-4、混合回收" class="headerlink" title="12.8.7.4、混合回收"></a>12.8.7.4、混合回收</h5><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6.png" alt="混合回收"></p>
<ul>
<li>当越来越多的对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾回收器，也就是我们的 <code>Mixed GC</code>，该算法并不是一个 <code>Old GC</code> 除了回收整个 <code>Young Region</code>，还会回收一部分的 <code>Old Region</code> 这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些 <code>Old Region</code> 进行收集，从而可以对垃圾回收的耗时时间进行控制，也需要注意的是 <code>Mixed GC</code> 并不是 <code>Full GC</code></li>
</ul>
<hr>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算出来了，默认情况下，这些老年代的内存分段会被分 <code>8</code> 次（可通过 <code>-XX:G1MixedGCCountTarget</code> 设置）被回收</li>
<li>回合回收的回收集 <code>Colleciton Set</code> 包括 <code>1/8</code> 的老年代内存分段，<code>Eden</code> 区内存分段，<code>Survivor</code> 区分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段，具体过程可参考年轻代回收的过程</li>
<li>优于老年代中的内存分段默认分 <code>8</code> 次回收，<code>G1</code> 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高，约会被先回收，并且有一个阈值会决定内存分段是否被回收 <code>-XX:G1MixedGCLiveThresholdPercent</code> 默认为 <code>65%</code>，意思是垃圾占内存分段的比例要达到 <code>65%</code> 才会被回收，如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</li>
<li>混合回收并不一定要进行 <code>8</code> 次，有一个阈值 <code>-XX:G1HeapWastePercent</code>，默认值为 <code>10%</code>，意思是允许整个堆内存中有 <code>10%</code> 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 <code>10%</code>，则不再进行混合回收，因为 <code>GC</code> 会花费很多的时间但是回收到的内存却很少</li>
</ul>
</blockquote>
<h5 id="12-8-7-5、可选过程：Full-GC"><a href="#12-8-7-5、可选过程：Full-GC" class="headerlink" title="12.8.7.5、可选过程：Full GC"></a>12.8.7.5、可选过程：Full GC</h5><blockquote>
<ul>
<li><code>G1</code> 的初衷就是要避免 <code>Full GC</code> 的出现，但是如果上述方式不能正常工作，<code>G1</code> 会 <strong>停止应用程序的执行</strong>，使用 <strong>单线程</strong> 的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长</li>
<li>要避免 <code>Full GC</code> 的发生，一旦发生需要进行调整，什么时候会发生 <code>Full GC</code> 呢？比如 <strong>堆太小</strong>，当 <code>G1</code> 在复制存活对象的时候没有空的内存分段可用，则会回退到 <code>Full GC</code> ，这种情况可以通过增大内存解决</li>
<li>导致 <code>G1</code> 进行 <code>Full GC</code> 的原因可能有两个<ul>
<li><code>Evacuation</code> 的时候没有足够的 <code>to-space</code> 来存放晋升到的对象</li>
<li>并发处理过程完成之前空间耗尽</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="12-8-8、补充"><a href="#12-8-8、补充" class="headerlink" title="12.8.8、补充"></a>12.8.8、补充</h4><blockquote>
<ul>
<li>从 <code>Oracle</code> 官方透露出来的信息可获知，回收阶段 <code>(Evacuation)</code> 其实本也想过设计成与用户程序一起并发执行，但是这件事情做起来比较复杂，考虑到 <code>G1</code> 只是回收一部分 <code>Region</code> 停顿时间是用户控制的，所以并不迫切区实现，而 <strong>选择把这个特性放到了 <code>G1</code> 之后出现的低延迟垃圾收集器 <code>ZGC</code> 中</strong>。另外，还考虑到 <code>G1</code> 不仅仅面向低延迟，停顿用户线程能最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案</li>
</ul>
<hr>
<ul>
<li>优化建议<ul>
<li>年轻代大小<ul>
<li>避免使用 <code>-Xmn</code> 或 <code>-XX:NewRatio</code> 等相关选项显示设置年轻代的大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
</li>
<li>暂停时间目标不要太严苛<ul>
<li><code>G1</code> 回收器的吞吐量目标是 <code>90%</code> 的用户程序时间和 <code>10%</code> 的垃圾回收时间</li>
<li>评估 <code>G1</code> 回收器的吞吐量时，暂停时间目标不要太严苛。目标泰国严苛标识你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="12-9、垃圾回收器总结"><a href="#12-9、垃圾回收器总结" class="headerlink" title="12.9、垃圾回收器总结"></a>12.9、垃圾回收器总结</h3><blockquote>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/GC%E6%80%BB%E6%88%AA%E5%9B%BE.png" alt="GC总截图"></p>
</blockquote>
<h4 id="12-9-1、如何选择垃圾回收器"><a href="#12-9-1、如何选择垃圾回收器" class="headerlink" title="12.9.1、如何选择垃圾回收器"></a>12.9.1、如何选择垃圾回收器</h4><blockquote>
<ul>
<li>优先调整堆的大小让 <code>JVM</code> 自适应完成</li>
<li>如果内存小于 <code>100M</code>，使用串行收集器</li>
<li>如果是单核、单机程序，并没有停顿时间的要求，串行收集器</li>
<li>如果是多 <code>CPU</code>、需要高吞吐量、允许停顿使时间超过 <code>1</code> 秒，选择并行或者 <code>JVM</code> 自己选择</li>
<li>如果是多 <code>CPU</code>、追求低停顿时间，需要快速响应，使用并发收集器</li>
</ul>
</blockquote>
<h3 id="12-10、GC-日志分析"><a href="#12-10、GC-日志分析" class="headerlink" title="12.10、GC 日志分析"></a>12.10、GC 日志分析</h3><h4 id="12-10-1、参数设置"><a href="#12-10-1、参数设置" class="headerlink" title="12.10.1、参数设置"></a>12.10.1、参数设置</h4><blockquote>
<ul>
<li><code>-XX:+PrintGC</code>：输出 <code>GC</code> 日志</li>
<li><code>-XX:+PrintGCDetails</code>：输出 <code>GC</code> 的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出 <code>GC</code> 的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出 <code>GC</code> 的时间戳（以日期的形式，如 <code>20**-**-**T**:**:**.***+0800</code>）</li>
<li><code>-XX:+PrintHeapAtGC</code>：在进行 <code>GC</code> 的前后打印出堆的信息</li>
<li><code>-Xloggc:path/gc.log</code>：设置日志文件的输出路径</li>
</ul>
</blockquote>
<h4 id="12-10-2、日志分析"><a href="#12-10-2、日志分析" class="headerlink" title="12.10.2、日志分析"></a>12.10.2、日志分析</h4><blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [GC (Allocation Failure) 80832K-&gt;19298K (227840K), 0.0084018 secs]</span></span><br><span class="line"><span class="quote">&gt; [GC (Metadata GC Threshold) 109499K-&gt;21465K (228352K), 0.0184066 secs]</span></span><br><span class="line"><span class="quote">&gt; [Full GC (Metadata GC Threshold) 21465K-&gt;16716K (201728K)，0.0619261 secs]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>GC</code>、<code>Full GC</code>：<code>GC</code> 的类型，<code>GC</code> 只在新生代上进行，<code>Full GC</code> 包括永久代，新生代，老年代</li>
<li><code>Allocation Failure</code>：<code>GC</code> 发生的原因</li>
<li><code>80832K -&gt; 19298K</code>：堆在 <code>GC</code> 前后的大小</li>
<li><code>228840K</code>：现在堆的大小</li>
<li><code>0.0084018 secs</code>：<code>GC</code> 持续的时间</li>
</ul>
<hr>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [GC(Allocation Failure)[pSYoungGen: 70640K-&gt;10116K(141312K)] 80541K-&gt;20017K (227328K)，0.0172573 secs] [Times: user=0.03 sys=0.00， real=0.02 secs]</span></span><br><span class="line"><span class="quote">&gt; [GC(Metadata GC Threshold)[PsYoungGen: 98859K-&gt;8154K(142336K)] 108760K-&gt;21261K (228352K), 0.0151573 secs] [Times: user=0.00 sys=0.01, real=0.02 secs]</span></span><br><span class="line"><span class="quote">&gt; [<span class="string">Full GC(Metadata GC Threshold)[pSYoungGen: 8154K-&gt;0K(142336K)</span>][<span class="symbol">ParOldGen: 13107K-&gt;16809K(62464K)</span>]21261K-&gt;16809K (204800K)，[<span class="string">Metaspace: 20599K-&gt;20599K (1067008K)</span>], 0.0639732 secs][Times: user=0.14 sys=0.00, real=0.06 secs]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>GC</code>、<code>Full GC</code>：同样是 <code>GC</code> 的类型</li>
<li><code>Allocation Failure</code>：<code>GC</code> 发生的原因</li>
<li><code>ParOldGen</code>：使用了 <code>Parallel Old</code> 并行垃圾收集器的老年代 <code>GC</code> 前后大小的变化</li>
<li><code>PSYoungGen</code>：使用了 <code>Parallel Scavenge</code> 并行垃圾收集器的新生代 <code>GC</code> 前后大小的变化</li>
<li><code>MetaSpace</code>：元数据区 <code>GC</code> 前后大小的变化，<code>JDK 1.8</code> 中引用了元数据区替换永久代</li>
<li><code>x secs</code>：<code>GC</code> 所花时间</li>
<li><code>Times</code>：<ul>
<li><code>user</code>：指垃圾收集器花费的所有 <code>CPU</code> 时间</li>
<li><code>sys</code>：花费在等待系统调用或系统事件的事件</li>
<li><code>real</code>：<code>GC</code> 从开始到结束的事件，包括其他进程所占用时间片的实际时间</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>[GC</code> 和 <code>[Full GC</code> 说明垃圾收集的停顿类型，如果有 <code>Full</code> 则表示发生了 <code>Stop The World</code></li>
<li>使用 <code>Serial</code> 收集器在新生代的名字是 <code>Default New Generation</code>，因此显示 <code>[DefNew</code></li>
<li>使用 <code>ParNew</code> 收集器在新生代的名字会变成 <code>[ParNew</code>，意思是 <code>Parallel New Generation</code></li>
<li>使用 <code>Parallel Scavenge</code> 收集器在新生代的名字是 <code>[PSYoungGen</code></li>
<li>老年代的收集和新生代一样，名字也是收集器决定的</li>
<li>使用 <code>G1</code> 的话，会显示 <code>Garbage-First Heap</code> </li>
</ul>
<hr>
<p><img src="https://gitee.com/CyingK/files/raw/master/images/JVM/MinorGC%E6%97%A5%E5%BF%97.png" alt="MinorGC日志"></p>
<hr>
<p>![Full GC日志](<a target="_blank" rel="noopener" href="https://gitee.com/CyingK/files/raw/master/images/JVM/Full">https://gitee.com/CyingK/files/raw/master/images/JVM/Full</a> GC日志.png)</p>
</blockquote>
<h3 id="12-11、垃圾回收器的新发展"><a href="#12-11、垃圾回收器的新发展" class="headerlink" title="12.11、垃圾回收器的新发展"></a>12.11、垃圾回收器的新发展</h3><blockquote>
<ul>
<li><code>GC</code> 仍然处于飞速发展之中，目前的默认选项 <code>G1</code> 回收器在不断的进行改进，很多我们原来认为的缺点，例如串行的 <code>Full GC</code>、<code>Card Table</code> 扫描低效等，都已经被大幅改进，例如 <code>JDK10</code> 以后，<code>Full GC</code> 已经是并行运行，在很多场景下，其表现还略优于 <code>Parallel GC</code> 的并行 <code>Full GC</code> 实现</li>
<li>即使是 <code>Serial</code> 回收器，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 <code>GC</code> 相关数据结构的开销还是线程的开销都是非常小的，随着云计算的兴起，<strong>在 <code>Serverless</code> 等新的应用场景下，<code>Serial</code> 回收器找到了新的舞台</strong></li>
<li>比较不幸的是 <code>CMS</code> 回收器，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 <code>JDK9</code> 中已经被标记为废弃，并在 <code>JDK 14</code> 中移除</li>
</ul>
</blockquote>
<h4 id="12-11-1、Shenandoah-GC"><a href="#12-11-1、Shenandoah-GC" class="headerlink" title="12.11.1、Shenandoah GC"></a>12.11.1、Shenandoah GC</h4><blockquote>
<ul>
<li><code>Shenandoah</code> 是众多 <code>GC</code> 中最孤独的一个，是第一款不由 <code>Oracle</code> 公司团队领导开发的 <code>HotSpot</code> 垃圾回收器。不可避免地 <strong>受到官方的排挤</strong>。比如号称 <code>OpenJDK</code> 和 <code>OracleJDK</code> 没有区别的 <code>Oracle</code> 公司拒绝在 <code>OracleJDK12</code> 中支持 <code>Shenandoah</code></li>
<li><code>Shenandoah</code> 垃圾回收器最初由 <code>RedHat</code> 进行的一项垃圾收集器研究项目 <code>Pauseless</code> 回收器的实现，<strong>旨在针对 <code>JVM</code> 上的内存回收实现低停顿的需求</strong>。在 <code>2014</code> 年贡献给 <code>OpenJDK</code></li>
<li><code>Red Hat</code> 研发 <code>Shenandoah</code> 团队对外宣称，**<code>Shenandoah</code> 回收器的暂停大小与堆大小无关，这意味着无论将堆设置为 <code>200MB</code> 还是 <code>200GB</code>，<code>99.9%</code> 的目标都可以把垃圾收集的停顿时间限制在十毫秒以内**，不过实际使用性能将取决于实际工作堆的大小和工作负载</li>
</ul>
</blockquote>
<h4 id="12-11-2、ZGC"><a href="#12-11-2、ZGC" class="headerlink" title="12.11.2、ZGC"></a>12.11.2、ZGC</h4><blockquote>
<ul>
<li><strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</strong></li>
<li>《深入理解 <code>Java</code> 虚拟机》一书中这样定义 <code>ZGC</code>：是一款基于 <code>Region</code> 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现 <strong>可并发的标记压缩算法</strong> 的，以 <strong>低延迟为首要目标</strong> 的一款垃圾收集器</li>
<li><code>ZGC</code> 的工作过程可以分为 <code>4</code> 个阶段：<strong>并发标记</strong>、<strong>并发预备重分配</strong>、<strong>并发重分配</strong>、<strong>并发重映射</strong></li>
<li><code>ZGC</code> 几乎在所有地方并发执行的，除了初始标记的是 <code>STW</code> 的，所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是很少的</li>
</ul>
</blockquote>
<div style="text-align: center;
            font-size: 20px; 
            margin-top: 30px;
            font-weight: bolder;"
    >
    <span style="border-top: 1px solid black;
                 border-bottom: 1px solid black;
                 letter-spacing:5px"
        >
        >>FINISH<<
    </span>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">承影</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cyingk.github.io/2020/07/22/JVM%20%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">http://cyingk.github.io/2020/07/22/JVM%20%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cyingk.github.io" target="_blank">Cin's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/06/%E5%88%9D%E8%AF%86%20Docker/"><img class="prev-cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/docker-2020-08-06.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">初识Docker</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/05/SpringCloud/"><img class="next-cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/SpringCloud-2020-05-05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringCloud微服务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/02/26/UML 类图/" title="UML类图"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/uml-2020-02-26.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-26</div><div class="title">UML类图</div></div></a></div><div><a href="/2020/01/16/Java 设计模式/" title="Java设计模式"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/design-patterns-2020-01-16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-16</div><div class="title">Java设计模式</div></div></a></div><div><a href="/2019/12/13/Java 连接 MySQL 数据库/" title="Java连接MySQL数据库"><img class="cover" src="https://gitee.com/CyingK/files/raw/master/images/blog/cover/jdbc-2019-12-13.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-13</div><div class="title">Java连接MySQL数据库</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java 虚拟机概论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">
    [ 第一部分 ]
    内存与垃圾回收
    </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">一、概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.</span> <span class="toc-text">二、类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E7%AE%80%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1、简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2、类的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81Loading"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3、Loading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%E3%80%81%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">2.3.2、加载方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81Linking"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4、Linking</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1%E3%80%81Verify"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">2.4.1、Verify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E3%80%81Prepare"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.4.2、Prepare</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%E3%80%81Resolve"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">2.4.3、Resolve</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81Initialization"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5、Initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E3%80%81ClassLoader"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6、ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1%E3%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">2.6.1、分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2%E3%80%81%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">2.6.2、引导类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">2.6.3、自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.7、双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E3%80%81%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.8.</span> <span class="toc-text">2.8、类的主动使用与被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1%E3%80%81%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">2.8.1、主动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2%E3%80%81%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">2.8.2、被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">2.3.</span> <span class="toc-text">三、运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81PC-Register"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1、PC Register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81JVM-Stack-Area"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2、JVM Stack Area</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E3%80%81%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">3.2.1、栈的存储单位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-1%E3%80%81%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.2.1.1.</span> <span class="toc-text">3.2.1.1、运行原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2%E3%80%81%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">3.2.2、栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-1%E3%80%81Local-Variables"><span class="toc-number">2.3.2.2.1.</span> <span class="toc-text">3.2.2.1、Local Variables</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-2%E3%80%81Operand-Stack"><span class="toc-number">2.3.2.2.2.</span> <span class="toc-text">3.2.2.2、Operand Stack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-3%E3%80%81Dynamic-Linking"><span class="toc-number">2.3.2.2.3.</span> <span class="toc-text">3.2.2.3、Dynamic Linking</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-4%E3%80%81Return-Address"><span class="toc-number">2.3.2.2.4.</span> <span class="toc-text">3.2.3.4、Return Address</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-5%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.2.2.5.</span> <span class="toc-text">3.2.3.5、方法的调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-6%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.3.2.2.6.</span> <span class="toc-text">3.2.3.6、方法重写的本质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3.2.3、面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81Native-Method-Stack"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3、Native Method Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81Heap"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4、Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1%E3%80%81%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">3.4.1、堆的核心概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-1%E3%80%81%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="toc-number">2.3.4.1.1.</span> <span class="toc-text">3.4.1.1、内存细分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2%E3%80%81%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">3.4.2、设置堆内存大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">3.4.3、年轻代与老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">3.4.4、对象分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5%E3%80%81Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="toc-number">2.3.4.5.</span> <span class="toc-text">3.4.5、Minor GC、Major GC、Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-1%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3-GC-%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.5.1.</span> <span class="toc-text">3.4.5.1、年轻代 GC 触发机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-2%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3-GC-%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.5.2.</span> <span class="toc-text">3.4.5.2、老年代 GC 触发机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-3%E3%80%81%E6%95%B4%E5%A0%86%E5%9B%9E%E6%94%B6-GC-%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.5.3.</span> <span class="toc-text">3.4.5.3、整堆回收 GC 触发机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6%E3%80%81%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-number">2.3.4.6.</span> <span class="toc-text">3.4.6、堆空间分代思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-7%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.4.7.</span> <span class="toc-text">3.4.7、内存分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-8%E3%80%81%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="toc-number">2.3.4.8.</span> <span class="toc-text">3.4.8、为对象分配内存：TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-8-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-TLAB"><span class="toc-number">2.3.4.8.1.</span> <span class="toc-text">3.4.8.1、为什么要有 TLAB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-8-2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-TLAB"><span class="toc-number">2.3.4.8.2.</span> <span class="toc-text">3.4.8.2、什么是 TLAB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-8-3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.4.8.3.</span> <span class="toc-text">3.4.8.3、对象分配过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-9%E3%80%81%E5%A0%86%E7%A9%BA%E9%97%B4%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.4.9.</span> <span class="toc-text">3.4.9、堆空间参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-10%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.10.</span> <span class="toc-text">3.4.10、逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-10-1%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.10.1.</span> <span class="toc-text">3.4.10.1、逃逸分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-10-2%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.4.10.2.</span> <span class="toc-text">3.4.10.2、参数设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-10-3%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B9%B6%E4%B8%8D%E6%88%90%E7%86%9F"><span class="toc-number">2.3.4.10.3.</span> <span class="toc-text">3.4.10.3、逃逸分析并不成熟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E3%80%81Method-Area"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5、Method Area</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1%E3%80%81%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">3.5.1、堆、栈、方法区的交互关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-1-1%E3%80%81Hopspot-JVM-%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">2.3.5.1.1.</span> <span class="toc-text">3.5.1.1、Hopspot JVM 中方法区的演进</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">3.5.2、设置方法区内存的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">3.5.3、方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-1%E3%80%81Non-final-%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.5.3.1.</span> <span class="toc-text">3.5.3.1、Non-final 的类变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-2%E3%80%81Static-final-%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.5.3.2.</span> <span class="toc-text">3.5.3.2、Static-final 的类变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-3%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E9%95%BF"><span class="toc-number">2.3.5.3.3.</span> <span class="toc-text">3.5.3.3、常量池与运行时常量长</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">3.5.4、方法区使用举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5%E3%80%81%E6%96%B9%E6%B3%95%E6%BC%94%E8%BF%9B%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">3.5.5、方法演进的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-5-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E6%8D%A2%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-number">2.3.5.5.1.</span> <span class="toc-text">3.5.5.1、为什么要用元空间替换永久代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-5-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%95%B4-String-Table"><span class="toc-number">2.3.5.5.2.</span> <span class="toc-text">3.5.5.2、为什么要调整 String Table</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-6%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.5.6.</span> <span class="toc-text">3.5.6、方法区的垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-6-1%E3%80%81%E5%B8%B8%E9%87%8F%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.5.6.1.</span> <span class="toc-text">3.5.6.1、常量回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-6-2%E3%80%81%E7%B1%BB%E4%BF%A1%E6%81%AF%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.5.6.2.</span> <span class="toc-text">3.5.6.2、类信息的回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.6.</span> <span class="toc-text">3.6、小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">四、本地方法接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E3%80%81%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.5.</span> <span class="toc-text">五、对象的实例化、内存布局、访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1、对象的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">5.1.1、创建对象的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">5.1.2、创建对象的步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2、内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%B4-Header"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">5.2.1、对象头 Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2%E3%80%81%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE-Instance-Data"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">5.2.2、实例数据 Instance Data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3%E3%80%81%E5%AF%B9%E5%85%B6%E5%A1%AB%E5%85%85-Padding"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">5.2.3、对其填充 Padding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4%E3%80%81%E5%9B%BE%E7%A4%BA"><span class="toc-number">2.5.2.4.</span> <span class="toc-text">5.2.4、图示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3、对象访问定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">六、直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1、非直接缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2、直接缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3、直接内存概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">2.7.</span> <span class="toc-text">七、执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">7.1、执行引擎概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">7.1.2、执行引擎工作过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81Java-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.2.</span> <span class="toc-text">7.2、Java 代码编译和执行的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">2.7.3.</span> <span class="toc-text">7.3、机器码、指令、汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">7.3.1、机器码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2%E3%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">7.3.2、指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3%E3%80%81%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">7.3.3、指令集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">2.7.3.4.</span> <span class="toc-text">7.3.4、汇编语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-5%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">2.7.3.5.</span> <span class="toc-text">7.3.5、高级语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-6%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">2.7.3.6.</span> <span class="toc-text">7.3.6、字节码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">2.7.4.</span> <span class="toc-text">7.4、解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1%E3%80%81%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">7.4.1、解释器的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E3%80%81JIT-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.7.5.</span> <span class="toc-text">7.5、JIT 编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1%E3%80%81Java-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">7.5.1、Java 代码的执行分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2%E3%80%81%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%92%8C%E6%8E%A2%E6%B5%8B"><span class="toc-number">2.7.5.2.</span> <span class="toc-text">7.5.2、热点代码和探测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3%E3%80%81%E6%A8%A1%E5%BC%8F%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.7.5.3.</span> <span class="toc-text">7.5.3、模式设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6%E3%80%81%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.7.6.</span> <span class="toc-text">7.6、其他编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81String-Table"><span class="toc-number">2.8.</span> <span class="toc-text">八、String Table</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81String-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">2.8.1.</span> <span class="toc-text">8.1、String 的基本特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81String-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.8.2.</span> <span class="toc-text">8.2、String 的内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.3.</span> <span class="toc-text">8.3、字符串拼接操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E3%80%81intern-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.8.4.</span> <span class="toc-text">8.4、intern() 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1%E3%80%81new-String-%E2%80%9Cab%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.8.4.1.</span> <span class="toc-text">8.4.1、new String(“ab”) 会创建几个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2%E3%80%81new-String-%E2%80%9Ca%E2%80%9D-new-String-%E2%80%9Cb%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.8.4.2.</span> <span class="toc-text">8.4.2、new String(“a”) + new String(“b”) 会创建几个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3%E3%80%81%E9%87%8D%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.8.4.3.</span> <span class="toc-text">8.4.3、重点面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.8.5.</span> <span class="toc-text">9.4、Java 垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">十、垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.9.1.</span> <span class="toc-text">10.1、标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">10.1.1 引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2%E3%80%81%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">10.1.2、可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84-finalization-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.2.</span> <span class="toc-text">10.2、对象的 finalization 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">2.9.3.</span> <span class="toc-text">10.3、清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1%E3%80%81%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">10.3.1、标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.3.2.</span> <span class="toc-text">10.3.2、复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3%E3%80%81%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.3.3.</span> <span class="toc-text">10.3.3、标记压缩算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.9.4.</span> <span class="toc-text">10.4、小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.5.</span> <span class="toc-text">10.5、分代收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6%E3%80%81%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E3%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.6.</span> <span class="toc-text">10.6、增量收集算法、分区算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-1%E3%80%81%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.6.1.</span> <span class="toc-text">10.6.1、增量收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2%E3%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.6.2.</span> <span class="toc-text">10.6.2、分区算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.10.</span> <span class="toc-text">十一、垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E3%80%81System-gc"><span class="toc-number">2.10.1.</span> <span class="toc-text">11.1、System.gc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.10.2.</span> <span class="toc-text">11.2、内存溢出与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">11.2.1、内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">11.2.2、内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E3%80%81Stop-The-World"><span class="toc-number">2.10.3.</span> <span class="toc-text">11.3、Stop The World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.10.4.</span> <span class="toc-text">11.4、垃圾回收的并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-1%E3%80%81%E5%B9%B6%E5%8F%91"><span class="toc-number">2.10.4.1.</span> <span class="toc-text">11.4.1、并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-2%E3%80%81%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.10.4.2.</span> <span class="toc-text">11.4.2、并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-3%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.10.4.3.</span> <span class="toc-text">11.4.3、垃圾回收的并发与并行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5%E3%80%81%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.10.5.</span> <span class="toc-text">11.5、安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-1%E3%80%81%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-number">2.10.5.1.</span> <span class="toc-text">11.5.1、安全点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-2%E3%80%81%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.10.5.2.</span> <span class="toc-text">11.5.2、安全区域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6%E3%80%81%E5%BC%95%E7%94%A8"><span class="toc-number">2.10.6.</span> <span class="toc-text">11.6、引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">2.10.6.1.</span> <span class="toc-text">11.6.1、强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-2%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.10.6.2.</span> <span class="toc-text">11.6.2、软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-3%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">2.10.6.3.</span> <span class="toc-text">11.6.3、弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-4%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.10.6.4.</span> <span class="toc-text">11.6.4、虚引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-5%E3%80%81%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">2.10.6.5.</span> <span class="toc-text">11.6.5、终结器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.11.</span> <span class="toc-text">十二、垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E3%80%81GC-%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">2.11.1.</span> <span class="toc-text">12.1、GC 分类与性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.1.1.</span> <span class="toc-text">12.1.1、垃圾回收器概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2%E3%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.11.1.2.</span> <span class="toc-text">12.1.2、分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">2.11.1.3.</span> <span class="toc-text">12.1.3、性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-3-1%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">2.11.1.3.1.</span> <span class="toc-text">12.1.3.1、吞吐量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-3-2%E3%80%81%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="toc-number">2.11.1.3.2.</span> <span class="toc-text">12.1.3.2、暂停时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-3-3%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F-VS-%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="toc-number">2.11.1.3.3.</span> <span class="toc-text">12.1.3.3、吞吐量 VS 暂停时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.2.</span> <span class="toc-text">12.2、不同的垃圾回收器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">2.11.2.1.</span> <span class="toc-text">12.2.1、发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-2%E3%80%81%E4%B8%83%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.11.2.2.</span> <span class="toc-text">12.2.2、七种经典的垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-3%E3%80%81%E4%B8%83%E7%A7%8D%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.11.2.3.</span> <span class="toc-text">12.2.3、七种经典垃圾收集器与垃圾分代之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-4%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">2.11.2.4.</span> <span class="toc-text">12.2.4、垃圾收集器的组合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-5%E3%80%81%E4%B8%8D%E5%90%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.2.5.</span> <span class="toc-text">12.2.5、不同垃圾回收器的概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E3%80%81Serial-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">2.11.3.</span> <span class="toc-text">12.3、Serial 回收器：串行回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.3.1.</span> <span class="toc-text">12.3.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.11.3.2.</span> <span class="toc-text">12.3.2、优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4%E3%80%81ParNew-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">2.11.4.</span> <span class="toc-text">12.4、ParNew 回收器：并行回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.4.1.</span> <span class="toc-text">12.4.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.11.4.2.</span> <span class="toc-text">12.4.2、参数设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5%E3%80%81Parallel-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">2.11.5.</span> <span class="toc-text">12.5、Parallel 回收器：吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.5.1.</span> <span class="toc-text">12.5.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-2%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.11.5.2.</span> <span class="toc-text">12.5.2、参数设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6%E3%80%81CMS-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">2.11.6.</span> <span class="toc-text">12.6、CMS 回收器：低延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-6-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.6.1.</span> <span class="toc-text">12.6.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-6-2%E3%80%81%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">2.11.6.2.</span> <span class="toc-text">12.6.2、回收过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-6-3%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.11.6.3.</span> <span class="toc-text">12.6.3、优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-6-4%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.11.6.4.</span> <span class="toc-text">12.6.4、参数设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.11.7.</span> <span class="toc-text">12.7、小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8%E3%80%81G1-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="toc-number">2.11.8.</span> <span class="toc-text">12.8、G1 回收器：区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.11.8.1.</span> <span class="toc-text">12.8.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.11.8.2.</span> <span class="toc-text">12.8.2、优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-3%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.11.8.3.</span> <span class="toc-text">12.8.3、参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-4%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.11.8.4.</span> <span class="toc-text">12.8.4、常见的操作步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-5%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.11.8.5.</span> <span class="toc-text">12.8.5、适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-6%E3%80%81Region"><span class="toc-number">2.11.8.6.</span> <span class="toc-text">12.8.6、Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-7%E3%80%81%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">2.11.8.7.</span> <span class="toc-text">12.8.7、回收过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-8-7-1%E3%80%81Remembered-Set"><span class="toc-number">2.11.8.7.1.</span> <span class="toc-text">12.8.7.1、Remembered Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-8-7-2%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3-GC"><span class="toc-number">2.11.8.7.2.</span> <span class="toc-text">12.8.7.2、年轻代 GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-8-7-3%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.11.8.7.3.</span> <span class="toc-text">12.8.7.3、并发标记过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-8-7-4%E3%80%81%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="toc-number">2.11.8.7.4.</span> <span class="toc-text">12.8.7.4、混合回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-8-7-5%E3%80%81%E5%8F%AF%E9%80%89%E8%BF%87%E7%A8%8B%EF%BC%9AFull-GC"><span class="toc-number">2.11.8.7.5.</span> <span class="toc-text">12.8.7.5、可选过程：Full GC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-8%E3%80%81%E8%A1%A5%E5%85%85"><span class="toc-number">2.11.8.8.</span> <span class="toc-text">12.8.8、补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-number">2.11.9.</span> <span class="toc-text">12.9、垃圾回收器总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-9-1%E3%80%81%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.11.9.1.</span> <span class="toc-text">12.9.1、如何选择垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-10%E3%80%81GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">2.11.10.</span> <span class="toc-text">12.10、GC 日志分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-10-1%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.11.10.1.</span> <span class="toc-text">12.10.1、参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-10-2%E3%80%81%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">2.11.10.2.</span> <span class="toc-text">12.10.2、日志分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-11%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95"><span class="toc-number">2.11.11.</span> <span class="toc-text">12.11、垃圾回收器的新发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-11-1%E3%80%81Shenandoah-GC"><span class="toc-number">2.11.11.1.</span> <span class="toc-text">12.11.1、Shenandoah GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-11-2%E3%80%81ZGC"><span class="toc-number">2.11.11.2.</span> <span class="toc-text">12.11.2、ZGC</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">却道天凉好个秋</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>