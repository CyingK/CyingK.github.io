<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Operating_System | Cying</title><meta name="description" content="Operating_System"><meta name="keywords" content="OS"><meta name="author" content="Cying-承影"><meta name="copyright" content="Cying-承影"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Operating_System"><meta name="twitter:description" content="Operating_System"><meta name="twitter:image" content="http://narpro.top/img/os.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Operating_System"><meta property="og:url" content="http://cyingk.github.io/2020/04/08/Operating-System/"><meta property="og:site_name" content="Cying"><meta property="og:description" content="Operating_System"><meta property="og:image" content="http://narpro.top/img/os.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://cyingk.github.io/2020/04/08/Operating-System/"><link rel="next" title="SpringBoot" href="http://cyingk.github.io/2020/04/05/SpringBoot/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://narpro.top/","msgToTraditionalChinese":"简","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Light Mode Activated Manually","night_to_day":"Dark Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Cying</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#一、计算机操作系统概念"><span class="toc_mobile_items-text">一、计算机操作系统概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-1-操作系统处理方式"><span class="toc_mobile_items-text">1.1 操作系统处理方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-1-批处理方式"><span class="toc_mobile_items-text">1.1.1 批处理方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-2-分时处理方式"><span class="toc_mobile_items-text">1.1.2 分时处理方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-3-实时处理方式"><span class="toc_mobile_items-text">1.1.3 实时处理方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-2-操作系统的功能组成"><span class="toc_mobile_items-text">1.2 操作系统的功能组成</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-1-用户和接口管理"><span class="toc_mobile_items-text">1.2.1 用户和接口管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-2-处理机管理"><span class="toc_mobile_items-text">1.2.2 处理机管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-3-线程控制和管理"><span class="toc_mobile_items-text">1.2.3 线程控制和管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-4-存储管理"><span class="toc_mobile_items-text">1.2.4 存储管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-5-设备管理"><span class="toc_mobile_items-text">1.2.5 设备管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-6-文件管理"><span class="toc_mobile_items-text">1.2.6 文件管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-1-内核"><span class="toc_mobile_items-text">1.2.1 内核</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-2-PC-机-DOS-操作系统启动过程"><span class="toc_mobile_items-text">1.2.2 PC 机 DOS 操作系统启动过程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-3-操作系统的主要特征"><span class="toc_mobile_items-text">1.3 操作系统的主要特征</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-1-并发性"><span class="toc_mobile_items-text">1.3.1 并发性</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二、作业与作业管理概述"><span class="toc_mobile_items-text">二、作业与作业管理概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-什么是作业"><span class="toc_mobile_items-text">2.1 什么是作业</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-1-用户管理"><span class="toc_mobile_items-text">2.1.1 用户管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-2-接口管理"><span class="toc_mobile_items-text">2.1.2 接口管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-3-批作业的管理控制与调度"><span class="toc_mobile_items-text">2.1.3 批作业的管理控制与调度</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-操作系统接口"><span class="toc_mobile_items-text">2.2 操作系统接口</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-1-作业控制说明语言"><span class="toc_mobile_items-text">2.2.1 作业控制说明语言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-2-联机命令接口"><span class="toc_mobile_items-text">2.2.2 联机命令接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-3-程序级接口"><span class="toc_mobile_items-text">2.2.3 程序级接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-4-CPU-的两种工作状态"><span class="toc_mobile_items-text">2.2.4 CPU 的两种工作状态</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-3-系统调用"><span class="toc_mobile_items-text">2.3 系统调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-4-作业的管理控制"><span class="toc_mobile_items-text">2.4 作业的管理控制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-1-批作业的状态管理"><span class="toc_mobile_items-text">2.4.1 批作业的状态管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-2-批作业控制块的描述和组织"><span class="toc_mobile_items-text">2.4.2 批作业控制块的描述和组织</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-3-不同的作业-I-O-方式"><span class="toc_mobile_items-text">2.4.3 不同的作业 I&#x2F;O 方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-4-不同的作业控制方式"><span class="toc_mobile_items-text">2.4.4 不同的作业控制方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-5-作业调度"><span class="toc_mobile_items-text">2.5 作业调度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-1-先来先服务-FCFS-调度算法"><span class="toc_mobile_items-text">2.5.1 先来先服务 FCFS 调度算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-2-最短作业优先-SJF-调度算法"><span class="toc_mobile_items-text">2.5.2 最短作业优先 SJF 调度算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-3-最高相应比优先-HRF-调度算法"><span class="toc_mobile_items-text">2.5.3 最高相应比优先 HRF 调度算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-4-最高优先级-HPF-调度算法"><span class="toc_mobile_items-text">2.5.4 最高优先级 HPF 调度算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-5-均衡调度算法"><span class="toc_mobile_items-text">2.5.5 均衡调度算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-6-作业调度性能的衡量准则"><span class="toc_mobile_items-text">2.5.6 作业调度性能的衡量准则</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#三、进程管理与处理机调度"><span class="toc_mobile_items-text">三、进程管理与处理机调度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-1-初识进程"><span class="toc_mobile_items-text">3.1 初识进程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-1-什么是进程"><span class="toc_mobile_items-text">3.1.1 什么是进程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-2-操作系统为什么要进入进程"><span class="toc_mobile_items-text">3.1.2 操作系统为什么要进入进程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-3-进程与程序、作业有何区别和联系"><span class="toc_mobile_items-text">3.1.3 进程与程序、作业有何区别和联系</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-2-进程与进程管理模块"><span class="toc_mobile_items-text">3.2 进程与进程管理模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-1-进程的特征"><span class="toc_mobile_items-text">3.2.1 进程的特征</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-2-进程管理模块的主要功能"><span class="toc_mobile_items-text">3.2.2 进程管理模块的主要功能</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-3-进程状态转换"><span class="toc_mobile_items-text">3.3 进程状态转换</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-3-1-进程的三种基本状态"><span class="toc_mobile_items-text">3.3.1 进程的三种基本状态</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-4-进程的创建与撤销"><span class="toc_mobile_items-text">3.4 进程的创建与撤销</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-4-1-什么是原语"><span class="toc_mobile_items-text">3.4.1 什么是原语</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-4-2-进程创建原语"><span class="toc_mobile_items-text">3.4.2 进程创建原语</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-4-3-撤销进程"><span class="toc_mobile_items-text">3.4.3 撤销进程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-5-父进程与子进程"><span class="toc_mobile_items-text">3.5 父进程与子进程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-5-1-fork-说明"><span class="toc_mobile_items-text">3.5.1 fork() 说明</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-6-进程状态转换控制原语"><span class="toc_mobile_items-text">3.6 进程状态转换控制原语</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-6-1-阻塞原语"><span class="toc_mobile_items-text">3.6.1 阻塞原语</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-6-2-唤醒原语"><span class="toc_mobile_items-text">3.6.2 唤醒原语</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-6-3-挂起原语"><span class="toc_mobile_items-text">3.6.3 挂起原语</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-6-4-激活原语"><span class="toc_mobile_items-text">3.6.4 激活原语</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-7-进程调度"><span class="toc_mobile_items-text">2.7 进程调度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-7-1-非抢占式调度"><span class="toc_mobile_items-text">2.7.1 非抢占式调度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-7-2-抢占式调度"><span class="toc_mobile_items-text">2.7.2 抢占式调度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-7-3-进程调度算法"><span class="toc_mobile_items-text">3.7.3 进程调度算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-8-实时任务调度"><span class="toc_mobile_items-text">2.8 实时任务调度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-8-1-非周期实时任务的分类及调度方法"><span class="toc_mobile_items-text">2.8.1 非周期实时任务的分类及调度方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-8-2-周期性实时任务"><span class="toc_mobile_items-text">2.8.2 周期性实时任务</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-9-线程的引入"><span class="toc_mobile_items-text">2.9 线程的引入</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-9-1-线程是什么"><span class="toc_mobile_items-text">2.9.1 线程是什么</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-9-2-线程的实现"><span class="toc_mobile_items-text">2.9.2 线程的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-9-3-进程和线程的区别"><span class="toc_mobile_items-text">2.9.3 进程和线程的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-10-处理机的四级调度"><span class="toc_mobile_items-text">2.10 处理机的四级调度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-10-1-典型的三级调度"><span class="toc_mobile_items-text">2.10.1 典型的三级调度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-10-2-线程调度"><span class="toc_mobile_items-text">2.10.2 线程调度</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#四、进程并发控制篇"><span class="toc_mobile_items-text">四、进程并发控制篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-1-互斥与同步的基本概念"><span class="toc_mobile_items-text">4.1 互斥与同步的基本概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-1-并发"><span class="toc_mobile_items-text">4.1.1 并发</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-2-并发带来的问题"><span class="toc_mobile_items-text">4.1.2 并发带来的问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-3-互斥"><span class="toc_mobile_items-text">4.1.3 互斥</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-4-同步"><span class="toc_mobile_items-text">4.1.4 同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-5-临界资源"><span class="toc_mobile_items-text">4.1.5 临界资源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-6-临界区"><span class="toc_mobile_items-text">4.1.6 临界区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-7-死锁"><span class="toc_mobile_items-text">4.1.7 死锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-8-活锁"><span class="toc_mobile_items-text">4.1.8 活锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-9-饥饿"><span class="toc_mobile_items-text">4.1.9 饥饿</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-10-原子操作"><span class="toc_mobile_items-text">4.1.10 原子操作</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-2-软件方法解决进程互斥"><span class="toc_mobile_items-text">4.2 软件方法解决进程互斥</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-3-信号量机制解决同步互斥问题"><span class="toc_mobile_items-text">4.3 信号量机制解决同步互斥问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-1-信号量机制实现要素"><span class="toc_mobile_items-text">4.3.1 信号量机制实现要素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-2-记录型信号量"><span class="toc_mobile_items-text">4.3.2 记录型信号量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-3-解决互斥问题"><span class="toc_mobile_items-text">4.3.3 解决互斥问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-4-解决同步问题"><span class="toc_mobile_items-text">4.3.4 解决同步问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-5-互斥、同步解决方法之异同分析"><span class="toc_mobile_items-text">4.3.5 互斥、同步解决方法之异同分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-6-记录型信号量解决问题的步骤"><span class="toc_mobile_items-text">4.3.6 记录型信号量解决问题的步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-4-生产者与消费者问题"><span class="toc_mobile_items-text">4.4 生产者与消费者问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-4-3-经典生产者-消费者问题"><span class="toc_mobile_items-text">4.4.3 经典生产者-消费者问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-5-读者写者问题"><span class="toc_mobile_items-text">4.5 读者写者问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-6-理发师问题"><span class="toc_mobile_items-text">4.6 理发师问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-7-哲学家就餐问题"><span class="toc_mobile_items-text">4.7 哲学家就餐问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-7-1-错误算法"><span class="toc_mobile_items-text">4.7.1 错误算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-7-1-算法一"><span class="toc_mobile_items-text">4.7.1 算法一</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-7-2-算法二"><span class="toc_mobile_items-text">4.7.2 算法二</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-7-4-算法三"><span class="toc_mobile_items-text">4.7.4 算法三</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-8-管程机制"><span class="toc_mobile_items-text">4.8 管程机制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-8-1-管程解决生产者与消费者问题"><span class="toc_mobile_items-text">4.8.1 管程解决生产者与消费者问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-9-死锁的发生与描述"><span class="toc_mobile_items-text">4.9 死锁的发生与描述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-1-现象"><span class="toc_mobile_items-text">4.9.1 现象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-2-死锁的危害"><span class="toc_mobile_items-text">4.9.2 死锁的危害</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-3-产生死锁的原因"><span class="toc_mobile_items-text">4.9.3 产生死锁的原因</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-4-必要条件"><span class="toc_mobile_items-text">4.9.4 必要条件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-5-资源请求分配图"><span class="toc_mobile_items-text">4.9.5 资源请求分配图</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-6-资源请求分配矩阵"><span class="toc_mobile_items-text">4.9.6 资源请求分配矩阵</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-9-7-死锁的解决方法"><span class="toc_mobile_items-text">4.9.7 死锁的解决方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-10-死锁的预防"><span class="toc_mobile_items-text">4.10 死锁的预防</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-11-死锁避免"><span class="toc_mobile_items-text">4.11 死锁避免</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-11-1-银行家算法的思路"><span class="toc_mobile_items-text">4.11.1 银行家算法的思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-11-2-银行家算法的数据结构"><span class="toc_mobile_items-text">4.11.2 银行家算法的数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-11-3-银行家算法的步骤"><span class="toc_mobile_items-text">4.11.3 银行家算法的步骤</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-11-4-银行家算法的应用"><span class="toc_mobile_items-text">4.11.4 银行家算法的应用</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#五、存储管理篇"><span class="toc_mobile_items-text">五、存储管理篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-1-存储管理概述"><span class="toc_mobile_items-text">5.1 存储管理概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-1-1-内存的分配和回收"><span class="toc_mobile_items-text">5.1.1 内存的分配和回收</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-1-2-地址重定位"><span class="toc_mobile_items-text">5.1.2 地址重定位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-1-3-地址共享与保护"><span class="toc_mobile_items-text">5.1.3 地址共享与保护</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-1-4-地址扩充"><span class="toc_mobile_items-text">5.1.4 地址扩充</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-1-5-存储管理方法"><span class="toc_mobile_items-text">5.1.5 存储管理方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-2-程序的编译链接与地址重定位"><span class="toc_mobile_items-text">5.2 程序的编译链接与地址重定位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-3-连续分区存储结构"><span class="toc_mobile_items-text">5.3 连续分区存储结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-3-1-单分区方式"><span class="toc_mobile_items-text">5.3.1 单分区方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-3-2-多分区方式"><span class="toc_mobile_items-text">5.3.2 多分区方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-3-3-主存分配表"><span class="toc_mobile_items-text">5.3.3 主存分配表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-3-4-主存分配算法"><span class="toc_mobile_items-text">5.3.4 主存分配算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-4-固定多分区存储管理"><span class="toc_mobile_items-text">5.4 固定多分区存储管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-4-1-单分区存储管理"><span class="toc_mobile_items-text">5.4.1 单分区存储管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-4-2-固定多分区存储管理"><span class="toc_mobile_items-text">5.4.2 固定多分区存储管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-4-3-动态多分区存储管理（可变分区）"><span class="toc_mobile_items-text">5.4.3 动态多分区存储管理（可变分区）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-5-基本分页存储管理"><span class="toc_mobile_items-text">5.5 基本分页存储管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-5-1-位视图"><span class="toc_mobile_items-text">5.5.1 位视图</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-5-2-页表"><span class="toc_mobile_items-text">5.5.2 页表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-5-3-地址重定位"><span class="toc_mobile_items-text">5.5.3 地址重定位</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-6-基本分段存储管理"><span class="toc_mobile_items-text">5.6 基本分段存储管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-6-1-按逻辑分段"><span class="toc_mobile_items-text">5.6.1 按逻辑分段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-6-2-记录内存使用情况的数据结构"><span class="toc_mobile_items-text">5.6.2 记录内存使用情况的数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-6-3-地址重定位"><span class="toc_mobile_items-text">5.6.3 地址重定位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-6-4-分段保护"><span class="toc_mobile_items-text">5.6.4 分段保护</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-6-7-分段共享"><span class="toc_mobile_items-text">5.6.7 分段共享</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-7-基本段也是存储管理"><span class="toc_mobile_items-text">5.7 基本段也是存储管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-1-分段-VS-分页"><span class="toc_mobile_items-text">5.7.1 分段 VS 分页</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-2-基本原理"><span class="toc_mobile_items-text">5.7.2 基本原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-3-数据结构"><span class="toc_mobile_items-text">5.7.3 数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-4-地址形式"><span class="toc_mobile_items-text">5.7.4 地址形式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-5-地址重定位"><span class="toc_mobile_items-text">5.7.5 地址重定位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-6-地址保护"><span class="toc_mobile_items-text">5.7.6 地址保护</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-7-7-段页式地址字结构的计算"><span class="toc_mobile_items-text">5.7.7 段页式地址字结构的计算</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-8-多级页表相关计算"><span class="toc_mobile_items-text">5.8 多级页表相关计算</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-8-1-例题"><span class="toc_mobile_items-text">5.8.1 例题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-8-2-多级页表的地址重定位"><span class="toc_mobile_items-text">5.8.2 多级页表的地址重定位</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-9-快表"><span class="toc_mobile_items-text">5.9 快表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-9-1-地址变换过程"><span class="toc_mobile_items-text">5.9.1 地址变换过程</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#六、虚拟存储管理篇"><span class="toc_mobile_items-text">六、虚拟存储管理篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-1-主存扩充技术"><span class="toc_mobile_items-text">6.1 主存扩充技术</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-1-1-实质"><span class="toc_mobile_items-text">6.1.1 实质</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-1-2-局部性原理"><span class="toc_mobile_items-text">6.1.2 局部性原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-1-3-覆盖技术"><span class="toc_mobile_items-text">6.1.3 覆盖技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-1-4-交换技术"><span class="toc_mobile_items-text">6.1.4 交换技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-1-5-虚拟存储技术"><span class="toc_mobile_items-text">6.1.5 虚拟存储技术</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-2-请求分页存储管理基本原理"><span class="toc_mobile_items-text">6.2 请求分页存储管理基本原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-2-1-要点"><span class="toc_mobile_items-text">6.2.1 要点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-2-2-页的位置"><span class="toc_mobile_items-text">6.2.2 页的位置</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-2-3-数据结构"><span class="toc_mobile_items-text">6.2.3 数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-2-4-地址重定位"><span class="toc_mobile_items-text">6.2.4 地址重定位</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-3-缺页中断与缺页中断处理过程"><span class="toc_mobile_items-text">6.3 缺页中断与缺页中断处理过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-3-1-缺页中断的断点压入"><span class="toc_mobile_items-text">6.3.1 缺页中断的断点压入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-3-2-缺页中断处理过程"><span class="toc_mobile_items-text">6.3.2 缺页中断处理过程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-4-页面分配算法与分配策略"><span class="toc_mobile_items-text">6.4 页面分配算法与分配策略</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-4-1-给特定进程分配合理的内存帧数"><span class="toc_mobile_items-text">6.4.1 给特定进程分配合理的内存帧数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-4-2-平均分配法"><span class="toc_mobile_items-text">6.4.2 平均分配法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-4-3-优先权分配法"><span class="toc_mobile_items-text">6.4.3 优先权分配法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-4-4-比例分配法"><span class="toc_mobile_items-text">6.4.4 比例分配法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-4-5-页面分配策略"><span class="toc_mobile_items-text">6.4.5 页面分配策略</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-5-页面置换算法概述"><span class="toc_mobile_items-text">6.5 页面置换算法概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-1-页面置换"><span class="toc_mobile_items-text">6.5.1 页面置换</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-2-页面置换策略"><span class="toc_mobile_items-text">6.5.2 页面置换策略</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-3-页面置换要点"><span class="toc_mobile_items-text">6.5.3 页面置换要点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-4-常见的页面置换算法"><span class="toc_mobile_items-text">6.5.4 常见的页面置换算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-5-OPT-最佳置换算法"><span class="toc_mobile_items-text">6.5.5 OPT 最佳置换算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-6-FIFO-先进先出页面置换算法"><span class="toc_mobile_items-text">6.5.6 FIFO 先进先出页面置换算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-7-LRU-最近最久未用算法"><span class="toc_mobile_items-text">6.5.7 LRU 最近最久未用算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-8-Clock-算法"><span class="toc_mobile_items-text">6.5.8 Clock 算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-9-改进的-Clock-算法"><span class="toc_mobile_items-text">6.5.9 改进的 Clock 算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-6-关于页面调入的进一步讨论"><span class="toc_mobile_items-text">6.6 关于页面调入的进一步讨论</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-6-1-页面什么时候调入？"><span class="toc_mobile_items-text">6.6.1 页面什么时候调入？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-6-2-页面从哪儿调入？"><span class="toc_mobile_items-text">6.6.2 页面从哪儿调入？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-6-3-页面调入需要多长时间？"><span class="toc_mobile_items-text">6.6.3 页面调入需要多长时间？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-7-页面访问时间"><span class="toc_mobile_items-text">6.7 页面访问时间</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-7-1-进程执行过程中要访问的页面有几种情况？"><span class="toc_mobile_items-text">6.7.1 进程执行过程中要访问的页面有几种情况？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-7-2-访问页面需要多长时间？"><span class="toc_mobile_items-text">6.7.2 访问页面需要多长时间？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-8-驻留集，工作集与抖动的预防"><span class="toc_mobile_items-text">6.8 驻留集，工作集与抖动的预防</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-8-1-驻留集"><span class="toc_mobile_items-text">6.8.1 驻留集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-8-2-工作集"><span class="toc_mobile_items-text">6.8.2 工作集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-8-3-抖动"><span class="toc_mobile_items-text">6.8.3 抖动</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-9-请求分段与请求段页式存储管理"><span class="toc_mobile_items-text">6.9 请求分段与请求段页式存储管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-1-请求分段存储管理的基本原理"><span class="toc_mobile_items-text">6.9.1 请求分段存储管理的基本原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-2-请求分段存储管理的数据结构"><span class="toc_mobile_items-text">6.9.2 请求分段存储管理的数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-3-请求分段存储管理的地址重定位"><span class="toc_mobile_items-text">6.9.3 请求分段存储管理的地址重定位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-4-缺段中断机制"><span class="toc_mobile_items-text">6.9.4 缺段中断机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-5-缺段中断处理程序"><span class="toc_mobile_items-text">6.9.5 缺段中断处理程序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-6-请求段页式存储管理基本原理"><span class="toc_mobile_items-text">6.9.6 请求段页式存储管理基本原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-7-请求段页式地址重定位"><span class="toc_mobile_items-text">6.9.7 请求段页式地址重定位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-9-8-请求段页式存储管理的优缺点"><span class="toc_mobile_items-text">6.9.8 请求段页式存储管理的优缺点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-10-与地址有关的计算"><span class="toc_mobile_items-text">6.10 与地址有关的计算</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-1-题一"><span class="toc_mobile_items-text">6.10.1 题一</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-2-题二"><span class="toc_mobile_items-text">6.10.2 题二</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-3-题三"><span class="toc_mobile_items-text">6.10.3 题三</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-4-题四"><span class="toc_mobile_items-text">6.10.4 题四</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-5-题五"><span class="toc_mobile_items-text">6.10.5 题五</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-6-题六"><span class="toc_mobile_items-text">6.10.6 题六</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-7-题七"><span class="toc_mobile_items-text">6.10.7 题七</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-8-题八"><span class="toc_mobile_items-text">6.10.8 题八</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#七、设备管理篇"><span class="toc_mobile_items-text">七、设备管理篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-1-设备管理概述"><span class="toc_mobile_items-text">7.1 设备管理概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-1-分类"><span class="toc_mobile_items-text">7.1.1 分类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-2-设备管理目标"><span class="toc_mobile_items-text">7.1.2 设备管理目标</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-3-设备管理功能"><span class="toc_mobile_items-text">7.1.3 设备管理功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-4-设备管理系统的构成"><span class="toc_mobile_items-text">7.1.4 设备管理系统的构成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-5-逻辑外部设备"><span class="toc_mobile_items-text">7.1.5 逻辑外部设备</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-2-设备的分配"><span class="toc_mobile_items-text">7.2 设备的分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-1-设备分配对象"><span class="toc_mobile_items-text">7.2.1 设备分配对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-2-设备分配"><span class="toc_mobile_items-text">7.2.2 设备分配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-3-系统设备分配表-SDT"><span class="toc_mobile_items-text">7.2.3 系统设备分配表 SDT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-4-设备控制表-DCT"><span class="toc_mobile_items-text">7.2.4 设备控制表 DCT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-5-控制器控制表-CCT"><span class="toc_mobile_items-text">7.2.5 控制器控制表 CCT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-6-通道控制器-CHT"><span class="toc_mobile_items-text">7.2.6 通道控制器 CHT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-7-逻辑设备映射表-LUT"><span class="toc_mobile_items-text">7.2.7 逻辑设备映射表 LUT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-8-设备分配过程"><span class="toc_mobile_items-text">7.2.8 设备分配过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-9-设备无关性"><span class="toc_mobile_items-text">7.2.9 设备无关性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-3-缓冲区的设置与管理"><span class="toc_mobile_items-text">7.3 缓冲区的设置与管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-3-1-什么是缓冲区"><span class="toc_mobile_items-text">7.3.1 什么是缓冲区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-3-2-设置缓冲区的目的"><span class="toc_mobile_items-text">7.3.2 设置缓冲区的目的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-3-4-设置缓冲区的方法"><span class="toc_mobile_items-text">7.3.4 设置缓冲区的方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-3-5-缓冲池"><span class="toc_mobile_items-text">7.3.5 缓冲池</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-4-磁盘读写速度分析"><span class="toc_mobile_items-text">7.4 磁盘读写速度分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-4-1-性能参数"><span class="toc_mobile_items-text">7.4.1 性能参数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-5-磁盘调度算法"><span class="toc_mobile_items-text">7.5 磁盘调度算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-5-1-先来先服务-FCFS"><span class="toc_mobile_items-text">7.5.1 先来先服务 FCFS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-5-2-最短寻道优先-SSTF"><span class="toc_mobile_items-text">7.5.2 最短寻道优先 SSTF</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-5-3-扫描算法-SCAN"><span class="toc_mobile_items-text">7.5.3 扫描算法 SCAN</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-5-4-循环扫描算法-CSCAN"><span class="toc_mobile_items-text">7.5.4 循环扫描算法 CSCAN</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-6-通道控制下的-I-O"><span class="toc_mobile_items-text">7.6 通道控制下的 I&#x2F;O</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-6-1-中断类别"><span class="toc_mobile_items-text">7.6.1 中断类别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-6-2-中断处理程序的处理过程"><span class="toc_mobile_items-text">7.6.2 中断处理程序的处理过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-6-3-通道"><span class="toc_mobile_items-text">7.6.3 通道</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-7-虚拟设备"><span class="toc_mobile_items-text">7.7 虚拟设备</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-7-1-Spooling-技术"><span class="toc_mobile_items-text">7.7.1 Spooling 技术</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#八、文件管理篇"><span class="toc_mobile_items-text">八、文件管理篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-1-文件与文件管理概述"><span class="toc_mobile_items-text">8.1 文件与文件管理概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-1-1-什么是文件"><span class="toc_mobile_items-text">8.1.1 什么是文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-1-2-文件的内部形式"><span class="toc_mobile_items-text">8.1.2 文件的内部形式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-1-3-文件管理系统-FMS"><span class="toc_mobile_items-text">8.1.3 文件管理系统 FMS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-1-4-文件管理系统的目标"><span class="toc_mobile_items-text">8.1.4 文件管理系统的目标</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-1-5-文件管理系统的管理功能"><span class="toc_mobile_items-text">8.1.5 文件管理系统的管理功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-1-6-公认一个好的-FMS-应具有以下特点"><span class="toc_mobile_items-text">8.1.6 公认一个好的 FMS 应具有以下特点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-2-文件、目录、文件目录、目录文件"><span class="toc_mobile_items-text">8.2 文件、目录、文件目录、目录文件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-2-1-DOS-目录文件"><span class="toc_mobile_items-text">8.2.1 DOS 目录文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-2-1-Unix-目录文件"><span class="toc_mobile_items-text">8.2.1 Unix 目录文件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-3-文件的逻辑结构"><span class="toc_mobile_items-text">8.3 文件的逻辑结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-3-1-流式文件"><span class="toc_mobile_items-text">8.3.1 流式文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-3-2-记录式文件"><span class="toc_mobile_items-text">8.3.2 记录式文件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-4-文件的物理结构"><span class="toc_mobile_items-text">8.4 文件的物理结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-1-顺序存储结构"><span class="toc_mobile_items-text">8.4.1 顺序存储结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-2-隐式链式存储结构"><span class="toc_mobile_items-text">8.4.2 隐式链式存储结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-3-显式链接存储方式"><span class="toc_mobile_items-text">8.4.3 显式链接存储方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-4-索引存储结构"><span class="toc_mobile_items-text">8.4.4 索引存储结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-5-二级索引存储结构"><span class="toc_mobile_items-text">8.4.5 二级索引存储结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-6-多级混合索引结构"><span class="toc_mobile_items-text">8.4.6 多级混合索引结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-4-7-Unix-中的一个文件"><span class="toc_mobile_items-text">8.4.7 Unix 中的一个文件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-5-文件目录的管理与查询"><span class="toc_mobile_items-text">8.5 文件目录的管理与查询</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-5-1-文件目录内容"><span class="toc_mobile_items-text">8.5.1 文件目录内容</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-5-2-文件目录管理的主要目的"><span class="toc_mobile_items-text">8.5.2 文件目录管理的主要目的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-5-3-单级文件目录"><span class="toc_mobile_items-text">8.5.3 单级文件目录</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-5-4-两级文件目录"><span class="toc_mobile_items-text">8.5.4 两级文件目录</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-5-5-多级文件目录"><span class="toc_mobile_items-text">8.5.5 多级文件目录</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-6-文件存储空间的管理"><span class="toc_mobile_items-text">8.6 文件存储空间的管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-6-1-具体功能"><span class="toc_mobile_items-text">8.6.1 具体功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-6-2-分配和回收"><span class="toc_mobile_items-text">8.6.2 分配和回收</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-6-3-空闲区表-链"><span class="toc_mobile_items-text">8.6.3 空闲区表&#x2F;链</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-6-4-空闲块链"><span class="toc_mobile_items-text">8.6.4 空闲块链</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-6-5-位示图"><span class="toc_mobile_items-text">8.6.5 位示图</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-6-6-成组链接存储方式"><span class="toc_mobile_items-text">8.6.6 成组链接存储方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-7-文件共享、保护与保密"><span class="toc_mobile_items-text">8.7 文件共享、保护与保密</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-7-1-静态共享"><span class="toc_mobile_items-text">8.7.1 静态共享</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-7-2-动态共享"><span class="toc_mobile_items-text">8.7.2 动态共享</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-7-3-文件保护"><span class="toc_mobile_items-text">8.7.3 文件保护</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-7-4-文件保密"><span class="toc_mobile_items-text">8.7.4 文件保密</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-7-5-系统安全"><span class="toc_mobile_items-text">8.7.5 系统安全</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、计算机操作系统概念"><span class="toc-text">一、计算机操作系统概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-操作系统处理方式"><span class="toc-text">1.1 操作系统处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-批处理方式"><span class="toc-text">1.1.1 批处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-分时处理方式"><span class="toc-text">1.1.2 分时处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-实时处理方式"><span class="toc-text">1.1.3 实时处理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-操作系统的功能组成"><span class="toc-text">1.2 操作系统的功能组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-用户和接口管理"><span class="toc-text">1.2.1 用户和接口管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-处理机管理"><span class="toc-text">1.2.2 处理机管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-线程控制和管理"><span class="toc-text">1.2.3 线程控制和管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-存储管理"><span class="toc-text">1.2.4 存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-设备管理"><span class="toc-text">1.2.5 设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-文件管理"><span class="toc-text">1.2.6 文件管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-内核"><span class="toc-text">1.2.1 内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-PC-机-DOS-操作系统启动过程"><span class="toc-text">1.2.2 PC 机 DOS 操作系统启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-操作系统的主要特征"><span class="toc-text">1.3 操作系统的主要特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-并发性"><span class="toc-text">1.3.1 并发性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、作业与作业管理概述"><span class="toc-text">二、作业与作业管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-什么是作业"><span class="toc-text">2.1 什么是作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-用户管理"><span class="toc-text">2.1.1 用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-接口管理"><span class="toc-text">2.1.2 接口管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-批作业的管理控制与调度"><span class="toc-text">2.1.3 批作业的管理控制与调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-操作系统接口"><span class="toc-text">2.2 操作系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-作业控制说明语言"><span class="toc-text">2.2.1 作业控制说明语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-联机命令接口"><span class="toc-text">2.2.2 联机命令接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-程序级接口"><span class="toc-text">2.2.3 程序级接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-CPU-的两种工作状态"><span class="toc-text">2.2.4 CPU 的两种工作状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-系统调用"><span class="toc-text">2.3 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-作业的管理控制"><span class="toc-text">2.4 作业的管理控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-批作业的状态管理"><span class="toc-text">2.4.1 批作业的状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-批作业控制块的描述和组织"><span class="toc-text">2.4.2 批作业控制块的描述和组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-不同的作业-I-O-方式"><span class="toc-text">2.4.3 不同的作业 I&#x2F;O 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-不同的作业控制方式"><span class="toc-text">2.4.4 不同的作业控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-作业调度"><span class="toc-text">2.5 作业调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-先来先服务-FCFS-调度算法"><span class="toc-text">2.5.1 先来先服务 FCFS 调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-最短作业优先-SJF-调度算法"><span class="toc-text">2.5.2 最短作业优先 SJF 调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-最高相应比优先-HRF-调度算法"><span class="toc-text">2.5.3 最高相应比优先 HRF 调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-最高优先级-HPF-调度算法"><span class="toc-text">2.5.4 最高优先级 HPF 调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-均衡调度算法"><span class="toc-text">2.5.5 均衡调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-作业调度性能的衡量准则"><span class="toc-text">2.5.6 作业调度性能的衡量准则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、进程管理与处理机调度"><span class="toc-text">三、进程管理与处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-初识进程"><span class="toc-text">3.1 初识进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-什么是进程"><span class="toc-text">3.1.1 什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-操作系统为什么要进入进程"><span class="toc-text">3.1.2 操作系统为什么要进入进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-进程与程序、作业有何区别和联系"><span class="toc-text">3.1.3 进程与程序、作业有何区别和联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-进程与进程管理模块"><span class="toc-text">3.2 进程与进程管理模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-进程的特征"><span class="toc-text">3.2.1 进程的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-进程管理模块的主要功能"><span class="toc-text">3.2.2 进程管理模块的主要功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-进程状态转换"><span class="toc-text">3.3 进程状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-进程的三种基本状态"><span class="toc-text">3.3.1 进程的三种基本状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-进程的创建与撤销"><span class="toc-text">3.4 进程的创建与撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-什么是原语"><span class="toc-text">3.4.1 什么是原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-进程创建原语"><span class="toc-text">3.4.2 进程创建原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-撤销进程"><span class="toc-text">3.4.3 撤销进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-父进程与子进程"><span class="toc-text">3.5 父进程与子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-fork-说明"><span class="toc-text">3.5.1 fork() 说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-进程状态转换控制原语"><span class="toc-text">3.6 进程状态转换控制原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-阻塞原语"><span class="toc-text">3.6.1 阻塞原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-唤醒原语"><span class="toc-text">3.6.2 唤醒原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-挂起原语"><span class="toc-text">3.6.3 挂起原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4-激活原语"><span class="toc-text">3.6.4 激活原语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-进程调度"><span class="toc-text">2.7 进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-非抢占式调度"><span class="toc-text">2.7.1 非抢占式调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-抢占式调度"><span class="toc-text">2.7.2 抢占式调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-进程调度算法"><span class="toc-text">3.7.3 进程调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-实时任务调度"><span class="toc-text">2.8 实时任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-非周期实时任务的分类及调度方法"><span class="toc-text">2.8.1 非周期实时任务的分类及调度方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-周期性实时任务"><span class="toc-text">2.8.2 周期性实时任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-线程的引入"><span class="toc-text">2.9 线程的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-线程是什么"><span class="toc-text">2.9.1 线程是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-线程的实现"><span class="toc-text">2.9.2 线程的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-3-进程和线程的区别"><span class="toc-text">2.9.3 进程和线程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-处理机的四级调度"><span class="toc-text">2.10 处理机的四级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-1-典型的三级调度"><span class="toc-text">2.10.1 典型的三级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-2-线程调度"><span class="toc-text">2.10.2 线程调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、进程并发控制篇"><span class="toc-text">四、进程并发控制篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-互斥与同步的基本概念"><span class="toc-text">4.1 互斥与同步的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-并发"><span class="toc-text">4.1.1 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-并发带来的问题"><span class="toc-text">4.1.2 并发带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-互斥"><span class="toc-text">4.1.3 互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-同步"><span class="toc-text">4.1.4 同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-临界资源"><span class="toc-text">4.1.5 临界资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-临界区"><span class="toc-text">4.1.6 临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-死锁"><span class="toc-text">4.1.7 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-活锁"><span class="toc-text">4.1.8 活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-饥饿"><span class="toc-text">4.1.9 饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-10-原子操作"><span class="toc-text">4.1.10 原子操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-软件方法解决进程互斥"><span class="toc-text">4.2 软件方法解决进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-信号量机制解决同步互斥问题"><span class="toc-text">4.3 信号量机制解决同步互斥问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-信号量机制实现要素"><span class="toc-text">4.3.1 信号量机制实现要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-记录型信号量"><span class="toc-text">4.3.2 记录型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-解决互斥问题"><span class="toc-text">4.3.3 解决互斥问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-解决同步问题"><span class="toc-text">4.3.4 解决同步问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-互斥、同步解决方法之异同分析"><span class="toc-text">4.3.5 互斥、同步解决方法之异同分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-6-记录型信号量解决问题的步骤"><span class="toc-text">4.3.6 记录型信号量解决问题的步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-生产者与消费者问题"><span class="toc-text">4.4 生产者与消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-经典生产者-消费者问题"><span class="toc-text">4.4.3 经典生产者-消费者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-读者写者问题"><span class="toc-text">4.5 读者写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-理发师问题"><span class="toc-text">4.6 理发师问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-哲学家就餐问题"><span class="toc-text">4.7 哲学家就餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-错误算法"><span class="toc-text">4.7.1 错误算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-算法一"><span class="toc-text">4.7.1 算法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-算法二"><span class="toc-text">4.7.2 算法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-算法三"><span class="toc-text">4.7.4 算法三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-管程机制"><span class="toc-text">4.8 管程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-管程解决生产者与消费者问题"><span class="toc-text">4.8.1 管程解决生产者与消费者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-死锁的发生与描述"><span class="toc-text">4.9 死锁的发生与描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-现象"><span class="toc-text">4.9.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-死锁的危害"><span class="toc-text">4.9.2 死锁的危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3-产生死锁的原因"><span class="toc-text">4.9.3 产生死锁的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-4-必要条件"><span class="toc-text">4.9.4 必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-5-资源请求分配图"><span class="toc-text">4.9.5 资源请求分配图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-6-资源请求分配矩阵"><span class="toc-text">4.9.6 资源请求分配矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-7-死锁的解决方法"><span class="toc-text">4.9.7 死锁的解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-死锁的预防"><span class="toc-text">4.10 死锁的预防</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-死锁避免"><span class="toc-text">4.11 死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-1-银行家算法的思路"><span class="toc-text">4.11.1 银行家算法的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-2-银行家算法的数据结构"><span class="toc-text">4.11.2 银行家算法的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-3-银行家算法的步骤"><span class="toc-text">4.11.3 银行家算法的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-4-银行家算法的应用"><span class="toc-text">4.11.4 银行家算法的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、存储管理篇"><span class="toc-text">五、存储管理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-存储管理概述"><span class="toc-text">5.1 存储管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-内存的分配和回收"><span class="toc-text">5.1.1 内存的分配和回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-地址重定位"><span class="toc-text">5.1.2 地址重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-地址共享与保护"><span class="toc-text">5.1.3 地址共享与保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-地址扩充"><span class="toc-text">5.1.4 地址扩充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-存储管理方法"><span class="toc-text">5.1.5 存储管理方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-程序的编译链接与地址重定位"><span class="toc-text">5.2 程序的编译链接与地址重定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-连续分区存储结构"><span class="toc-text">5.3 连续分区存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-单分区方式"><span class="toc-text">5.3.1 单分区方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-多分区方式"><span class="toc-text">5.3.2 多分区方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-主存分配表"><span class="toc-text">5.3.3 主存分配表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-主存分配算法"><span class="toc-text">5.3.4 主存分配算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-固定多分区存储管理"><span class="toc-text">5.4 固定多分区存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-单分区存储管理"><span class="toc-text">5.4.1 单分区存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-固定多分区存储管理"><span class="toc-text">5.4.2 固定多分区存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-动态多分区存储管理（可变分区）"><span class="toc-text">5.4.3 动态多分区存储管理（可变分区）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-基本分页存储管理"><span class="toc-text">5.5 基本分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-位视图"><span class="toc-text">5.5.1 位视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-页表"><span class="toc-text">5.5.2 页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-地址重定位"><span class="toc-text">5.5.3 地址重定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-基本分段存储管理"><span class="toc-text">5.6 基本分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-按逻辑分段"><span class="toc-text">5.6.1 按逻辑分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-记录内存使用情况的数据结构"><span class="toc-text">5.6.2 记录内存使用情况的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-地址重定位"><span class="toc-text">5.6.3 地址重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-分段保护"><span class="toc-text">5.6.4 分段保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-7-分段共享"><span class="toc-text">5.6.7 分段共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-基本段也是存储管理"><span class="toc-text">5.7 基本段也是存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-分段-VS-分页"><span class="toc-text">5.7.1 分段 VS 分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-基本原理"><span class="toc-text">5.7.2 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-3-数据结构"><span class="toc-text">5.7.3 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-4-地址形式"><span class="toc-text">5.7.4 地址形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-5-地址重定位"><span class="toc-text">5.7.5 地址重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-6-地址保护"><span class="toc-text">5.7.6 地址保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-7-段页式地址字结构的计算"><span class="toc-text">5.7.7 段页式地址字结构的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-多级页表相关计算"><span class="toc-text">5.8 多级页表相关计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-例题"><span class="toc-text">5.8.1 例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-多级页表的地址重定位"><span class="toc-text">5.8.2 多级页表的地址重定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-快表"><span class="toc-text">5.9 快表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-1-地址变换过程"><span class="toc-text">5.9.1 地址变换过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、虚拟存储管理篇"><span class="toc-text">六、虚拟存储管理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-主存扩充技术"><span class="toc-text">6.1 主存扩充技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-实质"><span class="toc-text">6.1.1 实质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-局部性原理"><span class="toc-text">6.1.2 局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-覆盖技术"><span class="toc-text">6.1.3 覆盖技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-交换技术"><span class="toc-text">6.1.4 交换技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-虚拟存储技术"><span class="toc-text">6.1.5 虚拟存储技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-请求分页存储管理基本原理"><span class="toc-text">6.2 请求分页存储管理基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-要点"><span class="toc-text">6.2.1 要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-页的位置"><span class="toc-text">6.2.2 页的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-数据结构"><span class="toc-text">6.2.3 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-地址重定位"><span class="toc-text">6.2.4 地址重定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-缺页中断与缺页中断处理过程"><span class="toc-text">6.3 缺页中断与缺页中断处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-缺页中断的断点压入"><span class="toc-text">6.3.1 缺页中断的断点压入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-缺页中断处理过程"><span class="toc-text">6.3.2 缺页中断处理过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-页面分配算法与分配策略"><span class="toc-text">6.4 页面分配算法与分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-给特定进程分配合理的内存帧数"><span class="toc-text">6.4.1 给特定进程分配合理的内存帧数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-平均分配法"><span class="toc-text">6.4.2 平均分配法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-优先权分配法"><span class="toc-text">6.4.3 优先权分配法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4-比例分配法"><span class="toc-text">6.4.4 比例分配法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5-页面分配策略"><span class="toc-text">6.4.5 页面分配策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-页面置换算法概述"><span class="toc-text">6.5 页面置换算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-页面置换"><span class="toc-text">6.5.1 页面置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-页面置换策略"><span class="toc-text">6.5.2 页面置换策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-页面置换要点"><span class="toc-text">6.5.3 页面置换要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4-常见的页面置换算法"><span class="toc-text">6.5.4 常见的页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-5-OPT-最佳置换算法"><span class="toc-text">6.5.5 OPT 最佳置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-6-FIFO-先进先出页面置换算法"><span class="toc-text">6.5.6 FIFO 先进先出页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-7-LRU-最近最久未用算法"><span class="toc-text">6.5.7 LRU 最近最久未用算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-8-Clock-算法"><span class="toc-text">6.5.8 Clock 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-9-改进的-Clock-算法"><span class="toc-text">6.5.9 改进的 Clock 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-关于页面调入的进一步讨论"><span class="toc-text">6.6 关于页面调入的进一步讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-页面什么时候调入？"><span class="toc-text">6.6.1 页面什么时候调入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-页面从哪儿调入？"><span class="toc-text">6.6.2 页面从哪儿调入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-页面调入需要多长时间？"><span class="toc-text">6.6.3 页面调入需要多长时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-页面访问时间"><span class="toc-text">6.7 页面访问时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-进程执行过程中要访问的页面有几种情况？"><span class="toc-text">6.7.1 进程执行过程中要访问的页面有几种情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-访问页面需要多长时间？"><span class="toc-text">6.7.2 访问页面需要多长时间？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-驻留集，工作集与抖动的预防"><span class="toc-text">6.8 驻留集，工作集与抖动的预防</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-驻留集"><span class="toc-text">6.8.1 驻留集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-2-工作集"><span class="toc-text">6.8.2 工作集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-3-抖动"><span class="toc-text">6.8.3 抖动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-请求分段与请求段页式存储管理"><span class="toc-text">6.9 请求分段与请求段页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-1-请求分段存储管理的基本原理"><span class="toc-text">6.9.1 请求分段存储管理的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-2-请求分段存储管理的数据结构"><span class="toc-text">6.9.2 请求分段存储管理的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-3-请求分段存储管理的地址重定位"><span class="toc-text">6.9.3 请求分段存储管理的地址重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-4-缺段中断机制"><span class="toc-text">6.9.4 缺段中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-5-缺段中断处理程序"><span class="toc-text">6.9.5 缺段中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-6-请求段页式存储管理基本原理"><span class="toc-text">6.9.6 请求段页式存储管理基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-7-请求段页式地址重定位"><span class="toc-text">6.9.7 请求段页式地址重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-8-请求段页式存储管理的优缺点"><span class="toc-text">6.9.8 请求段页式存储管理的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-与地址有关的计算"><span class="toc-text">6.10 与地址有关的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-题一"><span class="toc-text">6.10.1 题一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-题二"><span class="toc-text">6.10.2 题二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-3-题三"><span class="toc-text">6.10.3 题三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-4-题四"><span class="toc-text">6.10.4 题四</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-5-题五"><span class="toc-text">6.10.5 题五</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-6-题六"><span class="toc-text">6.10.6 题六</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-7-题七"><span class="toc-text">6.10.7 题七</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-8-题八"><span class="toc-text">6.10.8 题八</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、设备管理篇"><span class="toc-text">七、设备管理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-设备管理概述"><span class="toc-text">7.1 设备管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-分类"><span class="toc-text">7.1.1 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-设备管理目标"><span class="toc-text">7.1.2 设备管理目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-设备管理功能"><span class="toc-text">7.1.3 设备管理功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-设备管理系统的构成"><span class="toc-text">7.1.4 设备管理系统的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-逻辑外部设备"><span class="toc-text">7.1.5 逻辑外部设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-设备的分配"><span class="toc-text">7.2 设备的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-设备分配对象"><span class="toc-text">7.2.1 设备分配对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-设备分配"><span class="toc-text">7.2.2 设备分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-系统设备分配表-SDT"><span class="toc-text">7.2.3 系统设备分配表 SDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-设备控制表-DCT"><span class="toc-text">7.2.4 设备控制表 DCT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-控制器控制表-CCT"><span class="toc-text">7.2.5 控制器控制表 CCT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6-通道控制器-CHT"><span class="toc-text">7.2.6 通道控制器 CHT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-7-逻辑设备映射表-LUT"><span class="toc-text">7.2.7 逻辑设备映射表 LUT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-8-设备分配过程"><span class="toc-text">7.2.8 设备分配过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-9-设备无关性"><span class="toc-text">7.2.9 设备无关性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-缓冲区的设置与管理"><span class="toc-text">7.3 缓冲区的设置与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-什么是缓冲区"><span class="toc-text">7.3.1 什么是缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-设置缓冲区的目的"><span class="toc-text">7.3.2 设置缓冲区的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-设置缓冲区的方法"><span class="toc-text">7.3.4 设置缓冲区的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-5-缓冲池"><span class="toc-text">7.3.5 缓冲池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-磁盘读写速度分析"><span class="toc-text">7.4 磁盘读写速度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-性能参数"><span class="toc-text">7.4.1 性能参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-磁盘调度算法"><span class="toc-text">7.5 磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-先来先服务-FCFS"><span class="toc-text">7.5.1 先来先服务 FCFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-最短寻道优先-SSTF"><span class="toc-text">7.5.2 最短寻道优先 SSTF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-扫描算法-SCAN"><span class="toc-text">7.5.3 扫描算法 SCAN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4-循环扫描算法-CSCAN"><span class="toc-text">7.5.4 循环扫描算法 CSCAN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-通道控制下的-I-O"><span class="toc-text">7.6 通道控制下的 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-中断类别"><span class="toc-text">7.6.1 中断类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-中断处理程序的处理过程"><span class="toc-text">7.6.2 中断处理程序的处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-通道"><span class="toc-text">7.6.3 通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-虚拟设备"><span class="toc-text">7.7 虚拟设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-1-Spooling-技术"><span class="toc-text">7.7.1 Spooling 技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、文件管理篇"><span class="toc-text">八、文件管理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-文件与文件管理概述"><span class="toc-text">8.1 文件与文件管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-什么是文件"><span class="toc-text">8.1.1 什么是文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-文件的内部形式"><span class="toc-text">8.1.2 文件的内部形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-文件管理系统-FMS"><span class="toc-text">8.1.3 文件管理系统 FMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4-文件管理系统的目标"><span class="toc-text">8.1.4 文件管理系统的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5-文件管理系统的管理功能"><span class="toc-text">8.1.5 文件管理系统的管理功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-6-公认一个好的-FMS-应具有以下特点"><span class="toc-text">8.1.6 公认一个好的 FMS 应具有以下特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-文件、目录、文件目录、目录文件"><span class="toc-text">8.2 文件、目录、文件目录、目录文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-DOS-目录文件"><span class="toc-text">8.2.1 DOS 目录文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-Unix-目录文件"><span class="toc-text">8.2.1 Unix 目录文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-文件的逻辑结构"><span class="toc-text">8.3 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-流式文件"><span class="toc-text">8.3.1 流式文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-记录式文件"><span class="toc-text">8.3.2 记录式文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-文件的物理结构"><span class="toc-text">8.4 文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-顺序存储结构"><span class="toc-text">8.4.1 顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-隐式链式存储结构"><span class="toc-text">8.4.2 隐式链式存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3-显式链接存储方式"><span class="toc-text">8.4.3 显式链接存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-4-索引存储结构"><span class="toc-text">8.4.4 索引存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-5-二级索引存储结构"><span class="toc-text">8.4.5 二级索引存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-6-多级混合索引结构"><span class="toc-text">8.4.6 多级混合索引结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-7-Unix-中的一个文件"><span class="toc-text">8.4.7 Unix 中的一个文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-文件目录的管理与查询"><span class="toc-text">8.5 文件目录的管理与查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-文件目录内容"><span class="toc-text">8.5.1 文件目录内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2-文件目录管理的主要目的"><span class="toc-text">8.5.2 文件目录管理的主要目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-3-单级文件目录"><span class="toc-text">8.5.3 单级文件目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-4-两级文件目录"><span class="toc-text">8.5.4 两级文件目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-5-多级文件目录"><span class="toc-text">8.5.5 多级文件目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-文件存储空间的管理"><span class="toc-text">8.6 文件存储空间的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-1-具体功能"><span class="toc-text">8.6.1 具体功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-2-分配和回收"><span class="toc-text">8.6.2 分配和回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-3-空闲区表-链"><span class="toc-text">8.6.3 空闲区表&#x2F;链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-4-空闲块链"><span class="toc-text">8.6.4 空闲块链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-5-位示图"><span class="toc-text">8.6.5 位示图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-6-成组链接存储方式"><span class="toc-text">8.6.6 成组链接存储方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-文件共享、保护与保密"><span class="toc-text">8.7 文件共享、保护与保密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-1-静态共享"><span class="toc-text">8.7.1 静态共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-2-动态共享"><span class="toc-text">8.7.2 动态共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-3-文件保护"><span class="toc-text">8.7.3 文件保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-4-文件保密"><span class="toc-text">8.7.4 文件保密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-5-系统安全"><span class="toc-text">8.7.5 系统安全</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://5b0988e595225.cdn.sohucs.com/images/20190831/84729f5c5bb346208416445feb485df6.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">Operating_System</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Note/">Note</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>Word count:</span><span class="word-count">29.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>Reading time: 89 min</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="一、计算机操作系统概念"><a href="#一、计算机操作系统概念" class="headerlink" title="一、计算机操作系统概念"></a>一、计算机操作系统概念</h1><p><a href="http://narpro.top/img/image-20200403104425661.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403104425661" class="fancybox"><img alt="image-20200403104425661" title="image-20200403104425661" data-src="http://narpro.top/img/image-20200403104425661.png" class="lazyload"></a></p>
<blockquote>
<p>管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效的使用计算机体哦那个良好的运行环境的一种系统软件</p>
<ul>
<li>方便用户使用</li>
<li>管理系统资源</li>
<li>提高系统效率</li>
<li>扩大机器功能</li>
<li>构筑开放环境</li>
</ul>
<p>资源管理技术：</p>
<ul>
<li><strong>资源复用</strong>：解决物理资源数量的不足<ul>
<li>空分复用：该资源可以进一步分割成更多和更小的单位供进行使用，如内存空间</li>
<li>时分复用：并不把资源进一步分割成更小的单位，进程可在一个时间段内独占使用整个物理资源，如 <code>CPU</code></li>
</ul>
</li>
<li><strong>资源虚拟</strong>：解决物理资源不足，提高服务能力和水平<ul>
<li>是对资源进行转化，模拟或整合，把物理上的一个资源变成逻辑上的多个对应物，或把物理上多个变成逻辑上的一个</li>
<li>空分复用分割实际存在的物理资源，虚拟实现虚构假象的虚拟同类资源</li>
<li>资源虚拟的例子：虚拟设备，虚拟主存，虚拟文件，虚拟屏幕，虚拟信道</li>
</ul>
</li>
<li><strong>资源抽象</strong>：处理系统的复杂性，解决资源的易用性<ul>
<li>资源抽象用于处理系统的复杂性，重点解决资源的易用性</li>
<li>资源抽象是指通过从创建软件来屏蔽硬件资源物理特性和接口细节，简化对硬件资源的操作，控制和使用的一类技术</li>
<li>单机资源抽象与多级资源抽象</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="1-1-操作系统处理方式"><a href="#1-1-操作系统处理方式" class="headerlink" title="1.1 操作系统处理方式"></a>1.1 操作系统处理方式</h2><h3 id="1-1-1-批处理方式"><a href="#1-1-1-批处理方式" class="headerlink" title="1.1.1 批处理方式"></a>1.1.1 批处理方式</h3><blockquote>
<p>特点：成批提交，成批处理</p>
<ul>
<li>接受一批作业到外存，组织成作业流</li>
<li>自动控制一批作业的内存装入和运行过程</li>
<li>全部完成后再将结果反馈给用户</li>
</ul>
<p>分类：</p>
<ul>
<li><p>单道批处理程序</p>
<p><a href="http://narpro.top/img/image-20200403112758177.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403112758177" class="fancybox"><img alt="image-20200403112758177" title="image-20200403112758177" data-src="http://narpro.top/img/image-20200403112758177.png" class="lazyload"></a></p>
<ul>
<li>成批提交：操作员集中一批用户提交的作业通过输入设备输入到磁带上</li>
<li>单道装入：管理程序自动把磁带上的一个作业装入主存，并把控制权交给作业</li>
<li>顺序运行：该作业执行完成后把控制权交回管理程序，管理程序再调入磁带上的下一个作业</li>
</ul>
</li>
<li><p>多道批处理程序</p>
<p><a href="http://narpro.top/img/image-20200403113210279.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403113210279" class="fancybox"><img alt="image-20200403113210279" title="image-20200403113210279" data-src="http://narpro.top/img/image-20200403113210279.png" class="lazyload"></a></p>
<ul>
<li>成批提交，多道装入</li>
<li>系统资源利用率提高，系统吞吐量变大</li>
<li>成批处理过程中无交互性，用户作业的等待时间长</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-1-2-分时处理方式"><a href="#1-1-2-分时处理方式" class="headerlink" title="1.1.2 分时处理方式"></a>1.1.2 分时处理方式</h3><blockquote>
<p>又叫会话型处理，是在多道程序设计基础上发展起来的一种处理方式，强调交互性，采用分时技术，即将 <code>CPU</code> 时间划分为多个时间片，每个时间片轮流执行为用户程序</p>
<p><a href="http://narpro.top/img/image-20200403113611137.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403113611137" class="fancybox"><img alt="image-20200403113611137" title="image-20200403113611137" data-src="http://narpro.top/img/image-20200403113611137.png" class="lazyload"></a></p>
<p>基本特征：</p>
<ul>
<li>同时性</li>
<li>交互性</li>
<li>独占性</li>
<li>及时性</li>
</ul>
</blockquote>
<h3 id="1-1-3-实时处理方式"><a href="#1-1-3-实时处理方式" class="headerlink" title="1.1.3 实时处理方式"></a>1.1.3 实时处理方式</h3><blockquote>
<p>硬实时系统：对时间严格约束</p>
<p>软实时系统：对时间限制稍弱一点</p>
<p>软实时的常见系统：</p>
<ul>
<li>过程控制系统</li>
<li>信息查询系统</li>
<li>事务处理系统</li>
</ul>
</blockquote>
<h2 id="1-2-操作系统的功能组成"><a href="#1-2-操作系统的功能组成" class="headerlink" title="1.2 操作系统的功能组成"></a>1.2 操作系统的功能组成</h2><h3 id="1-2-1-用户和接口管理"><a href="#1-2-1-用户和接口管理" class="headerlink" title="1.2.1 用户和接口管理"></a>1.2.1 用户和接口管理</h3><blockquote>
<p>负责用户身份验证，操纵权限管理以及各种人机接口的实现</p>
<ul>
<li>用户管理</li>
<li>用户组管理</li>
<li>联机接口管理</li>
<li>脱机接口管理</li>
<li>程序级接口管理</li>
</ul>
</blockquote>
<h3 id="1-2-2-处理机管理"><a href="#1-2-2-处理机管理" class="headerlink" title="1.2.2 处理机管理"></a>1.2.2 处理机管理</h3><blockquote>
<p>围绕 <code>CPU</code> 的调度，负责管理、控制用户程序的动态执行过程</p>
<ul>
<li>进程控制和管理</li>
<li>进程同步和互斥</li>
<li>进程通信</li>
<li>进程思索</li>
</ul>
</blockquote>
<h3 id="1-2-3-线程控制和管理"><a href="#1-2-3-线程控制和管理" class="headerlink" title="1.2.3 线程控制和管理"></a>1.2.3 线程控制和管理</h3><blockquote>
<ul>
<li>四级调度</li>
</ul>
</blockquote>
<h3 id="1-2-4-存储管理"><a href="#1-2-4-存储管理" class="headerlink" title="1.2.4 存储管理"></a>1.2.4 存储管理</h3><blockquote>
<p>负责为正在运行的程序分配内存空间，并实现地址和空间有关的管理功能</p>
<ul>
<li>内存分配</li>
<li>地址转换</li>
<li>存储保护</li>
<li>内存共享</li>
<li>存储扩充</li>
</ul>
</blockquote>
<h3 id="1-2-5-设备管理"><a href="#1-2-5-设备管理" class="headerlink" title="1.2.5 设备管理"></a>1.2.5 设备管理</h3><blockquote>
<p>负责外存和 <code>I/O</code> 设备的分配、驱动和调度控制，以及实现外设读写的相关机制</p>
<ul>
<li>设备的分配和回收</li>
<li>设备的驱动调度</li>
<li>实现逻辑设备到物理设备之间的映射</li>
<li>提供设备终端处理</li>
<li>提供缓冲区管理</li>
<li>实现虚拟设备</li>
</ul>
</blockquote>
<h3 id="1-2-6-文件管理"><a href="#1-2-6-文件管理" class="headerlink" title="1.2.6 文件管理"></a>1.2.6 文件管理</h3><blockquote>
<p>负责文件的建立、存取、目录管理、共享保护以及文件存储空间的管理</p>
<ul>
<li>提供文件的逻辑组织方法</li>
<li>提供文件的物理组织方法</li>
<li>提供文件的存取和使用发给发</li>
<li>实现文件的目录管理</li>
<li>实现文件的共享和安全性控制</li>
<li>实现文件的存储空间管理</li>
<li>网络与通信管理</li>
</ul>
</blockquote>
<h3 id="1-2-1-内核"><a href="#1-2-1-内核" class="headerlink" title="1.2.1 内核"></a>1.2.1 内核</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200403115652649.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403115652649" class="fancybox"><img alt="image-20200403115652649" title="image-20200403115652649" data-src="http://narpro.top/img/image-20200403115652649.png" class="lazyload"></a></p>
<ul>
<li>是作为可信软件来提供支持进程并发执行的基本功能和基本操作的一组程序，如始终管理，<code>CPU</code> 调度，内存分配等</li>
<li>内核通常驻留再内核空间，运行于核心态，具有访问硬设备和所有主存空间的权限</li>
<li>内核是由中断驱动的</li>
<li>内核是不可抢占的</li>
<li>内核可以在屏蔽中断状态下执行</li>
<li>内核可以使用特权指令</li>
</ul>
</blockquote>
<h3 id="1-2-2-PC-机-DOS-操作系统启动过程"><a href="#1-2-2-PC-机-DOS-操作系统启动过程" class="headerlink" title="1.2.2 PC 机 DOS 操作系统启动过程"></a>1.2.2 <strong><code>PC</code> 机 <code>DOS</code> 操作系统启动过程</strong></h3><blockquote>
<p><a href="http://narpro.top/img/image-20200403120343194.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403120343194" class="fancybox"><img alt="image-20200403120343194" title="image-20200403120343194" data-src="http://narpro.top/img/image-20200403120343194.png" class="lazyload"></a></p>
<ul>
<li>加电，<code>CPU</code> 执行 <code>BIOS</code> 程序模块，该模块中的 <strong>硬件诊断程序</strong> 投入运行，检查硬件配置和设备状态，并在屏幕上显示存储容量和各个设备的链接情况</li>
<li>外存储器上的 <strong>操作系统引导程序</strong> 被自动写入内存，立即投入运行，把操作系统的内核部分一一装入内存，将 <code>CPU</code> 控制权交给内核</li>
<li>内核运行做一些必要的初始化工作，比如内存分区，建立链表，创建必须的系统进程</li>
<li>系统安排停当后显示系统提示符，并执行 <strong><code>CPU</code> 闲逛</strong> 程序，等待用户到来</li>
</ul>
</blockquote>
<h2 id="1-3-操作系统的主要特征"><a href="#1-3-操作系统的主要特征" class="headerlink" title="1.3 操作系统的主要特征"></a>1.3 操作系统的主要特征</h2><h3 id="1-3-1-并发性"><a href="#1-3-1-并发性" class="headerlink" title="1.3.1 并发性"></a>1.3.1 并发性</h3><blockquote>
<p>在一个时间段内，多个程序处于宏观的运行状态，并发推进</p>
<p><a href="http://narpro.top/img/image-20200403120621908.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403120621908" class="fancybox"><img alt="image-20200403120621908" title="image-20200403120621908" data-src="http://narpro.top/img/image-20200403120621908.png" class="lazyload"></a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>在一个时间段内，多个程序（进程）并发推进，共享系统资源</li>
<li>发挥并发性能够消除系统中部件和部件之间的互相等待，有效地改善系统资源的利用率</li>
</ul>
<p><strong>必须解决的问题</strong>：</p>
<ul>
<li>如何从一个进程切换到另一个进程</li>
<li>如何将各个进程隔离开，使之互不干扰</li>
<li>怎样让多个进程写作完成任务</li>
<li>多个进程共享文件数据时，如何保证数据的一致性</li>
<li>怎样协调多个进程对资源的竞争或共享</li>
</ul>
<p><strong>并发的实质</strong>:</p>
<ul>
<li><strong>并发的实质</strong> 是一个物理 <code>CPU</code> 在若干道程序之间多路复用</li>
<li><strong>并发性</strong> 是指让有限物理资源实现多用户共享，以提高效率</li>
<li><strong>共享性</strong> 指操作系统中的资源可被多个并发执行的进程所使用<ul>
<li>同时共享：同时具有使用权，如内存空间、磁盘空间，涉及透明资源共享（资源隔离与授权访问）</li>
<li>互斥共享：轮流使用，如 <code>CPU</code> 、<code>I/O</code> 设备，涉及显示资源共享（临界资源与独占访问）</li>
</ul>
</li>
<li><strong>异步性</strong> 也被称为不确定性，指的是并发进程的推进速度不可预知<ul>
<li>每个进程在某一时刻所处的状态以及资源拥有情况，不是提前安排好的，而是系统动态运行过程中通过管理调度形成的</li>
<li>异步性特征是并发和共享带来的结果</li>
<li>异步性的表现：<ul>
<li>进程何时执行，何时暂停是随机的</li>
<li>作业到达系统的类型和时间是随机的</li>
<li>操作员发出命令或按按钮的时刻是随机的</li>
<li>程序运行发生错误或异常的时刻是随机的</li>
<li>各种各样的软硬件中断时间发生的时刻是随机的</li>
</ul>
</li>
<li>异步性给系统会带来潜在的危险，有可能导致与时间有关的错误</li>
<li>操作系统的一个重要人物是必须确保捕捉任何一种随机时间，正确处理，否则将会导致严重后果</li>
</ul>
</li>
<li><strong>虚拟性</strong> 是指利用某种技术将少的物理资源演变为多的，逻辑上对应的资源，还包括将慢的虚拟成快的、容量小的虚拟成容量大的、不能共享的虚拟成能共享的。一方面虚拟扩充了系统资源，另一方面为用户使用系统带来了方便<ul>
<li>虚拟性的表现：<ul>
<li>虚拟存储器</li>
<li>虚拟设备</li>
<li>虚拟机</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="二、作业与作业管理概述"><a href="#二、作业与作业管理概述" class="headerlink" title="二、作业与作业管理概述"></a>二、作业与作业管理概述</h1><blockquote>
<ul>
<li>作业管理模块是操作系统中最外层的直接面对用户的模块</li>
<li>为用户提供系统接口，将用户需求提交系统，再见处理结果反馈用户</li>
<li>负责用户管理，核证用户合法性，管理用户使用资源及费用等情况</li>
</ul>
</blockquote>
<h2 id="2-1-什么是作业"><a href="#2-1-什么是作业" class="headerlink" title="2.1 什么是作业"></a>2.1 什么是作业</h2><p><a href="http://narpro.top/img/image-20200403145728301.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403145728301" class="fancybox"><img alt="image-20200403145728301" title="image-20200403145728301" data-src="http://narpro.top/img/image-20200403145728301.png" class="lazyload"></a></p>
<blockquote>
<p>简单的说，就是用户提交给计算机系统的任务</p>
<ul>
<li>作业有大有小，小作业可能只包含一个程序，大作业可能包含若干个程序</li>
</ul>
<p><strong>作业类别</strong>：</p>
<ul>
<li>批处理作业：主要用于巨型机和大型服务器系统，成批提交以后，系统将所有作业组织成一个作业流，然后对它们逐一进行控制和调度，脱机<ul>
<li>批处理管理机制</li>
<li>作业控制块（<code>JCB</code>）</li>
<li>作业状态</li>
<li>作业调度</li>
<li>作业的装入和卸出</li>
</ul>
</li>
<li>交互性作业：广泛用于各种系统，主要特点是用户可以独占一台终端机，对自己的作业实施交互控制，联机<ul>
<li>不经作业调度，直接进入内存，通过进程调度和进程控制管理</li>
</ul>
</li>
<li>实时性：特指响应时间有实时需求的作业，用于实时系统。根据作业对响应时间严格性要求的不同，可细分为硬实时和软实时作业</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403151148720.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403151148720" class="fancybox"><img alt="image-20200403151148720" title="image-20200403151148720" data-src="http://narpro.top/img/image-20200403151148720.png" class="lazyload"></a></p>
</blockquote>
<h3 id="2-1-1-用户管理"><a href="#2-1-1-用户管理" class="headerlink" title="2.1.1 用户管理"></a>2.1.1 用户管理</h3><blockquote>
<ul>
<li>功能：创建新用户、删除老用户、验证用户身份、维护用户信息、配置各个用户的运行环境、为各用户设置使用权限、用户组的设置与管理</li>
<li>用途：既方便计费，又方便系统安全管理</li>
</ul>
</blockquote>
<h3 id="2-1-2-接口管理"><a href="#2-1-2-接口管理" class="headerlink" title="2.1.2 接口管理"></a>2.1.2 接口管理</h3><blockquote>
<ul>
<li>功能：为用户提供设置不同的用户接口，既分操作员接口、程序员接口，又分联机接口、脱机接口</li>
<li>用途：为用户使用计算机系统、运行不同类型的作业提供方便</li>
</ul>
</blockquote>
<h3 id="2-1-3-批作业的管理控制与调度"><a href="#2-1-3-批作业的管理控制与调度" class="headerlink" title="2.1.3 批作业的管理控制与调度"></a>2.1.3 批作业的管理控制与调度</h3><blockquote>
<ul>
<li>功能：将批作业收容到外存的“作业输入井”中，建立“作业控制块”记录作业控制信息，通过作业调度选择后备作业装载入内存，并在作业完成后将作业卸出</li>
<li>要点：<ul>
<li>作业状态、作业控制块</li>
<li>作业调度、作业的装载与卸出</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-2-操作系统接口"><a href="#2-2-操作系统接口" class="headerlink" title="2.2 操作系统接口"></a>2.2 操作系统接口</h2><p><a href="http://narpro.top/img/image-20200403150227957.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403150227957" class="fancybox"><img alt="image-20200403150227957" title="image-20200403150227957" data-src="http://narpro.top/img/image-20200403150227957.png" class="lazyload"></a></p>
<h3 id="2-2-1-作业控制说明语言"><a href="#2-2-1-作业控制说明语言" class="headerlink" title="2.2.1 作业控制说明语言"></a>2.2.1 作业控制说明语言</h3><blockquote>
<ul>
<li>批处理系统中，用户提交给系统的一个计算任务，就是一个作业</li>
<li>批作业 = 程序 + 数据 + 作业控制说明书</li>
<li>作业控制说明书由作业控制语言编写，也就是由一条条控制作业如何运行的命令组成</li>
<li>作业控制说明语言是由一组作业控制命令组成的集合，专门用于批处理系统</li>
</ul>
</blockquote>
<h3 id="2-2-2-联机命令接口"><a href="#2-2-2-联机命令接口" class="headerlink" title="2.2.2 联机命令接口"></a>2.2.2 联机命令接口</h3><blockquote>
<p>终端用户使用的操作命令接口，主要实现人机交互。用户通过终端命令或者鼠标点击来控制作业的运行。该类接口涉及的服务程序：</p>
<ul>
<li>终端处理程序</li>
<li>命令解释程序</li>
<li>鼠标点击事件响应程序</li>
</ul>
<p><strong>分类</strong>：</p>
<ul>
<li>命令行方式此操作接口（键盘）</li>
<li>图形化界面（鼠标点击）</li>
</ul>
</blockquote>
<h3 id="2-2-3-程序级接口"><a href="#2-2-3-程序级接口" class="headerlink" title="2.2.3 程序级接口"></a>2.2.3 程序级接口</h3><blockquote>
<p>操作系统还提供一种适用于应用程序中的功能调用接口，叫做系统调用，允许用户在自己的应用程序中调用系统中提供的一些功能模块。简单地说，系统调用就是应用程序要调用系统程序。</p>
<p><strong>系统调用是应用程序获得操作系统服务的唯一途径</strong></p>
<p><a href="http://narpro.top/img/image-20200403153619667.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403153619667" class="fancybox"><img alt="image-20200403153619667" title="image-20200403153619667" data-src="http://narpro.top/img/image-20200403153619667.png" class="lazyload"></a></p>
<ul>
<li>特权指令是指那些直接管理控制系统资源和状态的指令，用错可能导致整个系统崩溃，比如：清内存、设置时钟等</li>
<li>只有系统程序才能执行特权指令，应用程序只能执行非特权指令</li>
</ul>
<p>系统资源的分配、驱动、调度以及管理数据的检索、修改等操作，是不允许用户程序自行处理的，否则系统就无安全性及管理控制之说了</p>
<p>操作系统以系统调用的形式提供一系列的实现预定底层功能的内核函数，每个系统调用都有写好的服务历程，每个服务例程有其入口地址</p>
</blockquote>
<h3 id="2-2-4-CPU-的两种工作状态"><a href="#2-2-4-CPU-的两种工作状态" class="headerlink" title="2.2.4 CPU 的两种工作状态"></a>2.2.4 <code>CPU</code> 的两种工作状态</h3><blockquote>
<ul>
<li>管态（系统态）：执行系统程序的状态，允许执行所有指令</li>
<li>目态（用户态）：执行用户程序的状态，只允许执行非特权指令</li>
</ul>
</blockquote>
<h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3 系统调用"></a>2.3 系统调用</h2><blockquote>
<p>是操作系统提供的一种适用于应用程序中的功能调用接口，叫做系统调用，允许用户在自己的应用程序中调用系统中提供的一些功能模块</p>
<p><strong>系统调用是应用程序获得操作系统服务的唯一途径</strong></p>
<p><strong>分类</strong>：</p>
<ul>
<li>进程和作业管理类</li>
<li>文件操作类</li>
<li>设备管理嘞</li>
<li>主存管理嘞</li>
<li>信息维护类</li>
<li>通信类</li>
</ul>
<p>系统调用：程序级接口，通过该接口用户程序可以调用操作系统提供的功能模块。<strong>系统调用的服务例程在管态下执行</strong></p>
<p><code>API</code>：系统提供的应用函数库，也称应用程序接口，将一些常用功能函数事先实现，供用户程序直接调用，其中一些 <code>API</code> 函数的是现场过程调用了一个或多个系统调用。<strong><code>API</code> 函数在目态下执行</strong></p>
<p>Linux 系统程序、系统调用、库函数、应用程序分层关系</p>
<p><a href="http://narpro.top/img/image-20200403155859441.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403155859441" class="fancybox"><img alt="image-20200403155859441" title="image-20200403155859441" data-src="http://narpro.top/img/image-20200403155859441.png" class="lazyload"></a></p>
<p><strong>系统调用的实现</strong>：</p>
<ul>
<li>编写系统调用处理内核函数</li>
<li>设计一张系统调用入口地址表，每个入口地址都指向一个系统调用的处理内核函数，有的系统还包含系统调用自带参数的个数</li>
<li>陷入处理机制开辟现场保护区，以保存发生系统调用时的处理器现场</li>
</ul>
</blockquote>
<h2 id="2-4-作业的管理控制"><a href="#2-4-作业的管理控制" class="headerlink" title="2.4 作业的管理控制"></a>2.4 作业的管理控制</h2><h3 id="2-4-1-批作业的状态管理"><a href="#2-4-1-批作业的状态管理" class="headerlink" title="2.4.1 批作业的状态管理"></a>2.4.1 批作业的状态管理</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200403161131879.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403161131879" class="fancybox"><img alt="image-20200403161131879" title="image-20200403161131879" data-src="http://narpro.top/img/image-20200403161131879.png" class="lazyload"></a></p>
<ul>
<li>后备状态**：已经提交到外存的“作业收容井”，等待调度装入</li>
<li><strong>驻留状态</strong>：被作业调度选中，已经装入内存，处于宏观的运行状态</li>
<li><strong>完成状态</strong>：作业相关代码已经执行结束，已不再占有内存空间和系统各种设备，正在等待卸出和数据缓输出</li>
</ul>
</blockquote>
<h3 id="2-4-2-批作业控制块的描述和组织"><a href="#2-4-2-批作业控制块的描述和组织" class="headerlink" title="2.4.2 批作业控制块的描述和组织"></a>2.4.2 批作业控制块的描述和组织</h3><blockquote>
<ul>
<li>为了掌握作业的有关情况，管理程序需要对作业进行必要的等级</li>
<li>作业管理模块设置一种数据结构，叫做作业控制块 <code>JCB - Job Control Block</code> ，用以记录作业的各项属性和管理信息</li>
</ul>
<p><strong><code>JCB</code> 的内容</strong></p>
<ul>
<li>作业号</li>
<li>作业类别</li>
<li>用户名及用户账号</li>
<li>作业状态</li>
<li>提交到系统的时间</li>
<li>优先级</li>
<li>作业所在的外存位置</li>
<li>资源需求</li>
<li>运行长度</li>
<li>已经运行的时间</li>
<li>其他信息</li>
</ul>
</blockquote>
<h3 id="2-4-3-不同的作业-I-O-方式"><a href="#2-4-3-不同的作业-I-O-方式" class="headerlink" title="2.4.3 不同的作业 I/O 方式"></a>2.4.3 不同的作业 <code>I/O</code> 方式</h3><blockquote>
<p><strong>联机 <code>I/O</code></strong>：这是一种早期的输入输出方式，主机连接 <code>I/O</code> 设备，在作业运行过程中，占用着 <code>CPU</code> 进行输入和输出过程。缺点是快速 <code>CPU</code> 等待慢速的 <code>I/O</code> 设备</p>
<p><strong>脱机 <code>I/O</code></strong>：</p>
<p><a href="http://narpro.top/img/image-20200403161913582.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403161913582" class="fancybox"><img alt="image-20200403161913582" title="image-20200403161913582" data-src="http://narpro.top/img/image-20200403161913582.png" class="lazyload"></a></p>
<p><strong>假脱机 <code>I/O</code></strong>：这种方式又称作“在线外设并行访问”。简记为 <code>Spooling</code>。在这种方式中，不再单独设置的输入输出计算机，而是将输入输出功能从操作系统内核中分离出来，单独形成 <code>I/O</code> 进程，来完成用户的输入输出工作</p>
<p><a href="http://narpro.top/img/image-20200403162221545.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403162221545" class="fancybox"><img alt="image-20200403162221545" title="image-20200403162221545" data-src="http://narpro.top/img/image-20200403162221545.png" class="lazyload"></a></p>
</blockquote>
<h3 id="2-4-4-不同的作业控制方式"><a href="#2-4-4-不同的作业控制方式" class="headerlink" title="2.4.4 不同的作业控制方式"></a>2.4.4 不同的作业控制方式</h3><blockquote>
<p>操作系统必须对用户作业的全过程实施控制，包括怎样将作业输入到计算机中去、怎样控制作业对玉兴、运行出现故障后如何进行处理以及作业运行结束后哪些内容输出等</p>
<p><a href="http://narpro.top/img/image-20200403162637764.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403162637764" class="fancybox"><img alt="image-20200403162637764" title="image-20200403162637764" data-src="http://narpro.top/img/image-20200403162637764.png" class="lazyload"></a></p>
<p><strong>脱机作业控制</strong>：这种管理方式一般适用于批处理系统中，所有作业的控制信息都由用户按照系统提供的作业控制语言来编制。用户提交作业之后，作业的运行完全脱离用户的干预</p>
<p><strong>联机作业控制</strong>：是大多数分时系统和实时系统采用的一种作业控制方式，整个控制过程由用户使用操作系统提供的操作命令，与计算机通过交互会话方式来控制作业执行</p>
</blockquote>
<h2 id="2-5-作业调度"><a href="#2-5-作业调度" class="headerlink" title="2.5 作业调度"></a>2.5 作业调度</h2><blockquote>
<p>又称 <strong>高级调度</strong> </p>
<ul>
<li>批处理系统中采用的一级调度</li>
<li>其主要功能是，从处于后备状态的作业中按照某种算法选择一道或几道作业装入内存<ul>
<li>选几道：单道系统只选一道，多道系统视内存容量决定</li>
<li>选哪几道：由作业调度算法决定</li>
</ul>
</li>
<li>作业调度主要解决的是作业与作业之间的自动转接问题，即免去作业控制中的人工操作的问题</li>
</ul>
<p><strong>什么时候执行作业调度程序</strong>：</p>
<ul>
<li>有作业完成</li>
<li>新作业提交且内存有空闲</li>
<li>处理及利用率偏低</li>
</ul>
</blockquote>
<h3 id="2-5-1-先来先服务-FCFS-调度算法"><a href="#2-5-1-先来先服务-FCFS-调度算法" class="headerlink" title="2.5.1 先来先服务 FCFS 调度算法"></a>2.5.1 先来先服务 <code>FCFS</code> 调度算法</h3><blockquote>
<p><code>First Come First Serverd</code> 选择最先进入后备队列的作业装入内存</p>
<p><strong>优点</strong>：</p>
<ul>
<li>比较容易实现</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不区分作业长短，对短小作业十分不利</li>
<li>不顾及轻重缓急</li>
<li>对事件要求紧迫的作业不能做到急事急办</li>
</ul>
</blockquote>
<h3 id="2-5-2-最短作业优先-SJF-调度算法"><a href="#2-5-2-最短作业优先-SJF-调度算法" class="headerlink" title="2.5.2 最短作业优先 SJF 调度算法"></a>2.5.2 最短作业优先 <code>SJF</code> 调度算法</h3><blockquote>
<p><code>Shortest Job First</code> 从后备作业中选择运行时间最短的作业装入内存</p>
<p><strong>优点</strong>：</p>
<ul>
<li>照顾短作业用户的利益，提高系统吞吐量</li>
<li>让作业的平均周转时间降下来</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>推迟长作业运行，可能出现饥饿现象</li>
<li>估计运行时间本身有可能不太准确</li>
</ul>
</blockquote>
<h3 id="2-5-3-最高相应比优先-HRF-调度算法"><a href="#2-5-3-最高相应比优先-HRF-调度算法" class="headerlink" title="2.5.3 最高相应比优先 HRF 调度算法"></a>2.5.3 最高相应比优先 <code>HRF</code> 调度算法</h3><blockquote>
<p><code>Highest Response First</code></p>
<p><a href="http://narpro.top/img/image-20200403165018053.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403165018053" class="fancybox"><img alt="image-20200403165018053" title="image-20200403165018053" data-src="http://narpro.top/img/image-20200403165018053.png" class="lazyload"></a></p>
<p>t<sub>w</sub> ：作业的等待时间</p>
<p>t<sub>s</sub> ：作业的估计运行时间</p>
<p><strong>优点</strong>：折中考虑到作业进入系统的先后次序，又估计到作业的运行长度</p>
<p><strong>缺点</strong>：每次调度都要计算每个作业的响应时间比，开销大</p>
</blockquote>
<h3 id="2-5-4-最高优先级-HPF-调度算法"><a href="#2-5-4-最高优先级-HPF-调度算法" class="headerlink" title="2.5.4 最高优先级 HPF 调度算法"></a>2.5.4 最高优先级 <code>HPF</code> 调度算法</h3><blockquote>
<p><code>Highest Priority First</code> 该算法每次总是选择后备作业中优先级最高的作业装入内存。当一个作业进入系统，系统根据用户级别、用户租金、作业类别、作业运行时间要求等为作业赋予一个优先级。是一种比较灵活的调度算法，优先级可以根据需要灵活确定，经常作为基于作业运行紧迫性的一种调度方案</p>
</blockquote>
<h3 id="2-5-5-均衡调度算法"><a href="#2-5-5-均衡调度算法" class="headerlink" title="2.5.5 均衡调度算法"></a>2.5.5 均衡调度算法</h3><p><a href="http://narpro.top/img/image-20200403165754917.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403165754917" class="fancybox"><img alt="image-20200403165754917" title="image-20200403165754917" data-src="http://narpro.top/img/image-20200403165754917.png" class="lazyload"></a></p>
<blockquote>
<p>根据内存容量的限制，选择一组资源互补型的作业装入。</p>
<p><strong>目的</strong>：在作业运行期间，尽可能提高 <code>CPU</code> 和各种设备之间的并行度</p>
</blockquote>
<h3 id="2-5-6-作业调度性能的衡量准则"><a href="#2-5-6-作业调度性能的衡量准则" class="headerlink" title="2.5.6 作业调度性能的衡量准则"></a>2.5.6 作业调度性能的衡量准则</h3><blockquote>
<ul>
<li><p>系统吞吐量高，单位时间内系统完成的工作量称吞吐量。这是作业调度追求的第一目标</p>
</li>
<li><p>Q 吞吐量与作业的平均周转时间 T 有 <strong>T 越小，Q 就越大</strong> 的关系</p>
<ul>
<li>作业的平均周转时间</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403170240104.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403170240104" class="fancybox"><img alt="image-20200403170240104" title="image-20200403170240104" data-src="http://narpro.top/img/image-20200403170240104.png" class="lazyload"></a></p>
<ul>
<li>t<sub>fi</sub> 为第 i 个作业的完成时间</li>
<li>t<sub>bi</sub> 为第 i 个作业的提交时间</li>
<li>n 为单位时间内的作业数量</li>
</ul>
</li>
<li><p>对短作业优惠，这一准则主要是为了吸引中小用户使用计算机。为了描述系统对短小作业的优惠程度，可使用作业的平均带权周转时间 w 作为评价参数</p>
<p><a href="http://narpro.top/img/image-20200403170605200.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403170605200" class="fancybox"><img alt="image-20200403170605200" title="image-20200403170605200" data-src="http://narpro.top/img/image-20200403170605200.png" class="lazyload"></a></p>
<ul>
<li>t<sub>si</sub> 为第 i 个作业的服务时间（运行时间），w 越小，说明系统对短小作业越优惠</li>
</ul>
</li>
<li><p>处理及利用率高</p>
</li>
<li><p>响应时间有保证</p>
</li>
<li><p>优先权有保证</p>
</li>
<li><p>截止时间有保证</p>
</li>
<li><p>资源均衡利用</p>
</li>
</ul>
</blockquote>
<h1 id="三、进程管理与处理机调度"><a href="#三、进程管理与处理机调度" class="headerlink" title="三、进程管理与处理机调度"></a>三、进程管理与处理机调度</h1><h2 id="3-1-初识进程"><a href="#3-1-初识进程" class="headerlink" title="3.1 初识进程"></a>3.1 初识进程</h2><blockquote>
<p>是造作系统最核心的概念之一，是操作系统要面对的最核心的管理对象，是占用 <code>CPU</code> 资源和其他资源的实体</p>
<ul>
<li>用户的所有程序均通过进程的形式运行</li>
<li>操作系统给用户提供的各种服务也是以进程的形式运行</li>
<li>进程管理模块是操作系统中最核心的一个模块</li>
<li>学习操作系统内核从学习操作系统如何尽力、管理、调度进程开始</li>
</ul>
</blockquote>
<h3 id="3-1-1-什么是进程"><a href="#3-1-1-什么是进程" class="headerlink" title="3.1.1 什么是进程"></a>3.1.1 什么是进程</h3><blockquote>
<ul>
<li>一个正在计算机上执行中的程序</li>
<li>一个能分配给处理器执行的实体</li>
<li>一个具有以下特征的活动单元<ul>
<li>一组指令序列的执行</li>
<li>一个当前状态和相关的系统资源集</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-1-2-操作系统为什么要进入进程"><a href="#3-1-2-操作系统为什么要进入进程" class="headerlink" title="3.1.2 操作系统为什么要进入进程"></a>3.1.2 操作系统为什么要进入进程</h3><blockquote>
<p>一个程序的两次执行过程，在操作系统那里是两个相互独立的运行实体，所以操作系统需要引入进程</p>
<ul>
<li>使用进程描述每一个程序的每一次动态执行</li>
<li>通过进程实体来管理控制每一个程序的每一次执行过程</li>
<li>操作系统需要引进子进程，使大程序的程序段可以并发，以加快程序推进且高 <code>CPU</code> 利用率</li>
</ul>
<p>多道程序并发运行，共享 <code>CPU</code> 、内存、<code>I/O</code> 设备等资源</p>
<p>并发运行方式的基本特征：</p>
<ul>
<li>异步特征</li>
<li>资源共享特征</li>
<li>相互制约特征</li>
<li>不可重现性特征</li>
</ul>
</blockquote>
<h3 id="3-1-3-进程与程序、作业有何区别和联系"><a href="#3-1-3-进程与程序、作业有何区别和联系" class="headerlink" title="3.1.3 进程与程序、作业有何区别和联系"></a>3.1.3 进程与程序、作业有何区别和联系</h3><blockquote>
<p><strong>程序</strong>：</p>
<ul>
<li>完成一件事情的代码序列</li>
<li>静态</li>
<li>只包含代码</li>
<li>程序是作业的组成部分</li>
</ul>
<p><strong>进程</strong>：</p>
<ul>
<li>是一个程序的一次动态执行过程</li>
<li>进程对应一个程序的一次动态执行过程</li>
<li>动态</li>
<li>包括要运行的代码、代码要处理的数据、运行过程中的状态参数等</li>
</ul>
<p><strong>作业</strong>：</p>
<ul>
<li>批作业 = 程序 + 数据 + 作业控制说明书</li>
<li>交互作业 = 程序 + 数据 + 交互命令</li>
<li>用户提交给系统的一个计算任务</li>
</ul>
<p><strong>程序 VS 进程</strong>：</p>
<ul>
<li>进程是操作系统为了管理控制程序的运行而加设的一个概念和实体</li>
<li>程序不运行，就没有进程</li>
<li>一个进程是一个程序的一次执行过程</li>
<li>一个程序可能对应多个进程</li>
</ul>
</blockquote>
<h2 id="3-2-进程与进程管理模块"><a href="#3-2-进程与进程管理模块" class="headerlink" title="3.2 进程与进程管理模块"></a>3.2 进程与进程管理模块</h2><h3 id="3-2-1-进程的特征"><a href="#3-2-1-进程的特征" class="headerlink" title="3.2.1 进程的特征"></a>3.2.1 进程的特征</h3><blockquote>
<ul>
<li>动态特征：生命周期</li>
<li>并发特征：在一个时间段内都处在宏观的运行状态</li>
<li>独立特征：独立占有资源、独立参与 <code>CPU</code> 调度</li>
<li>异步特征：运行推进速度不可预知</li>
<li>结构特征：<code>PCB</code> + 进程体</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403183641480.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403183641480" class="fancybox"><img alt="image-20200403183641480" title="image-20200403183641480" data-src="http://narpro.top/img/image-20200403183641480.png" class="lazyload"></a></p>
<p><strong>进程控制块 <code>PCB</code></strong>：</p>
<p><a href="http://narpro.top/img/image-20200403183826661.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403183826661" class="fancybox"><img alt="image-20200403183826661" title="image-20200403183826661" data-src="http://narpro.top/img/image-20200403183826661.png" class="lazyload"></a></p>
<ul>
<li>进程标识<ul>
<li>外部标识（也称作进程的外部名）：是进程的创建者提供的进程名字，通常由字符串组成</li>
<li>内部标识（也称作进程的内部名）：是系统为进程命名的一个代码，通常是一个整型</li>
</ul>
</li>
<li>调度信息<ul>
<li>进程优先数，描述进程紧迫性的信息</li>
<li>进程状态信息，描述进程当前处于何种状态</li>
<li>其它调度信息</li>
</ul>
</li>
<li>处理机信息<ul>
<li>进程被中断时，该进程的 <code>CPU</code> 现场信息可以保存到自己的 <code>PCB</code> 中，一边该进程重新获得<code>CPU</code> 时可以从此处回复现场信息，继续运行</li>
<li>通用寄存器的内容，包括数据寄存器，段寄存器</li>
<li>程序状态字 <code>PSW</code> 的值</li>
<li>程序计数器 <code>PC</code> 的值</li>
<li>进程的堆栈指针等</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>程序代码和数据集所在的内存地址</li>
<li>资源清单，记载进程请求资源和已经占有资源的情况</li>
<li>同步与通信信息</li>
<li>外存地址</li>
<li>家族信息</li>
<li>链接指针</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-2-2-进程管理模块的主要功能"><a href="#3-2-2-进程管理模块的主要功能" class="headerlink" title="3.2.2 进程管理模块的主要功能"></a>3.2.2 进程管理模块的主要功能</h3><blockquote>
<p>进程管理模块时 <code>OS</code> 最重要的组成部分</p>
<p><strong>功能分类</strong>：</p>
<ul>
<li><p>进程控制</p>
<p>管理控制一个进程的生命周期</p>
<ul>
<li>创建新进程，撤销结束进程</li>
<li>阻塞或唤醒进程</li>
<li>挂起或激活进程</li>
</ul>
<p>管理控制多个进程的并发</p>
<ul>
<li>进程同步和进程互斥</li>
<li>进程通信</li>
</ul>
</li>
<li><p>进程调度</p>
<p>根据当前状态决定哪个进程获得 <code>CPU</code> </p>
<p>将 <code>CPU</code> 分给进程</p>
</li>
</ul>
</blockquote>
<h2 id="3-3-进程状态转换"><a href="#3-3-进程状态转换" class="headerlink" title="3.3 进程状态转换"></a>3.3 进程状态转换</h2><blockquote>
<p><a href="http://narpro.top/img/image-20200403185401119.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403185401119" class="fancybox"><img alt="image-20200403185401119" title="image-20200403185401119" data-src="http://narpro.top/img/image-20200403185401119.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200403185421976.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403185421976" class="fancybox"><img alt="image-20200403185421976" title="image-20200403185421976" data-src="http://narpro.top/img/image-20200403185421976.png" class="lazyload"></a></p>
</blockquote>
<h3 id="3-3-1-进程的三种基本状态"><a href="#3-3-1-进程的三种基本状态" class="headerlink" title="3.3.1 进程的三种基本状态"></a>3.3.1 进程的三种基本状态</h3><blockquote>
<ul>
<li>运行状态（running）：进程获得 <code>CPU</code> 并投入运行的一种状态。在单 <code>CPU</code> 系统中，每个瞬间最多只能有一个进程在运行</li>
<li>就绪状态（ready）：进程尚未获得 <code>CPU</code> 使用权的一种状态。进程已经拥有除 <code>CPU</code> 以外其它全部所需资源</li>
<li>阻塞状态（blocked）：进程因某种要求得不到满足，只好等待，我们称之为运行“受阻”。处于阻塞状态的进程是无权获得 <code>CPU</code> 的</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403190104419.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403190104419" class="fancybox"><img alt="image-20200403190104419" title="image-20200403190104419" data-src="http://narpro.top/img/image-20200403190104419.png" class="lazyload"></a></p>
<p><strong>状态转换</strong>：</p>
<ul>
<li>新建的进程都进入就绪状态，即 <strong>后备 to 就绪</strong></li>
<li>当进程被选中分配 <code>CPU</code>，由 <strong>就绪 to 运行</strong></li>
<li>如果这个进程运行一切顺利，则 <strong>运行 to 撤销</strong></li>
<li>但当这个进程因为某些原因暂时不能继续往下，就 <strong>运行 to 阻塞</strong></li>
<li>还有一种情况是当有优先级更高的进程进来，则 <strong>运行 to 就绪</strong></li>
<li>而阻塞进程的受阻得到解决后，可 <strong>阻塞 to 就绪</strong></li>
</ul>
<p><strong>挂起状态</strong>：把内存中当前某个尚不能运行的进程调到外存上去。腾出空间接纳更多的进程，这一处理称作挂起</p>
<p><a href="http://narpro.top/img/image-20200403191404665.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403191404665" class="fancybox"><img alt="image-20200403191404665" title="image-20200403191404665" data-src="http://narpro.top/img/image-20200403191404665.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200403191458898.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403191458898" class="fancybox"><img alt="image-20200403191458898" title="image-20200403191458898" data-src="http://narpro.top/img/image-20200403191458898.png" class="lazyload"></a></p>
<p>Linux 2.4 版本的六种状态</p>
<p><a href="http://narpro.top/img/image-20200403191701718.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403191701718" class="fancybox"><img alt="image-20200403191701718" title="image-20200403191701718" data-src="http://narpro.top/img/image-20200403191701718.png" class="lazyload"></a></p>
</blockquote>
<h2 id="3-4-进程的创建与撤销"><a href="#3-4-进程的创建与撤销" class="headerlink" title="3.4 进程的创建与撤销"></a>3.4 进程的创建与撤销</h2><blockquote>
<p>进程从产生到消亡的整个过程都是由操作系统来控制的，操作系统中实现进程控制的功能程序叫 <strong>原语</strong></p>
</blockquote>
<h3 id="3-4-1-什么是原语"><a href="#3-4-1-什么是原语" class="headerlink" title="3.4.1 什么是原语"></a>3.4.1 什么是原语</h3><blockquote>
<p>机器指令构成的一种实现特定功能的小程序，它的运行具有不可分个性</p>
<p><strong>特点</strong>：</p>
<ul>
<li>贴近底层</li>
<li>最重要的</li>
<li>运行过程具有原子性</li>
<li>系统小程序</li>
</ul>
<p><strong>进程管理原语</strong>：</p>
<ul>
<li>进程创建/撤销/阻塞/唤醒/挂起/激活/调度原语</li>
</ul>
<p><strong>其他类型的原语</strong>：</p>
<ul>
<li>进程通信用的原语：用于实现进程之间的通信，如消息发送原语、消息接收原语</li>
<li>资源互斥与同步用的原语：解决资源互斥访问的，主要有 <code>P</code> 操作原语和 <code>V</code> 操作原语</li>
<li>资源管理用的原语：主要有请求资源的原语和释放资源的原语</li>
</ul>
</blockquote>
<h3 id="3-4-2-进程创建原语"><a href="#3-4-2-进程创建原语" class="headerlink" title="3.4.2 进程创建原语"></a>3.4.2 进程创建原语</h3><blockquote>
<p><strong>什么时候会被运行</strong>：</p>
<ul>
<li>批作业调度</li>
<li>交互作业提交</li>
<li>系统提供服务</li>
<li>用户程序创建子进程</li>
</ul>
<p><strong>如何创建</strong></p>
<ul>
<li><p>Create_Process()</p>
</li>
<li><p>索取一个空白的 <code>PCB</code> 块</p>
</li>
<li><p>填入进程信息</p>
<ul>
<li>填入进程标识</li>
<li>填入优先级</li>
<li>填入内存地址：请求分配内存或 <code>JCB</code> 或父进程的内存地址填入</li>
<li>填入资源清单：请求分配设备或 <code>JCB</code> 或父进程资源填入</li>
<li>填入家族信息：用户名或父进程名</li>
<li>填入现场信息：初始状态数据</li>
<li>填入进程状态：就绪</li>
</ul>
</li>
<li><p>挂入就绪队列</p>
</li>
<li><p>若需要将进程代码和数据集装入内存，可启动加载程序</p>
</li>
</ul>
</blockquote>
<h3 id="3-4-3-撤销进程"><a href="#3-4-3-撤销进程" class="headerlink" title="3.4.3 撤销进程"></a>3.4.3 撤销进程</h3><blockquote>
<ul>
<li>进程自行终止</li>
<li>用户或父进程的原因使进程终止</li>
<li>运行超时而终止</li>
<li>运行出错而终止</li>
</ul>
<p><strong>如何撤销</strong></p>
<ul>
<li>Destroy (id_name)</li>
<li>根据 <code>id_name</code> 查找被终止进程的进程控制块 <code>PCB</code> </li>
<li>若该进程的状态是运行，则置调度标志为 <code>true</code></li>
<li>回收 <code>PCB</code> 中登记的全部资源</li>
<li>将进程的 <code>PCB</code> 从所在的队列摘下来，等待其他程序来搜集信息</li>
<li>对于该进程的所有子进程 <code>Sub</code>，递归调用 <code>End_Process(Sub)</code>，将子进程终止</li>
<li>如果调度标志 = <code>true</code> ，启动进程调度程序</li>
</ul>
</blockquote>
<h2 id="3-5-父进程与子进程"><a href="#3-5-父进程与子进程" class="headerlink" title="3.5 父进程与子进程"></a>3.5 父进程与子进程</h2><blockquote>
<p><strong>进程什么时候被创建</strong>：</p>
<ul>
<li>批作业调度：操作系统创建用户进程</li>
<li>交互作业提交：操作系统创建用户进程</li>
<li>系统提供服务：操作系统创建系统进程</li>
<li>用户程序创建子进程：用户程序创建用户进程，通过 <code>fork()</code> 实现</li>
</ul>
<p><strong>进程家族树</strong>：</p>
<ul>
<li>父进程：执行过程中创建了其他进程的进程</li>
<li>子进程：被父进程创建的进程</li>
<li>.etc</li>
</ul>
</blockquote>
<h3 id="3-5-1-fork-说明"><a href="#3-5-1-fork-说明" class="headerlink" title="3.5.1 fork() 说明"></a>3.5.1 <code>fork()</code> 说明</h3><blockquote>
<p><code>pid_t fork(void)</code> 函数包含于头文件 <code>unistd.sh</code></p>
<p><strong>函数功能</strong>：</p>
<ul>
<li>建立一个新的子进程。其子进程会复制父进程的数据与堆栈空间，并继承父进程的用户代码、组代码、环境变量、已打开的文件代码、工作目录和资源限制等</li>
<li>如果调用成功，则在父进程会返回新建立的子进程代码 <code>PID</code>，而在新建立的子进程中则返回 0</li>
</ul>
<p><strong>调用失败的原因</strong>：失败则直接返回 -1</p>
<ul>
<li>系统内存不够</li>
<li>进程表满</li>
<li>用户的子进程太多，一般不超过 25 个</li>
</ul>
</blockquote>
<h2 id="3-6-进程状态转换控制原语"><a href="#3-6-进程状态转换控制原语" class="headerlink" title="3.6 进程状态转换控制原语"></a>3.6 进程状态转换控制原语</h2><h3 id="3-6-1-阻塞原语"><a href="#3-6-1-阻塞原语" class="headerlink" title="3.6.1 阻塞原语"></a>3.6.1 阻塞原语</h3><blockquote>
<p><strong>什么时候调用阻塞原语</strong>：</p>
<ul>
<li>当正在运行的进程需要等待某一事件而发生运行受阻时，它通过中断请求系统服务</li>
<li>系统按照进程的需求进行适当处理后，启动“进程阻塞原语”将该进程阻塞起来</li>
</ul>
<p><strong>是么情况引起受阻</strong>：</p>
<ul>
<li>等待 <code>I/O</code></li>
<li>请求资源得不到满足</li>
<li>进程同步约束</li>
<li>服务进程无事可做</li>
</ul>
<p><strong>如何阻塞</strong>:</p>
<ul>
<li>获取 <code>PCB</code> 的 <code>id</code></li>
<li>从 <code>running</code> 队列中移除该 <code>id</code> 的 <code>PCB</code></li>
<li>保存 <code>PCB</code> 的上下文</li>
<li>将 <code>PCB</code> 状态设置为阻塞</li>
<li>将进程插入阻塞队列</li>
<li>启动调度程序选择下一个被执行的进程</li>
<li>结束</li>
</ul>
</blockquote>
<h3 id="3-6-2-唤醒原语"><a href="#3-6-2-唤醒原语" class="headerlink" title="3.6.2 唤醒原语"></a>3.6.2 唤醒原语</h3><blockquote>
<p><strong>什么时候调用唤醒原语</strong>：</p>
<ul>
<li>当系统发生某一个事件时，正在等待该事件的进程需要立即被唤醒，由 <strong>阻塞</strong> 变为 <strong>就绪</strong> 状态</li>
</ul>
<p><strong>什么情况下会唤醒</strong>：</p>
<ul>
<li>所等的 <code>I/O</code> 操作已完成</li>
<li>请求的资源得到了满足</li>
<li>进程同步约束已撤销</li>
<li>服务进程收到新的任务</li>
</ul>
<p><strong>如何唤醒</strong>：</p>
<ul>
<li>将当前进程的上下文保存到系统栈</li>
<li>从阻塞队列查找等待该事件的进程 <code>PCB</code></li>
<li>将 <code>PCB</code> 从阻塞队列上摘下来</li>
<li>将其状态设置为 <strong>就绪</strong>，将 <code>PCB</code> 挂入就绪队列</li>
<li>弹出系统栈中的进程上下文，置入 <code>CPU</code> 让被中断的进程恢复运行</li>
<li>结束</li>
</ul>
</blockquote>
<h3 id="3-6-3-挂起原语"><a href="#3-6-3-挂起原语" class="headerlink" title="3.6.3 挂起原语"></a>3.6.3 挂起原语</h3><blockquote>
<p><strong>什么时候会调用</strong>：</p>
<ul>
<li>当前内存空间紧缺，部分进程优先运行</li>
<li>应用户的要求，将用户进程挂起</li>
<li>应父进程的要求，将其子进程挂起</li>
</ul>
<p><strong>如何挂起</strong>：</p>
<ul>
<li>找到被挂起进程的 <code>PCB</code> ，获得其内存地址，将内存空间归还给存储管理模块</li>
<li>进程状态阻塞挂起为 <strong>挂起阻塞</strong> ，或者就绪转为 <strong>挂起就绪</strong>，将 <code>PCB</code> 从原队列转入相应队列</li>
<li>森请外存交换区空间，换出进程，地址写入 <code>PCB</code> </li>
<li>结束</li>
</ul>
</blockquote>
<h3 id="3-6-4-激活原语"><a href="#3-6-4-激活原语" class="headerlink" title="3.6.4 激活原语"></a>3.6.4 激活原语</h3><blockquote>
<p><strong>什么时候会调用</strong>：</p>
<ul>
<li>有进程运行完毕，当前内存空间不紧张</li>
<li>应用户要求，将其进程激活</li>
<li>应父进程的要求，将其子进程激活</li>
<li>进程自身设定的挂起周期已完成</li>
</ul>
<p><strong>如何激活</strong>：</p>
<ul>
<li>扫描 <strong>挂起就绪队列</strong> 找到被激活进程的 <code>PCB</code></li>
<li>将 <code>PCB</code> 从所在的队列上摘下来</li>
<li>按 <code>PCB</code> 等级的空间需求，申请内存，加载到内存中</li>
<li>归还外存交换区空间</li>
<li>将进程设置为 <strong>就绪</strong>，插入就绪队列</li>
<li>结束</li>
</ul>
</blockquote>
<h2 id="2-7-进程调度"><a href="#2-7-进程调度" class="headerlink" title="2.7 进程调度"></a>2.7 进程调度</h2><blockquote>
<p>调度程序功能：从处于就绪状态的进程中，按照某种调度策略，选择一个进程切换给 <code>CPU</code>，使其状态从就绪转为运行</p>
</blockquote>
<h3 id="2-7-1-非抢占式调度"><a href="#2-7-1-非抢占式调度" class="headerlink" title="2.7.1 非抢占式调度"></a>2.7.1 非抢占式调度</h3><blockquote>
<p><strong>可能性</strong>：</p>
<ul>
<li>进程运行完毕推出</li>
<li>运行受阻</li>
<li>运行出错，非正常终止</li>
<li>遇到不可挽回的故障</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403222848973.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403222848973" class="fancybox"><img alt="image-20200403222848973" title="image-20200403222848973" data-src="http://narpro.top/img/image-20200403222848973.png" class="lazyload"></a></p>
</blockquote>
<h3 id="2-7-2-抢占式调度"><a href="#2-7-2-抢占式调度" class="headerlink" title="2.7.2 抢占式调度"></a>2.7.2 抢占式调度</h3><blockquote>
<p>也称剥夺式调度，一般用于有实时需求的系统</p>
<p><strong>可能性</strong>：</p>
<ul>
<li>主要指系统正常运转期间，如果某种事件出现，系统将迫使正在运行的进程停下来，将 <code>CPU</code> 控制权交给其他进程</li>
<li>其思想源于对高紧迫度作业的响应</li>
</ul>
</blockquote>
<h3 id="3-7-3-进程调度算法"><a href="#3-7-3-进程调度算法" class="headerlink" title="3.7.3 进程调度算法"></a>3.7.3 进程调度算法</h3><blockquote>
<ul>
<li><p>FCFS：先进入就绪队列的进程先调度</p>
</li>
<li><p>SPF：最短进程优先调度</p>
</li>
<li><p>HPF：最高优先级调度</p>
</li>
<li><p>HRF：最高相应比优先调度</p>
</li>
<li><p>SRT</p>
</li>
<li><p>RR：按时间片轮转调度，多用于分时系统</p>
<ul>
<li>进程轮流使用 <code>CPU</code>，各用一个时间片，时间片用完管理程序停止它的运行，并将它转入就绪队列尾部，调度下一个进程。<strong>进程失去 <code>CPU</code> 不是自愿的，而是被系统剥夺的</strong></li>
<li>启动时机：<ul>
<li>一个时间片运行结束</li>
<li>当前进程运行结束</li>
<li>正在运行的进程因运行受阻主动放弃控制权</li>
</ul>
</li>
<li>时间片确定的原则<ul>
<li>进程的刀数较多时，取小一点，反之大一点</li>
<li>系统要求的响应时间比较苛刻时，取小一点，反之取大一点</li>
</ul>
</li>
</ul>
</li>
<li><p>多队列调度</p>
<ul>
<li>设置多个就绪队</li>
<li>就绪对优先级不同，优先级高的队列优先调度</li>
<li>优先级高的队列为空时，再调度低优先级队列</li>
</ul>
</li>
<li><p>多级队列反馈调度</p>
<ul>
<li>设置 n 个队列 Q1，Q2，，，Qn</li>
<li>记 Qi 的优先级为 Pi，有 P1 > P2 >，，，> Pn</li>
<li>记 Qi 的时间片为 qi，有 q1 < q2 <，，，< qn</li>
<li>新建进程进入 Q1 队</li>
<li>只有 Qi 为空时，才调度 Qi+1 中的进程</li>
<li>进程 p 在 Qi 中被调度执行，若时间片 qi 已到但尚未结束，则进程 p 转为就绪状态进入 Qi+1 队，进程 p 在 Qn 中被调度执行，若时间片已到但尚未结束，则进程转为就绪状态仍入 Qn 队</li>
</ul>
<p><strong>终端型用户满意</strong>：终端型作业都是交互型，比较短，进入第一队列后优先调度，一般只要一个小时间片就可完成</p>
<p><strong>短的批处理作业用户满意</strong>：短的批处理作业开始时首先进入第一个队列，能即使被响应，若轮转一周不能完成的花，通常只需在第二乃至第三队列上各执行一个时间片就能完成，作业的周转时间仍比较短</p>
<p><strong>长的批处理作业用户满意</strong>：一个长的批处理作业进入系统后，将依次在 1，2，，，n -1 队列中各运行一个时间片，最后进入第 n 各队列进行轮转运行，一般不必担心受冷落，一旦进入后面的叫徐对，获得的时间片比较长，系统调度开销比较少</p>
</li>
</ul>
</blockquote>
<h2 id="2-8-实时任务调度"><a href="#2-8-实时任务调度" class="headerlink" title="2.8 实时任务调度"></a>2.8 实时任务调度</h2><blockquote>
<ul>
<li>实时任务是一类对时间要求较为严格的进程，支持这类任务运行的系统成为实时处理系统</li>
<li>实时系统分为硬实时系统和软实时系统</li>
<li>调度方法一般是剥夺式的</li>
</ul>
</blockquote>
<h3 id="2-8-1-非周期实时任务的分类及调度方法"><a href="#2-8-1-非周期实时任务的分类及调度方法" class="headerlink" title="2.8.1 非周期实时任务的分类及调度方法"></a>2.8.1 非周期实时任务的分类及调度方法</h3><blockquote>
<ul>
<li><p>紧迫型实时任务调度</p>
<ul>
<li>多见于一些专用的、响应时间要求特别苛刻的数据采集和控制系统中，所要求的响应时间很短，一般是微秒级</li>
<li>采用立即抢占的 <code>HPF</code> 调度算法</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403231335772.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403231335772" class="fancybox"><img alt="image-20200403231335772" title="image-20200403231335772" data-src="http://narpro.top/img/image-20200403231335772.png" class="lazyload"></a></p>
</li>
<li><p>普通型的实时任务调度</p>
<ul>
<li><p>大多数自动控制系统对响应时间的要求都不是太高，一般是毫秒级的，它允许的相应时间长度与时钟中断的周期基本吻合</p>
</li>
<li><p>采用基于时钟中断抢占的高优先级调度</p>
<p><a href="http://narpro.top/img/image-20200403231613710.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403231613710" class="fancybox"><img alt="image-20200403231613710" title="image-20200403231613710" data-src="http://narpro.top/img/image-20200403231613710.png" class="lazyload"></a></p>
</li>
</ul>
</li>
<li><p>宽松型的实时任务调度</p>
<ul>
<li>要求的响应时间比较长，一般可达数百毫秒，甚至数秒</li>
<li>比如信息查询系统，这类任务的要求差异很大，通常又有很多不同的处理、</li>
<li>采用非抢占的 <code>HPF</code> </li>
</ul>
<p><a href="http://narpro.top/img/image-20200403231914140.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403231914140" class="fancybox"><img alt="image-20200403231914140" title="image-20200403231914140" data-src="http://narpro.top/img/image-20200403231914140.png" class="lazyload"></a></p>
<ul>
<li><code>RR</code> 算法</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403232054932.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403232054932" class="fancybox"><img alt="image-20200403232054932" title="image-20200403232054932" data-src="http://narpro.top/img/image-20200403232054932.png" class="lazyload"></a></p>
</li>
</ul>
</blockquote>
<h3 id="2-8-2-周期性实时任务"><a href="#2-8-2-周期性实时任务" class="headerlink" title="2.8.2 周期性实时任务"></a>2.8.2 周期性实时任务</h3><blockquote>
<p>信号检测和过程控制系统中呈现周期性运行规律的任务</p>
<ul>
<li><p>最小剩余时间调度算法</p>
<ul>
<li>周期任务 A 在第 i 次运行前的剩余时间 <code>FA(i)</code> 是</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403232437272.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403232437272" class="fancybox"><img alt="image-20200403232437272" title="image-20200403232437272" data-src="http://narpro.top/img/image-20200403232437272.png" class="lazyload"></a></p>
<ul>
<li>TA 任务 A 的周期长度</li>
<li>TsA 为任务 A 每次执行时间长度</li>
<li>t 为系统的当前时间</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-9-线程的引入"><a href="#2-9-线程的引入" class="headerlink" title="2.9 线程的引入"></a>2.9 线程的引入</h2><blockquote>
<p>操作系统中引入进程，目的是为了使多个程序并发执行，以改善资源使用率和提高系统效率</p>
<p>操作系统中再引入线程，则是为了减少程序并发执行时所付出的时空开销，使得并发粒度更细，并发性更好</p>
</blockquote>
<h3 id="2-9-1-线程是什么"><a href="#2-9-1-线程是什么" class="headerlink" title="2.9.1 线程是什么"></a>2.9.1 线程是什么</h3><blockquote>
<ul>
<li>线程是现代操作系统引入的一种执行实体</li>
<li>线程称 <strong>轻型进程</strong>，是进程的组成部分</li>
<li>进程是资源占有单位，线程只是 <code>CPU</code> 的调度单位</li>
<li>一个进程在运行过程中可以创建多个线程</li>
<li>线程共享所属进程的资源，自己只有 <code>TCB</code> 和很少的栈区</li>
</ul>
</blockquote>
<h3 id="2-9-2-线程的实现"><a href="#2-9-2-线程的实现" class="headerlink" title="2.9.2 线程的实现"></a>2.9.2 线程的实现</h3><blockquote>
<ul>
<li>内核级线程：因为是系统创建的，所以对于操作系统来说每一个线程的信息都可见，管理、控制、调度都由系统完成</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403233630709.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403233630709" class="fancybox"><img alt="image-20200403233630709" title="image-20200403233630709" data-src="http://narpro.top/img/image-20200403233630709.png" class="lazyload"></a></p>
<ul>
<li>用户级线程：由用户程序自己创建、管理、调度。在用户空间可见</li>
</ul>
<p><a href="http://narpro.top/img/image-20200403233645155.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403233645155" class="fancybox"><img alt="image-20200403233645155" title="image-20200403233645155" data-src="http://narpro.top/img/image-20200403233645155.png" class="lazyload"></a></p>
</blockquote>
<h3 id="2-9-3-进程和线程的区别"><a href="#2-9-3-进程和线程的区别" class="headerlink" title="2.9.3 进程和线程的区别"></a>2.9.3 进程和线程的区别</h3><blockquote>
<p><strong>进程</strong>：</p>
<ul>
<li>进程是个独立的实体单位</li>
<li>独立占有资源：进程拥有对资源的控制权或所有权</li>
<li>独立参与调度/执行：进程是一个可被操作系统调度和分派的单位</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程仅是分派（调度运行）的单位</li>
<li>线程不是单独占有资源的单位，线程共享其所属进程的资源</li>
</ul>
</blockquote>
<h2 id="2-10-处理机的四级调度"><a href="#2-10-处理机的四级调度" class="headerlink" title="2.10 处理机的四级调度"></a>2.10 处理机的四级调度</h2><blockquote>
<p><strong>调度的主要目标</strong>：</p>
<ul>
<li>选择哪个实体进入内存、选择哪个实体占用 <code>CPU</code></li>
</ul>
<p><strong>调度的主要层次</strong>：</p>
<ul>
<li>作业调度</li>
<li>中级调度</li>
<li>进程调度</li>
<li>线程调度</li>
</ul>
</blockquote>
<h3 id="2-10-1-典型的三级调度"><a href="#2-10-1-典型的三级调度" class="headerlink" title="2.10.1 典型的三级调度"></a>2.10.1 典型的三级调度</h3><blockquote>
<p>作业从进入系统成为后备作业开始，直到运行结束退出系统位置，需经历不同级别的调度，交互式作业不经过高级调度，直接进入内存</p>
<p><a href="http://narpro.top/img/image-20200403235055383.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200403235055383" class="fancybox"><img alt="image-20200403235055383" title="image-20200403235055383" data-src="http://narpro.top/img/image-20200403235055383.png" class="lazyload"></a></p>
<ul>
<li><strong>高级调度</strong>：<ul>
<li>又称作业调度，长程调度</li>
<li>从处于后备状态的作业中选择一道或几道，装入内存</li>
</ul>
</li>
<li><strong>中级调度</strong>：<ul>
<li>又称中程调度</li>
<li>优先从处于挂起就绪状态的进程之中选择一个或者几个，将之激活</li>
</ul>
</li>
<li><strong>低级调度</strong>：<ul>
<li>又称进程调度，短程调度</li>
<li>从处于就绪状态的进程中选择一个，切换给 <code>CPU</code> 执行</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-10-2-线程调度"><a href="#2-10-2-线程调度" class="headerlink" title="2.10.2 线程调度"></a>2.10.2 线程调度</h3><blockquote>
<ul>
<li>线程称 <strong>轻型进程</strong> 是进程的组成部分</li>
<li>进程是资源占有单位，线程是 <code>CPU</code> 的调度单位</li>
<li>线程共享所属进程的资源</li>
<li>线程分为用户级线程和内核级线程，调度方式不同<ul>
<li>用户级线程的调度<ul>
<li>操作系统进行进程调度</li>
<li>用户进程自己进行线程调度</li>
</ul>
</li>
<li>内核级线程的调度<ul>
<li>操作系统直接进行线程调度</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="四、进程并发控制篇"><a href="#四、进程并发控制篇" class="headerlink" title="四、进程并发控制篇"></a>四、进程并发控制篇</h1><h2 id="4-1-互斥与同步的基本概念"><a href="#4-1-互斥与同步的基本概念" class="headerlink" title="4.1 互斥与同步的基本概念"></a>4.1 互斥与同步的基本概念</h2><blockquote>
<p>操作系统在管理和控制资源分配与使用方面，应当保证进程对临界资源的访问满足以下 3 点</p>
<ul>
<li>互斥访问要求</li>
<li>不至于产生死锁</li>
<li>不能有饥饿进程给</li>
</ul>
</blockquote>
<h3 id="4-1-1-并发"><a href="#4-1-1-并发" class="headerlink" title="4.1.1 并发"></a>4.1.1 并发</h3><blockquote>
<ul>
<li>单处理器多道程序设计系统中，多个进程交替执行</li>
<li>多个并发进程再一个时间段内都处于运行状态</li>
<li>共享系统资源</li>
<li>每个进程都走走停停</li>
<li>并发带来的异步性</li>
</ul>
</blockquote>
<h3 id="4-1-2-并发带来的问题"><a href="#4-1-2-并发带来的问题" class="headerlink" title="4.1.2 并发带来的问题"></a>4.1.2 并发带来的问题</h3><blockquote>
<ul>
<li>并发进程的相对执行速度是不可预测的 ，取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略</li>
</ul>
</blockquote>
<h3 id="4-1-3-互斥"><a href="#4-1-3-互斥" class="headerlink" title="4.1.3 互斥"></a>4.1.3 互斥</h3><blockquote>
<ul>
<li>当一个进程在临界区访问临界资源时，其他进程不能进入相关临界区访问该资源</li>
<li>临界资源一个时刻只允许一个进程使用</li>
<li>进程使用该临界资源的顺序没有约束</li>
<li>体现竞争关系</li>
</ul>
</blockquote>
<h3 id="4-1-4-同步"><a href="#4-1-4-同步" class="headerlink" title="4.1.4 同步"></a>4.1.4 同步</h3><blockquote>
<ul>
<li>两个进程或线程不仅不能同时访问同一个资源，连先后顺序也要做限制</li>
<li>体现协作关系</li>
</ul>
</blockquote>
<h3 id="4-1-5-临界资源"><a href="#4-1-5-临界资源" class="headerlink" title="4.1.5 临界资源"></a>4.1.5 临界资源</h3><blockquote>
<ul>
<li>也叫互斥资源</li>
<li>一种一次只能为一个进程服务的共享资</li>
</ul>
</blockquote>
<h3 id="4-1-6-临界区"><a href="#4-1-6-临界区" class="headerlink" title="4.1.6 临界区"></a>4.1.6 临界区</h3><blockquote>
<ul>
<li>进程体中使用临界资源的代码段</li>
<li>使用同一临界资源的不同代码段叫做相关临界区</li>
<li>当一个进程已经再临界区中运行时，也就是已经在使用临界资源了，其他进程不能进入相关临界区</li>
</ul>
</blockquote>
<h3 id="4-1-7-死锁"><a href="#4-1-7-死锁" class="headerlink" title="4.1.7 死锁"></a>4.1.7 死锁</h3><blockquote>
<ul>
<li>两个或两个以上的进程，因其中的每个进程都在等待其他进程做完某些事情而不能继续执行，所有进程都阻塞等待，而且得不到解决</li>
</ul>
</blockquote>
<h3 id="4-1-8-活锁"><a href="#4-1-8-活锁" class="headerlink" title="4.1.8 活锁"></a>4.1.8 活锁</h3><blockquote>
<ul>
<li>两个或两个以上进程为了响应其他进程中的变化而持续改变自己的状态，但不做有用的工作</li>
</ul>
</blockquote>
<h3 id="4-1-9-饥饿"><a href="#4-1-9-饥饿" class="headerlink" title="4.1.9 饥饿"></a>4.1.9 饥饿</h3><blockquote>
<ul>
<li>一个可运行的进程被调度程序无限期的忽略，不能被调度执行的情形</li>
</ul>
</blockquote>
<h3 id="4-1-10-原子操作"><a href="#4-1-10-原子操作" class="headerlink" title="4.1.10 原子操作"></a>4.1.10 原子操作</h3><blockquote>
<ul>
<li>保证指令序列要么作为一个组来执行，要么都不执行</li>
</ul>
</blockquote>
<h2 id="4-2-软件方法解决进程互斥"><a href="#4-2-软件方法解决进程互斥" class="headerlink" title="4.2 软件方法解决进程互斥"></a>4.2 软件方法解决进程互斥</h2><blockquote>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<p><strong>软件方法解决互斥问题失败的原因</strong>：</p>
<ul>
<li>临界区前后所加代码越多，执行过程随时被打断的情况</li>
<li>所加的代码中的变量本身也是临界资源</li>
<li>没有考虑让权等待</li>
</ul>
</blockquote>
<h2 id="4-3-信号量机制解决同步互斥问题"><a href="#4-3-信号量机制解决同步互斥问题" class="headerlink" title="4.3 信号量机制解决同步互斥问题"></a>4.3 信号量机制解决同步互斥问题</h2><blockquote>
<p><strong>基本原理</strong>：</p>
<ul>
<li>两个或多个进程通过简单的信号进行合作</li>
<li>任务复杂的和需求都可以通过适当的信号结构得到的满足</li>
</ul>
</blockquote>
<h3 id="4-3-1-信号量机制实现要素"><a href="#4-3-1-信号量机制实现要素" class="headerlink" title="4.3.1 信号量机制实现要素"></a>4.3.1 信号量机制实现要素</h3><blockquote>
<ul>
<li>信号量（<code>Semaphore</code> 类型，内含一个阻塞队列）</li>
<li><code>P</code> 操作原语（<code>wait</code>）</li>
</ul>
<p><a href="http://narpro.top/img/image-20200404115032000.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404115032000" class="fancybox"><img alt="image-20200404115032000" title="image-20200404115032000" data-src="http://narpro.top/img/image-20200404115032000.png" class="lazyload"></a></p>
<ul>
<li><code>V</code> 操作原语（<code>signal</code>）</li>
</ul>
<p><a href="http://narpro.top/img/image-20200404115046395.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404115046395" class="fancybox"><img alt="image-20200404115046395" title="image-20200404115046395" data-src="http://narpro.top/img/image-20200404115046395.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-3-2-记录型信号量"><a href="#4-3-2-记录型信号量" class="headerlink" title="4.3.2 记录型信号量"></a>4.3.2 记录型信号量</h3><blockquote>
<ul>
<li>一个记录型信号量包含两个分量：信号量的值、信号量的等待队列指针</li>
</ul>
<p><a href="http://narpro.top/img/image-20200404114446927.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404114446927" class="fancybox"><img alt="image-20200404114446927" title="image-20200404114446927" data-src="http://narpro.top/img/image-20200404114446927.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-3-3-解决互斥问题"><a href="#4-3-3-解决互斥问题" class="headerlink" title="4.3.3 解决互斥问题"></a>4.3.3 解决互斥问题</h3><blockquote>
<ul>
<li>一种 <code>CR</code> 设置一个信号量</li>
<li>信号量的初值设置为系统初始状态 <code>CR</code> 的可用量</li>
<li><code>P</code> 操作用于临界区前，相当于进入 <code>CS</code> 之前申请 <code>CR</code> </li>
<li><code>V</code> 操作用于临界区后，相当于出临界区后释放 <code>CR</code></li>
<li><code>P</code>、<code>V</code> 操作必须成对匹配</li>
</ul>
</blockquote>
<blockquote>
<p>使用 <code>semaphore mutex</code>：这样声明的信号量 <code>mutex</code> 用于互斥问题</p>
<p><code>mutex.value</code>：</p>
<ul>
<li>目前 <code>CR</code> 有 <code>mutex.value</code> 个可用</li>
<li>目前 <code>CR</code> 没有可用的</li>
<li>目前有 <code>|mutex.value|</code> 个进程因等待该 <code>CR</code> 而阻塞</li>
</ul>
</blockquote>
<h3 id="4-3-4-解决同步问题"><a href="#4-3-4-解决同步问题" class="headerlink" title="4.3.4 解决同步问题"></a>4.3.4 解决同步问题</h3><blockquote>
<ul>
<li>一种同步信号设置一个信号量</li>
<li>信号量的初值设置问系统状态下信号的有无</li>
<li><code>P</code> 操作用于临界区前，相当于检查同步信号</li>
<li><code>V</code> 操作用于临界区后，相当于发出同步信号</li>
<li><code>P</code>、<code>V</code> 操作不成对匹配</li>
</ul>
</blockquote>
<blockquote>
<p>使用 <code>semaphore s</code>：这样生命的信号量 <code>s</code> 用于同步问题</p>
<p><code>s.value</code>：</p>
<ul>
<li>目前有 <code>s.value</code> 个 <code>s</code> 对应的同步信号</li>
<li>目前没有 <code>s</code> 对应的同步信号</li>
<li>目前有 <code>|s.value|</code> 个进程因等 <code>s</code> 对应的同步信号而阻塞</li>
</ul>
</blockquote>
<h3 id="4-3-5-互斥、同步解决方法之异同分析"><a href="#4-3-5-互斥、同步解决方法之异同分析" class="headerlink" title="4.3.5 互斥、同步解决方法之异同分析"></a>4.3.5 互斥、同步解决方法之异同分析</h3><blockquote>
<ul>
<li>信号量的设置</li>
<li>信号量的初值</li>
<li><code>P</code>、<code>V</code> 操作的含义</li>
<li><code>P</code>、<code>V</code> 操作的匹配</li>
</ul>
</blockquote>
<h3 id="4-3-6-记录型信号量解决问题的步骤"><a href="#4-3-6-记录型信号量解决问题的步骤" class="headerlink" title="4.3.6 记录型信号量解决问题的步骤"></a>4.3.6 记录型信号量解决问题的步骤</h3><blockquote>
<ul>
<li>分析问题中的进程、资源</li>
<li>分析进程间的关系</li>
<li>分别设置互斥、同步信号量</li>
<li>写出并发进程体，找出相关 <code>CS</code> </li>
<li>分别加 <code>PV</code> 操作并分析结果</li>
</ul>
</blockquote>
<h2 id="4-4-生产者与消费者问题"><a href="#4-4-生产者与消费者问题" class="headerlink" title="4.4 生产者与消费者问题"></a>4.4 生产者与消费者问题</h2><p><a href="http://narpro.top/img/image-20200404193908314.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404193908314" class="fancybox"><img alt="image-20200404193908314" title="image-20200404193908314" data-src="http://narpro.top/img/image-20200404193908314.png" class="lazyload"></a></p>
<blockquote>
<ul>
<li><code>Sin</code> 为可放入信号，初值为 n</li>
<li><code>Sout</code> 为可取信号，初值为 0</li>
</ul>
</blockquote>
<p><a href="http://narpro.top/img/image-20200404194033009.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404194033009" class="fancybox"><img alt="image-20200404194033009" title="image-20200404194033009" data-src="http://narpro.top/img/image-20200404194033009.png" class="lazyload"></a></p>
<blockquote>
<ul>
<li><strong>生产者</strong>：<ul>
<li>每放入一个产品，<code>Sin = Sin - 1</code>，<code>Sout = Sout + 1</code></li>
<li>可以看到，<code>Sin</code> 对应的是剩下空余空间的个数，<code>Sout</code> 是已放入的个数</li>
</ul>
</li>
<li><strong>消费者</strong>：<ul>
<li>每次取之前查看 <code>Sout</code>，若 <code>Sout > 0</code> 则取，否则 <code>Sout--</code> 并等待生产者放入产品</li>
<li><code>Sout = Sout - 1</code></li>
<li><code>Sin = Sin + 1</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-4-3-经典生产者-消费者问题"><a href="#4-4-3-经典生产者-消费者问题" class="headerlink" title="4.4.3 经典生产者-消费者问题"></a>4.4.3 经典生产者-消费者问题</h3><blockquote>
<ul>
<li>系统里有若干个合作的进程互斥使用由 r（ r > 0）个缓冲块组成的缓冲环，其中 n（ n > 0 ）个缓冲块组成的缓冲环，m（ m > 0 ）个消费者进程</li>
<li>任何一个生产者进程都可以将自己的产品存入环内的一个缓冲块，任何一个消费者可以将环内的一个产品去除。生产者远远不断地生产并存入产品：消费者周而复始地从环中取出产品并消费掉</li>
</ul>
<p><strong>假定使用的约束条件是</strong>：</p>
<ul>
<li>当环中有空闲缓冲块时，允许任意生产者进程把它的产品存入</li>
<li>当环中无空闲缓冲块时，则试图将产品存入缓冲区环的任何生产者进程必须阻塞等待</li>
<li>当环中尚有为取出的产品时，允许任意消费者进程把其中的一个产品取出</li>
<li>当环中没有未取出的产品时，试图从该环内取出产品的任何消费者进程必须阻塞等待</li>
</ul>
<p><strong>解决方案</strong>：</p>
<p><code>Var mutex: Semaphore: =1;</code></p>
<p><code>Var Sin,Sout: Semaphore: = n, 0;</code></p>
<p>先检查同步，如是否能放/取，再检查互斥，如是否有人在访问</p>
<ul>
<li><strong>生产者</strong>：</li>
</ul>
<p><a href="http://narpro.top/img/image-20200404224304355.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404224304355" class="fancybox"><img alt="image-20200404224304355" title="image-20200404224304355" data-src="http://narpro.top/img/image-20200404224304355.png" class="lazyload"></a></p>
<ul>
<li><strong>消费者</strong>：</li>
</ul>
<p><a href="http://narpro.top/img/image-20200404224102837.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404224102837" class="fancybox"><img alt="image-20200404224102837" title="image-20200404224102837" data-src="http://narpro.top/img/image-20200404224102837.png" class="lazyload"></a></p>
</blockquote>
<h2 id="4-5-读者写者问题"><a href="#4-5-读者写者问题" class="headerlink" title="4.5 读者写者问题"></a>4.5 读者写者问题</h2><blockquote>
<ul>
<li>有一个数据块被多个用户共享，其中一部分用户是读者，另一部分是写着</li>
<li>我们规定：读者对数据块是只读的，而且允许多个读者同时读，写着对数据块只是写的，当一个写着正在向数据块些信息的时候，不允许其他用户使用</li>
</ul>
<p><strong>进程</strong>：读者和写者</p>
<p><strong>资源</strong>：要操作的对象</p>
<p><strong>写者</strong>：跟任何一个其他的进程都互斥</p>
<p><a href="http://narpro.top/img/image-20200404234154615.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404234154615" class="fancybox"><img alt="image-20200404234154615" title="image-20200404234154615" data-src="http://narpro.top/img/image-20200404234154615.png" class="lazyload"></a></p>
<p><strong>读者</strong>：读者之间不互斥，但与写者互斥</p>
<p><a href="http://narpro.top/img/image-20200404234405639.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404234405639" class="fancybox"><img alt="image-20200404234405639" title="image-20200404234405639" data-src="http://narpro.top/img/image-20200404234405639.png" class="lazyload"></a></p>
<p><strong>解决方案</strong>：</p>
<p>为了判断 <code>reader</code> 是不是第一/最后一个，引入 counter</p>
<p><code>var mutex, Rmutex: semaphore: = 1, 1;</code></p>
<p><code>var counter: integer: = 0;</code></p>
<p><code>Parbegin Writeri(); Readerj(); Parend;</code></p>
<p><a href="http://narpro.top/img/image-20200404235055333.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404235055333" class="fancybox"><img alt="image-20200404235055333" title="image-20200404235055333" data-src="http://narpro.top/img/image-20200404235055333.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200404234908155.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404234908155" class="fancybox"><img alt="image-20200404234908155" title="image-20200404234908155" data-src="http://narpro.top/img/image-20200404234908155.png" class="lazyload"></a></p>
</blockquote>
<h2 id="4-6-理发师问题"><a href="#4-6-理发师问题" class="headerlink" title="4.6 理发师问题"></a>4.6 理发师问题</h2><blockquote>
<p>有一位理发师，一把理发椅和 <code>n</code> 把供等候理发的顾客坐的等候椅。如果没有顾客，理发师便在理发椅子上睡觉；当一个顾客到来时，唤醒理发师进行理发。如果理发师正在理发时又有新顾客到来，有空椅子可坐，他就坐下来等。如果没有空椅子，就立即离开。</p>
<p><strong>进程</strong>：理发师、顾客</p>
<p><strong>资源</strong>：理发椅、等候椅</p>
<p><strong>同步</strong>：理发师、顾客、理发椅</p>
<p><strong>互斥</strong>：顾客、顾客、等候椅</p>
<p><a href="http://narpro.top/img/image-20200404235543998.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200404235543998" class="fancybox"><img alt="image-20200404235543998" title="image-20200404235543998" data-src="http://narpro.top/img/image-20200404235543998.png" class="lazyload"></a></p>
<p>如果单纯的设置 <code>mutex</code> 为椅子的数量，当 <code>P(mutex)</code> 为 <code>-1</code> 时，进程会进入阻塞状态，与直接离开不符，故设置临界资源 <code>chairs</code> 来进行判断，当没有椅子，直接结束进程</p>
<p><code>var comming: somaphore: = 0;</code></p>
<p><code>var calling: somaphore: = 0;</code></p>
<p><code>var cutting: somaphore: = 0;</code></p>
<p><code>var finished: somaphore: = 0;</code></p>
<p><code>var chairs: integer: = n;</code></p>
<p><code>var mutex: semaphore: = 1;</code></p>
<p><strong>客户</strong>：</p>
<p><a href="http://narpro.top/img/image-20200405000820093.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405000820093" class="fancybox"><img alt="image-20200405000820093" title="image-20200405000820093" data-src="http://narpro.top/img/image-20200405000820093.png" class="lazyload"></a></p>
<p><strong>理发师</strong>：</p>
<p><a href="http://narpro.top/img/image-20200405001018453.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405001018453" class="fancybox"><img alt="image-20200405001018453" title="image-20200405001018453" data-src="http://narpro.top/img/image-20200405001018453.png" class="lazyload"></a></p>
</blockquote>
<h2 id="4-7-哲学家就餐问题"><a href="#4-7-哲学家就餐问题" class="headerlink" title="4.7 哲学家就餐问题"></a>4.7 哲学家就餐问题</h2><blockquote>
<p><a href="http://narpro.top/img/image-20200405001123263.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405001123263" class="fancybox"><img alt="image-20200405001123263" title="image-20200405001123263" data-src="http://narpro.top/img/image-20200405001123263.png" class="lazyload"></a></p>
<p><strong>进程</strong>：哲学家</p>
<p><strong>资源</strong>：筷子</p>
</blockquote>
<h3 id="4-7-1-错误算法"><a href="#4-7-1-错误算法" class="headerlink" title="4.7.1 错误算法"></a>4.7.1 错误算法</h3><blockquote>
<p>如果所有哲学家同时饿了想吃面，则每个人都只拿到一只，进入阻塞状态，形成死锁</p>
<p><a href="http://narpro.top/img/image-20200405001316753.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405001316753" class="fancybox"><img alt="image-20200405001316753" title="image-20200405001316753" data-src="http://narpro.top/img/image-20200405001316753.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-7-1-算法一"><a href="#4-7-1-算法一" class="headerlink" title="4.7.1 算法一"></a>4.7.1 算法一</h3><blockquote>
<p>控制同时能吃面的人数</p>
<p><a href="http://narpro.top/img/image-20200405001618880.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405001618880" class="fancybox"><img alt="image-20200405001618880" title="image-20200405001618880" data-src="http://narpro.top/img/image-20200405001618880.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-7-2-算法二"><a href="#4-7-2-算法二" class="headerlink" title="4.7.2 算法二"></a>4.7.2 算法二</h3><blockquote>
<p>给椅子编号，奇数上的先拿左筷子，偶数位的先拿右筷子</p>
<p><strong>奇数位</strong>：</p>
<p><a href="http://narpro.top/img/image-20200405001838365.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405001838365" class="fancybox"><img alt="image-20200405001838365" title="image-20200405001838365" data-src="http://narpro.top/img/image-20200405001838365.png" class="lazyload"></a></p>
<p><strong>偶数位</strong>：</p>
<p><a href="http://narpro.top/img/image-20200405001901741.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405001901741" class="fancybox"><img alt="image-20200405001901741" title="image-20200405001901741" data-src="http://narpro.top/img/image-20200405001901741.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-7-4-算法三"><a href="#4-7-4-算法三" class="headerlink" title="4.7.4 算法三"></a>4.7.4 算法三</h3><blockquote>
<p>要么两根一起拿，要么一根也不拿，设新的信号量机制：<strong>[ AND型 ] 信号量集机制</strong></p>
<p><strong>信号量集机制</strong>：</p>
<ul>
<li>用一个 <code>P</code> 操作，可以同时申请到两个或多个临界资源</li>
<li>用一个 <code>V</code> 操作，可以释放两个或多个临界资源</li>
</ul>
<p><strong>信号量集机制设计需求</strong>：</p>
<ul>
<li><code>P</code> 原语具有同时给多个信号量减 <code>1</code> 的功能</li>
<li>只有各个信号量都是绿灯才减 <code>1</code> 进入临界区</li>
<li>任意信号量是红灯，进程都要让权等待</li>
<li>并将 <code>P</code> 原语的第一条指令作为断电地址，保存到该进程的 <code>PCB</code> 中，等回复运行时重新执行 <code>P</code> 原语</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405002550084.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405002550084" class="fancybox"><img alt="image-20200405002550084" title="image-20200405002550084" data-src="http://narpro.top/img/image-20200405002550084.png" class="lazyload"></a></p>
</blockquote>
<h2 id="4-8-管程机制"><a href="#4-8-管程机制" class="headerlink" title="4.8 管程机制"></a>4.8 管程机制</h2><blockquote>
<p>管程是由局部数据结构、多个处理过程和一套初始化代码组成的模块</p>
<ul>
<li>这是一种具有面向对象程序设计思想的同步机制</li>
<li>它提供了与信号量机制相同的功能</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405003242911.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405003242911" class="fancybox"><img alt="image-20200405003242911" title="image-20200405003242911" data-src="http://narpro.top/img/image-20200405003242911.png" class="lazyload"></a></p>
<p><strong>特征</strong>：</p>
<ul>
<li>管程内的数据结构只能被管程内的过程访问，任何外部访问都是不允许的</li>
<li>进程可通过调用管程的一个过程进入管程</li>
<li>任何时间只允许一个进程进入管程，其他要求进入管程的进程统统被阻塞到等待管程的队列上</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405003603359.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405003603359" class="fancybox"><img alt="image-20200405003603359" title="image-20200405003603359" data-src="http://narpro.top/img/image-20200405003603359.png" class="lazyload"></a></p>
<p><strong>要素</strong>：</p>
<ul>
<li>条件变量：关联一个阻塞队列</li>
<li><code>P</code>：当遇到同步约束，将执行该操作的进程阻塞在条件变量关联的阻塞队列上</li>
<li><code>V</code>：从条件变量关联的阻塞队列上唤醒一个进程，让他恢复运行，若队列上没有进程在等待，就什么也不做</li>
</ul>
</blockquote>
<h3 id="4-8-1-管程解决生产者与消费者问题"><a href="#4-8-1-管程解决生产者与消费者问题" class="headerlink" title="4.8.1 管程解决生产者与消费者问题"></a>4.8.1 管程解决生产者与消费者问题</h3><blockquote>
<ul>
<li>定义一个数组 <code>buffer</code>：表示用于传递产品的缓冲区环</li>
<li>定义局部变量 <code>in</code>、<code>out</code>：表示在缓冲区环中生产者放的文职、消费者取的位置</li>
<li>定义变量 <code>counter</code>：记录缓冲区环中产品的数量</li>
<li>定义 <code>full</code>：生产者的条件变量。当一个试图存放产品的生产者发现缓冲区环已满时，执行 <code>P(full)</code> 将之组赛道 <code>full</code> 的关联队列上</li>
<li>定义 <code>empty</code>：消费者的条件变量。当一个试图取产品的消费者发现缓冲区环已空时，执行 <code>P(empty)</code> 将之阻塞到 <code>empty</code> 的关联队列上</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>定义管程</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405004657806.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405004657806" class="fancybox"><img alt="image-20200405004657806" title="image-20200405004657806" data-src="http://narpro.top/img/image-20200405004657806.png" class="lazyload"></a></p>
<ul>
<li>PUT()</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405004844226.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405004844226" class="fancybox"><img alt="image-20200405004844226" title="image-20200405004844226" data-src="http://narpro.top/img/image-20200405004844226.png" class="lazyload"></a></p>
<ul>
<li>GET()</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405004939262.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405004939262" class="fancybox"><img alt="image-20200405004939262" title="image-20200405004939262" data-src="http://narpro.top/img/image-20200405004939262.png" class="lazyload"></a></p>
<ul>
<li>生产者与消费者</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405004752136.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405004752136" class="fancybox"><img alt="image-20200405004752136" title="image-20200405004752136" data-src="http://narpro.top/img/image-20200405004752136.png" class="lazyload"></a></p>
</blockquote>
<h2 id="4-9-死锁的发生与描述"><a href="#4-9-死锁的发生与描述" class="headerlink" title="4.9 死锁的发生与描述"></a>4.9 死锁的发生与描述</h2><blockquote>
<p>一组相互竞争系统资源或者进行通信的进程间的永久性阻塞</p>
</blockquote>
<h3 id="4-9-1-现象"><a href="#4-9-1-现象" class="headerlink" title="4.9.1 现象"></a>4.9.1 现象</h3><blockquote>
<ul>
<li>每个进程获得了一部分资源，又申请另外的资源，得不到而转入阻塞</li>
<li>若无外力作用，这些进程会一直阻塞下去</li>
</ul>
</blockquote>
<h3 id="4-9-2-死锁的危害"><a href="#4-9-2-死锁的危害" class="headerlink" title="4.9.2 死锁的危害"></a>4.9.2 死锁的危害</h3><blockquote>
<ul>
<li>陷入死锁圈的进程无限期阻塞等待</li>
<li>陷入死锁圈的资源被浪费</li>
<li>更多进程卷入死锁</li>
<li>甚至系统死机</li>
</ul>
</blockquote>
<h3 id="4-9-3-产生死锁的原因"><a href="#4-9-3-产生死锁的原因" class="headerlink" title="4.9.3 产生死锁的原因"></a>4.9.3 产生死锁的原因</h3><blockquote>
<ul>
<li>动态资源分配策略</li>
<li>资源可用数量少于需求数量</li>
<li>进程并发过程的偶然因素</li>
</ul>
</blockquote>
<h3 id="4-9-4-必要条件"><a href="#4-9-4-必要条件" class="headerlink" title="4.9.4 必要条件"></a>4.9.4 必要条件</h3><blockquote>
<ul>
<li>互斥条件：进程请求的资源属于临界资源，每一瞬间只能由一个进程使用，其他申请该资源的进程等待</li>
<li>不可剥夺条件：进程获得某资源后，便一直占有她，知道用完为止才释放，其他进程不可剥夺</li>
<li>请求和保持条件：允许一个进程在保持已有资源不放弃的情况下，进一步请求新资源，被阻塞时也不会释放已有的资源</li>
<li>环路等待条件：一组进程的占有资源情况与请求资源情况构成一个环形链，比如 <code>P1</code> 等待 <code>P2</code> 的资源，<code>P2</code> 等待 <code>P3</code> 的资源，<code>P3</code> 等待 <code>P1</code> 的资源</li>
</ul>
</blockquote>
<h3 id="4-9-5-资源请求分配图"><a href="#4-9-5-资源请求分配图" class="headerlink" title="4.9.5 资源请求分配图"></a>4.9.5 资源请求分配图</h3><p><a href="http://narpro.top/img/image-20200405010345103.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405010345103" class="fancybox"><img alt="image-20200405010345103" title="image-20200405010345103" data-src="http://narpro.top/img/image-20200405010345103.png" class="lazyload"></a></p>
<h3 id="4-9-6-资源请求分配矩阵"><a href="#4-9-6-资源请求分配矩阵" class="headerlink" title="4.9.6 资源请求分配矩阵"></a>4.9.6 资源请求分配矩阵</h3><blockquote>
<ul>
<li><p>若有 n 个进程，m 类资源，则首先设置三个 n × m 的二维矩阵</p>
<ul>
<li>需求总量矩阵 <code>Max[][]</code></li>
<li>资源占有矩阵 <code>Allocation[][]</code></li>
<li>尚需矩阵 <code>Need[][]</code></li>
<li>如，<code>Need[i][j]</code> 标识进程 i 尚需第 j 类资源的数量为 k 个</li>
</ul>
</li>
<li><p>另设几个一维数组</p>
<ul>
<li>资源总量数组 <code>Total[]</code></li>
<li>可用（剩余）资源数组 <code>Available[]</code></li>
<li>申请资源数组 <code>Request[]</code></li>
</ul>
</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405011711912.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405011711912" class="fancybox"><img alt="image-20200405011711912" title="image-20200405011711912" data-src="http://narpro.top/img/image-20200405011711912.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-9-7-死锁的解决方法"><a href="#4-9-7-死锁的解决方法" class="headerlink" title="4.9.7 死锁的解决方法"></a>4.9.7 死锁的解决方法</h3><blockquote>
<ul>
<li>事前处理：针对性采取措施，让死锁没有机会发生<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li>事后处理：及时检测、及时解除<ul>
<li>死锁检测</li>
<li>死锁解除</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="4-10-死锁的预防"><a href="#4-10-死锁的预防" class="headerlink" title="4.10 死锁的预防"></a>4.10 死锁的预防</h2><blockquote>
<p>通过破坏死锁的必要条件，只要有一个不满足，就不会发生死锁</p>
<ul>
<li>互斥条件：互斥条件共享资源不能改成同时共享，破坏该条件行不通</li>
<li>不可剥夺条件：互斥共享资源被剥夺后，进程需要重新执行，破坏该条件行不通</li>
<li>请求和保持条件：进程运行整个过程中所需资源要申请就一次性全部申请，要不就不申请<ul>
<li>静态资源分配策略<ul>
<li>两个关键字：<ul>
<li>一次性</li>
<li>全部</li>
</ul>
</li>
<li>两个要点：<ul>
<li>在进程运行开始前，一次性申请全部所需资源</li>
<li>在进程运行结束时，一次性释放全部所占资源</li>
</ul>
</li>
<li>缺点：<ul>
<li>资源有效利用率会降低</li>
<li>进程并发推进的速度会降低</li>
</ul>
</li>
<li>优点：<ul>
<li>进程一定不会发生死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>环路等待条件：给资源排一个序号，按照从小到大或从大到小的顺序申请资源<ul>
<li>按序资源分配策略：即要用某个资源时，在后期还会用到另一个资源，序号比这个小或大，则先申请后面所需的，再来申请当前想要的，如果后面所需的没有获取到，也不会去申请当前想要的</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="4-11-死锁避免"><a href="#4-11-死锁避免" class="headerlink" title="4.11 死锁避免"></a>4.11 死锁避免</h2><blockquote>
<p>在每个进程的每次提出动态资源申请时，加设银行家算法，以决定是否满足该请求</p>
</blockquote>
<h3 id="4-11-1-银行家算法的思路"><a href="#4-11-1-银行家算法的思路" class="headerlink" title="4.11.1 银行家算法的思路"></a>4.11.1 银行家算法的思路</h3><blockquote>
<ul>
<li>银行家拥有一笔周转资金，客户申请贷款</li>
<li>检查客户信用，了解客户投资前进，判断有无出现呆账坏账的危险</li>
<li>确无危险，才贷出</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405013707384.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405013707384" class="fancybox"><img alt="image-20200405013707384" title="image-20200405013707384" data-src="http://narpro.top/img/image-20200405013707384.png" class="lazyload"></a></p>
<p>前提是系统采用动态资源分配策略，每个进程提出资源申请时加一道检查，假设分配，检查系统是否安全，安全则实施分配，不安全则不分配，进程阻塞等待</p>
<p><strong>何谓安全</strong></p>
<ul>
<li>安全状态不是死锁状态</li>
<li>安全状态是没有死锁危险的状态</li>
<li>死锁状态是不安全状态</li>
<li>不是所有不安全状态都是死锁状态</li>
</ul>
<p><strong>如何判断</strong></p>
<ul>
<li>在当前状态下至少能找到一个安全序列即为安全状态</li>
<li>当前状态下没有安全序列</li>
<li><strong>安全序列</strong>：各进程能依次满足资源需求并运行完成的一个序列</li>
</ul>
</blockquote>
<h3 id="4-11-2-银行家算法的数据结构"><a href="#4-11-2-银行家算法的数据结构" class="headerlink" title="4.11.2 银行家算法的数据结构"></a>4.11.2 银行家算法的数据结构</h3><blockquote>
<ul>
<li>需求总量矩阵 <code>Max[][]</code></li>
<li>资源占有矩阵 <code>Allocation[][]</code></li>
<li>尚需矩阵 <code>Need[][]</code></li>
<li>资源总量数组 <code>Total[]</code></li>
<li>可用资源数组 <code>Available[]</code></li>
<li>申请资源数组 <code>Request[]</code></li>
<li>安全检查过程中记录 <code>Available[]</code> 的变化</li>
<li>安全检查过程中记录各个进程是否能完成 <code>Finished[]</code></li>
</ul>
<p><a href="http://narpro.top/img/image-20200405014955551.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405014955551" class="fancybox"><img alt="image-20200405014955551" title="image-20200405014955551" data-src="http://narpro.top/img/image-20200405014955551.png" class="lazyload"></a></p>
</blockquote>
<h3 id="4-11-3-银行家算法的步骤"><a href="#4-11-3-银行家算法的步骤" class="headerlink" title="4.11.3 银行家算法的步骤"></a>4.11.3 银行家算法的步骤</h3><blockquote>
<ul>
<li>检查请求是否合法</li>
<li>检查系统可用资源是否足够</li>
<li>再假定分配，检查系统是否有发生死锁的危险，无危险则分配，有危险则不分配，让进程阻塞等待</li>
</ul>
</blockquote>
<h3 id="4-11-4-银行家算法的应用"><a href="#4-11-4-银行家算法的应用" class="headerlink" title="4.11.4 银行家算法的应用"></a>4.11.4 银行家算法的应用</h3><blockquote>
<p>设系统有 3 类资源，5 个活跃的进程 <code>Total=(10,5,7)</code></p>
<p><a href="http://narpro.top/img/image-20200405015440632.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405015440632" class="fancybox"><img alt="image-20200405015440632" title="image-20200405015440632" data-src="http://narpro.top/img/image-20200405015440632.png" class="lazyload"></a></p>
<ul>
<li><p>问：当前系统是否安全？</p>
<ul>
<li>求出 <code>Need[]</code></li>
</ul>
<p><a href="http://narpro.top/img/image-20200405015609081.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405015609081" class="fancybox"><img alt="image-20200405015609081" title="image-20200405015609081" data-src="http://narpro.top/img/image-20200405015609081.png" class="lazyload"></a></p>
<ul>
<li>通过<code>系统本来的资源数量 - 已分配出去的资源数量</code> 的到系统当前可用为 <code>[3,3,2]</code></li>
</ul>
<p><a href="http://narpro.top/img/image-20200405015830836.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405015830836" class="fancybox"><img alt="image-20200405015830836" title="image-20200405015830836" data-src="http://narpro.top/img/image-20200405015830836.png" class="lazyload"></a></p>
<ul>
<li>最后可找出安全序列</li>
</ul>
</li>
<li><p>若某一进程提出请求，该如何调用银行家算法：</p>
<ul>
<li>如果 <code>request > Need</code>，该进程的本次请求超过了它所宣布的最大值，系统拒绝分配，出错返回 <code>Return(ERROR)</code></li>
<li>如果 <code>request > Available</code>，表明系统当前的可用资源不能满足该进程的请求，应推迟分配，将该进程阻塞等待</li>
<li>做假定<ul>
<li><code>Available = Available - request;</code></li>
<li><code>Allocation = Allocation + request;</code> </li>
<li><code>Need = Need - request</code></li>
</ul>
</li>
<li>调用安全算法，测试系统是否为安全状态，如果返回 <code>TRUE</code>，则表示安全，进行分配，否则将第三步的作废，回复第三步之前的状态，让该进程阻塞等待</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="五、存储管理篇"><a href="#五、存储管理篇" class="headerlink" title="五、存储管理篇"></a>五、存储管理篇</h1><h2 id="5-1-存储管理概述"><a href="#5-1-存储管理概述" class="headerlink" title="5.1 存储管理概述"></a>5.1 存储管理概述</h2><blockquote>
<p><a href="http://narpro.top/img/image-20200405160423647.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405160423647" class="fancybox"><img alt="image-20200405160423647" title="image-20200405160423647" data-src="http://narpro.top/img/image-20200405160423647.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200405160453146.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405160453146" class="fancybox"><img alt="image-20200405160453146" title="image-20200405160453146" data-src="http://narpro.top/img/image-20200405160453146.png" class="lazyload"></a></p>
<p><strong>目标</strong>：</p>
<ul>
<li>内存的合理分配使用</li>
<li>提高内存利用率</li>
<li>程序、数据在内存中顺利读写</li>
<li>小内存运行大程序</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>内存的分配和回收</li>
<li>地址重定位</li>
<li>地址共享和保护</li>
<li>地址扩充</li>
</ul>
</blockquote>
<h3 id="5-1-1-内存的分配和回收"><a href="#5-1-1-内存的分配和回收" class="headerlink" title="5.1.1 内存的分配和回收"></a>5.1.1 内存的分配和回收</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200405160803650.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405160803650" class="fancybox"><img alt="image-20200405160803650" title="image-20200405160803650" data-src="http://narpro.top/img/image-20200405160803650.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-1-2-地址重定位"><a href="#5-1-2-地址重定位" class="headerlink" title="5.1.2 地址重定位"></a>5.1.2 地址重定位</h3><blockquote>
<ul>
<li>将逻辑地址转换为物理地址</li>
<li>物理地址：存储单元的实际物理单元地址</li>
<li>逻辑地址：用户空间中使用的相对地址</li>
</ul>
<p><strong>分类</strong>：</p>
<ul>
<li>静态重定位<ul>
<li>地址转换工作在进程执行前一次完成</li>
<li>无需硬件支持，易于实现，但不允许程序在执行过程中移动</li>
</ul>
</li>
<li>动态重定位<ul>
<li>地址转换推迟到最后的可能时刻，即进程执行时才完成</li>
<li>允许程序在主存中移动过，便于主存共存，主存利用率高</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-1-3-地址共享与保护"><a href="#5-1-3-地址共享与保护" class="headerlink" title="5.1.3 地址共享与保护"></a>5.1.3 地址共享与保护</h3><blockquote>
<p><strong>共享的含义</strong>：</p>
<ul>
<li>共享内存储器资源，让多个进程同时进入内存区域，共享一个存储器</li>
<li>共享内存储器的某些区域，即允许两个或多个进程访问内存中的同一段程序或数据</li>
</ul>
<p><strong>保护的含义</strong>：</p>
<ul>
<li>用户进程不能访问或修改系统区</li>
<li>用户进程不能访问或修改其他进程的用户区</li>
</ul>
<p><strong>保护的方法</strong>：</p>
<ul>
<li><p>存储键保护：</p>
<ul>
<li>系统将主存划分为大小相等的若干存储块，并给每个存储块都分配一个单独的保护键（锁）</li>
<li>在程序状态字 <code>PSW</code> 中设置有保护键字段，对不同作业赋予不同的代码（钥匙），钥匙和锁相匹配才允许访问</li>
</ul>
</li>
<li><p>界限寄存器：</p>
<ul>
<li>上下界防护：硬件为分给用户作业的连续的主存空间设置为一对上下界，分别指向该存储空间的上下界</li>
<li>基址、限长防护：基址寄存器存放当前正执行着的程序地址空间所占分区的始址，限长寄存器存放该地址空间的长度</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-1-4-地址扩充"><a href="#5-1-4-地址扩充" class="headerlink" title="5.1.4 地址扩充"></a>5.1.4 地址扩充</h3><blockquote>
<p>内存容量是有限的，当内存资源不能满足用户作业需求时，就需要对内存进行扩充，内存扩充不是硬件上的扩充，而是用存储管理软件来实现的逻辑扩充</p>
<ul>
<li>覆盖技术</li>
<li>对换技术</li>
<li>虚拟存储技术</li>
</ul>
</blockquote>
<h3 id="5-1-5-存储管理方法"><a href="#5-1-5-存储管理方法" class="headerlink" title="5.1.5 存储管理方法"></a>5.1.5 存储管理方法</h3><blockquote>
<ul>
<li><strong>连续存储管理</strong><ul>
<li><strong>单一连续区方式</strong>：内存用户区的全部空间只存放一个进程</li>
<li><strong>多分区方式</strong>：内存被分为多个分区，每个分区存放一个进程<ul>
<li>固定多分区</li>
<li>动态多分区</li>
</ul>
</li>
</ul>
</li>
<li><strong>非连续存储管理</strong><ul>
<li><strong>分页方式</strong>：内存被划分为多个等长的存储块，每个进程占用其中若干块，整个内存允许有多个进程同时驻留</li>
<li><strong>分段方式</strong>：对分段结构的应用程序，按照段长度分别为之分配内存空间</li>
<li><strong>段页方式</strong>：在分段管理的基础上加分页式管理形成的管理方式</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="5-2-程序的编译链接与地址重定位"><a href="#5-2-程序的编译链接与地址重定位" class="headerlink" title="5.2 程序的编译链接与地址重定位"></a>5.2 程序的编译链接与地址重定位</h2><blockquote>
<p><strong>地址重定位</strong>：又叫地址转换，将逻辑地址转换称物理地址</p>
<p><a href="http://narpro.top/img/image-20200405221258085.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405221258085" class="fancybox"><img alt="image-20200405221258085" title="image-20200405221258085" data-src="http://narpro.top/img/image-20200405221258085.png" class="lazyload"></a></p>
<p><strong>静态重定位</strong>：</p>
<ul>
<li>地址转换工作在进程执行前一次完成</li>
<li>无需硬件支持，易于实现，但不允许程序在执行过程中移动</li>
</ul>
<p><strong>动态重定位</strong>：</p>
<ul>
<li>地址转换推迟到最后的可能时刻，即进程执行时才完成</li>
<li>允许程序在主存中移动，便于主存共存，主存利用率高</li>
</ul>
<p><a href="http://narpro.top/img/image-20200405221625610.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405221625610" class="fancybox"><img alt="image-20200405221625610" title="image-20200405221625610" data-src="http://narpro.top/img/image-20200405221625610.png" class="lazyload"></a></p>
</blockquote>
<h2 id="5-3-连续分区存储结构"><a href="#5-3-连续分区存储结构" class="headerlink" title="5.3 连续分区存储结构"></a>5.3 连续分区存储结构</h2><blockquote>
<p><strong>实质特点</strong>：一个进程装入连续的一块内存空间</p>
</blockquote>
<h3 id="5-3-1-单分区方式"><a href="#5-3-1-单分区方式" class="headerlink" title="5.3.1 单分区方式"></a>5.3.1 单分区方式</h3><blockquote>
<ul>
<li>内存用户区的全部空间只存放一个进程</li>
</ul>
</blockquote>
<h3 id="5-3-2-多分区方式"><a href="#5-3-2-多分区方式" class="headerlink" title="5.3.2 多分区方式"></a>5.3.2 多分区方式</h3><blockquote>
<p>内存被分为多个分区，每个分区存放一个进程。每个瞬间可有多个进程驻留在内存的不同分区中</p>
<ul>
<li>固定多分区</li>
<li>动态多分区</li>
</ul>
</blockquote>
<h3 id="5-3-3-主存分配表"><a href="#5-3-3-主存分配表" class="headerlink" title="5.3.3 主存分配表"></a>5.3.3 主存分配表</h3><blockquote>
<p><code>Memory Allocation Table (MAT)</code></p>
<ul>
<li>分区号：每个分区都有一个编号，用以区别不同分区</li>
<li>起始地址：分区的起始地址，即首地址</li>
<li>长度：分区的总长，一般以 <code>KB</code> 为单位</li>
<li>占用标志：记录分区的使用状态，若占用标志为 0，表明该分区空闲，可进行分配</li>
</ul>
<p><strong>MAT 表</strong></p>
<p><a href="http://narpro.top/img/image-20200405222339773.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405222339773" class="fancybox"><img alt="image-20200405222339773" title="image-20200405222339773" data-src="http://narpro.top/img/image-20200405222339773.png" class="lazyload"></a></p>
<p><strong>空闲分区链</strong>：是 <code>MAT</code> 的子表，只包含空闲分区</p>
<p><a href="http://narpro.top/img/image-20200405222414299.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200405222414299" class="fancybox"><img alt="image-20200405222414299" title="image-20200405222414299" data-src="http://narpro.top/img/image-20200405222414299.png" class="lazyload"></a></p>
<ul>
<li><strong>分配</strong>：通过空闲分区链快速搜索内存的空闲区，从中找出最合适的分区分配出去，将该节点从链上删除</li>
<li><strong>回收</strong>：按其地址或者大小在链中找到合适的位置，插入一个新节点，若存在相邻的空闲区，则需要的花可将相邻空闲区合并</li>
</ul>
</blockquote>
<h3 id="5-3-4-主存分配算法"><a href="#5-3-4-主存分配算法" class="headerlink" title="5.3.4 主存分配算法"></a>5.3.4 主存分配算法</h3><blockquote>
<ul>
<li>首次适合算法 <code>First_Fit</code><ul>
<li>也称最早适应算法，系统将内存分区按地址递增顺序登记到内存分配表或其他数据结构中</li>
<li>每次进行内存分配时，系统根据进程申请空间的大小，从头到尾顺序扫描内存分配表，从中找到的第一块能够满足要求的空闲区，就立即分配出去</li>
</ul>
</li>
<li>循环首次适应算法 <code>Circle_First_Fit</code><ul>
<li>该算法的思想是，每次存储分配总是从上次分配的位置开始，向尾部查找，查到的第一块可满足用户需求的空闲空间，分配给用户。当查到尾部仍没有合适的，转到头部继续 </li>
<li>为什么要从上次分配的位置开始？<ul>
<li>因为在一些需求不大的系统上，高序号的地址长期得不到调用，如果长时间不用，故障率会长时间提高。</li>
</ul>
</li>
</ul>
</li>
<li>最佳适应算法 <code>Best_Fit</code><ul>
<li>在内存分配时，从空闲分配去找到一块满足进程需求的最小空闲区分配给他</li>
<li>这种做法减少了将大空闲区进行多次分割造成的空间浪费，但容易形成一些很小的碎片无法使用，同样不能提高内存利用率。另外，每次分配时都要对整个内存区进行从头到尾的搜索，系统开销大</li>
</ul>
</li>
<li>最坏适应算法 <code>Worst_Fit</code><ul>
<li>在内存分配时，从空闲分区表中找到一个满足长度要求的最大空闲区进行分配</li>
<li>这种算法部分缓解了由外碎片引起的浪费，适合于中小作业的运行，但对大作业的运行是不利的。与最佳适应算法一样，每次分配需要搜索一遍内存，效率会受到一定影响</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="5-4-固定多分区存储管理"><a href="#5-4-固定多分区存储管理" class="headerlink" title="5.4 固定多分区存储管理"></a>5.4 固定多分区存储管理</h2><h3 id="5-4-1-单分区存储管理"><a href="#5-4-1-单分区存储管理" class="headerlink" title="5.4.1 单分区存储管理"></a>5.4.1 单分区存储管理</h3><blockquote>
<p>这种存储管理非常简单，适用于单用户单任务系统</p>
<p><strong>基本原理</strong>：把内存的用户区视为一个独立的连续存储区，任何时刻只将他分给一个作业使用</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>因为任何时刻最多只有一个程序独占内存，无论在该程序执行过程中，还是 <code>CPU</code> 等待 <code>I/O</code> 时都不能让其他用户使用<ul>
<li><code>CPU</code> 利用率不高</li>
<li>外设利用率低</li>
</ul>
</li>
<li>进入系统运行的作业所要求的存储空间较小时，剩余较大的空白区未被利用，只能白白浪费</li>
</ul>
</blockquote>
<h3 id="5-4-2-固定多分区存储管理"><a href="#5-4-2-固定多分区存储管理" class="headerlink" title="5.4.2 固定多分区存储管理"></a>5.4.2 固定多分区存储管理</h3><blockquote>
<p><strong>基本原理</strong>：</p>
<ul>
<li>将内存用户区划分成多个大小相等或不等的固定分区，每一个分区可以装入一个进程。这样，内存中可同时容纳若干个进程</li>
<li><code>MAT</code> 表可以用静态数组实现</li>
</ul>
<p><strong>分区要求</strong>：</p>
<ul>
<li>分区大小可以相等，也可以不等</li>
<li>每个分区的起始地址和长度时固定的</li>
</ul>
<p><strong>有可能出现的问题</strong>：</p>
<ul>
<li>大的进程无法装入</li>
<li>效地进程装入大分区出现内部碎片</li>
</ul>
<p><a href="http://narpro.top/img/image-20200406124528958.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200406124528958" class="fancybox"><img alt="image-20200406124528958" title="image-20200406124528958" data-src="http://narpro.top/img/image-20200406124528958.png" class="lazyload"></a></p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>主存分配采用 <code>Best_Fit</code></li>
<li>地址重定位采用 <strong>静态重定位</strong>，因为固定多分区不许迁移</li>
<li>地址保护可以用 <strong>上下限</strong>，也可以采用 <strong>基址限长</strong></li>
</ul>
<p><strong>缺陷</strong>：</p>
<ul>
<li>分区数目实现确定，限制了系统中活动进程的数目</li>
<li>分区大小在系统生成阶段实现设置，大作业有可能无法装入，小进程不能有效地利用分区空间</li>
<li><strong>内碎片</strong> 现象降低了内存有效利用率</li>
</ul>
</blockquote>
<h3 id="5-4-3-动态多分区存储管理（可变分区）"><a href="#5-4-3-动态多分区存储管理（可变分区）" class="headerlink" title="5.4.3 动态多分区存储管理（可变分区）"></a>5.4.3 动态多分区存储管理（可变分区）</h3><blockquote>
<p><strong>基本原理</strong>：</p>
<ul>
<li>系统不预先划分固定分区，而是在装入进程时根据进程的实际需求量划分出一个分区给他使用</li>
<li><code>MAT</code> 表需要用动态数组实现</li>
</ul>
<p><strong>分配方式</strong>：将一个存储容量为 n 的内存空间，根据进程所需容量 x，划分成 x、n - x 两部分，x 部分分配给进程，n - x 部分记为未分配</p>
<p><strong>回收方式</strong>：将多个连续的空闲分区组合在一起</p>
<ul>
<li>主存分配采用 <code>Worst_Fit</code></li>
<li>地址重定位采用动态重定位</li>
</ul>
</blockquote>
<h2 id="5-5-基本分页存储管理"><a href="#5-5-基本分页存储管理" class="headerlink" title="5.5 基本分页存储管理"></a>5.5 基本分页存储管理</h2><blockquote>
<p><strong>基本原理</strong>：</p>
<ul>
<li>内存呢被划分成大小固定相等的块（Frame帧/页框/主存块）且块相对比较小</li>
<li>每个进程装入时被分成同样大小的页（Page）一页装入一帧</li>
<li>整个进程被离散装入到多个不连续的帧</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>离散存储，利于大进程装入</li>
<li>只有很少的页内碎片，提高内存利用率</li>
<li><code>DS</code>：位示图、页表：动态地址重定位</li>
<li>页面共享不易实现</li>
</ul>
</blockquote>
<h3 id="5-5-1-位视图"><a href="#5-5-1-位视图" class="headerlink" title="5.5.1 位视图"></a>5.5.1 位视图</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200406192126768.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200406192126768" class="fancybox"><img alt="image-20200406192126768" title="image-20200406192126768" data-src="http://narpro.top/img/image-20200406192126768.png" class="lazyload"></a></p>
<ul>
<li>通过在位视图中查找值为 0 的帧</li>
<li>设 i 为字，j 为位，k 为帧，L 为字长<ul>
<li>k = i * j;</li>
<li>i = k / L;</li>
<li>j = K % L;</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-5-2-页表"><a href="#5-5-2-页表" class="headerlink" title="5.5.2 页表"></a>5.5.2 页表</h3><blockquote>
<p>为了保证程序的正确运行，分页管理机制应为每个进程一个数据结构——页表，页表中等级进程各页面对应的帧号，供地址映射使用</p>
<p><a href="http://narpro.top/img/image-20200406192709936.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200406192709936" class="fancybox"><img alt="image-20200406192709936" title="image-20200406192709936" data-src="http://narpro.top/img/image-20200406192709936.png" class="lazyload"></a></p>
<p><strong>页面分配算法</strong>：</p>
<ul>
<li>计算请求者需要的总帧数 N</li>
<li>查位图，若找不到足够的空闲帧，编制分配失败报告返回</li>
<li>索取一个空闲页表</li>
<li>从位图中找出 N 个为 0 位，计算出对应的帧号，填入 <code>PT</code></li>
<li>位示图中将这些位改为 1</li>
<li>将 <code>PT</code> 起始地址填入进程 <code>PCB</code></li>
<li>结束</li>
</ul>
<p><strong>地址划分</strong>：</p>
<ul>
<li>进程装入之前，逻辑地址是一维的</li>
<li>进程装入之后，逻辑地址分为两维</li>
<li>例题：若机器的地址码是 16 位，页面长度是 1KB <ul>
<li>求划分结果<ul>
<li>总长度 16 位，每页 1KB，即每页需要 10 个二进制位来表示</li>
<li>总共 16 位，其中 10 位拿来表示页内地址，那么还剩 6 位作为页号</li>
<li>6 位做也好也就是说总共可以分 2 <sup>6</sup> = 64 页</li>
</ul>
</li>
<li>求允许进程最大空间<ul>
<li>64 页，每页 1KB，则说明最大 64KB</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-5-3-地址重定位"><a href="#5-5-3-地址重定位" class="headerlink" title="5.5.3 地址重定位"></a>5.5.3 地址重定位</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200406194938598.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200406194938598" class="fancybox"><img alt="image-20200406194938598" title="image-20200406194938598" data-src="http://narpro.top/img/image-20200406194938598.png" class="lazyload"></a></p>
<ul>
<li>页表寄存器：寄存当前正在 <code>CPU</code> 执行的进程的起始地址和页表的长度（分页数）</li>
<li>转换：根据逻辑地址的页号取出对应的帧，然后与偏移量放在一起表示物理地址</li>
<li><strong>内存保护</strong>：<ul>
<li>在根据页号取帧之前进行第一次，查看该页号是不是合法页号，即有没有在页表的行之内</li>
<li>在偏移量与帧相加时对偏移量进行第二次，查看该偏移量是不是合法的长度，即有没有在页表的列之内</li>
<li>在二者相加之后进行第三次，查看要做的操作，地址合不合法</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="5-6-基本分段存储管理"><a href="#5-6-基本分段存储管理" class="headerlink" title="5.6 基本分段存储管理"></a>5.6 基本分段存储管理</h2><blockquote>
<ul>
<li>段是一个逻辑单位，是进程的一个组成部分。如主程序段、子程序段、数据段</li>
<li>在结构程序设计中，进程自然分段</li>
<li>用户源程序使用的符号地址是二维的：<段名，变量名></li>
<li>翻译之后的逻辑地址是二维的：<段号，段内地址></li>
</ul>
<p><strong>原理</strong>：</p>
<ul>
<li>进程的程序和其相关的数据按逻辑分段</li>
<li>段有一个最大长度限制，但不要求所有程序的所有段的长度都相等</li>
<li>一段占用一块连续存储区</li>
<li>各段占用不连续分区</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>离散存储，一段连续装，各段不连续</li>
<li>内存仍然按分区管理，会产生外碎片</li>
<li><code>DS</code>：<code>MAT</code>、段表，动态地址重定位</li>
<li>分段共享非常方便</li>
</ul>
</blockquote>
<h3 id="5-6-1-按逻辑分段"><a href="#5-6-1-按逻辑分段" class="headerlink" title="5.6.1 按逻辑分段"></a>5.6.1 按逻辑分段</h3><blockquote>
<p>在分段机制中，一个进程的地址空间可以包含以下不同的段</p>
<ul>
<li>代码段</li>
<li>数据段</li>
<li>堆栈段</li>
<li>内存共享段</li>
</ul>
</blockquote>
<h3 id="5-6-2-记录内存使用情况的数据结构"><a href="#5-6-2-记录内存使用情况的数据结构" class="headerlink" title="5.6.2 记录内存使用情况的数据结构"></a>5.6.2 记录内存使用情况的数据结构</h3><blockquote>
<ul>
<li><code>MAT</code><ul>
<li><code>VS</code> 动态多分区中的 <code>MAT</code> </li>
<li><strong>相同点</strong>：<ul>
<li><code>MAT</code> 的一个表项，对应内存一个分区</li>
</ul>
</li>
<li><strong>不同点</strong>：<ul>
<li>动态多分区中，一个分区存放一整个进程</li>
<li>分段存储中，一个分区存放进程的一个段</li>
<li>一个进程离散分成多个段装入多个不连续的分区</li>
</ul>
</li>
</ul>
</li>
<li>空闲分区表/链</li>
<li>段表 <code>ST</code>：为每个进程设置一张段表，用来记录各个段地址的映射关系</li>
</ul>
</blockquote>
<h3 id="5-6-3-地址重定位"><a href="#5-6-3-地址重定位" class="headerlink" title="5.6.3 地址重定位"></a>5.6.3 地址重定位</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200407114446389.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407114446389" class="fancybox"><img alt="image-20200407114446389" title="image-20200407114446389" data-src="http://narpro.top/img/image-20200407114446389.png" class="lazyload"></a></p>
<ul>
<li>提取逻辑地址中的段号</li>
<li>比较段号与段表控制寄存器中的段长度，如果超出段表长度，则返回 <strong>内存定位错误</strong>，终止进程，否则继续向下执行</li>
<li>从段表控制寄存器中给出的段表首地址开始，以段号为索引查找该进程对应的段表，得到欲访问段的首地址</li>
<li>用欲访问段的首地址，加上逻辑地址中的偏移量得到物理地址</li>
</ul>
</blockquote>
<h3 id="5-6-4-分段保护"><a href="#5-6-4-分段保护" class="headerlink" title="5.6.4 分段保护"></a>5.6.4 分段保护</h3><blockquote>
<ul>
<li>第一级保护是防止进程发生超出存储空间的访问</li>
<li>第二级保护是组织进程超出访问权限的读写</li>
</ul>
<p><strong>步骤</strong>：</p>
<p><a href="http://narpro.top/img/image-20200407120455103.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407120455103" class="fancybox"><img alt="image-20200407120455103" title="image-20200407120455103" data-src="http://narpro.top/img/image-20200407120455103.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-6-7-分段共享"><a href="#5-6-7-分段共享" class="headerlink" title="5.6.7 分段共享"></a>5.6.7 分段共享</h3><blockquote>
<p>如果多个用户进程需要共享内存中的某些代码段或数据段时，可将内存中共享段的起始地址及长度，填入这些进程的段表当中，就可以共享一个逻辑上完整的段信息</p>
<p><a href="http://narpro.top/img/image-20200407120825200.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407120825200" class="fancybox"><img alt="image-20200407120825200" title="image-20200407120825200" data-src="http://narpro.top/img/image-20200407120825200.png" class="lazyload"></a></p>
<p><strong>共享段表 <code>SST</code></strong>：</p>
<p>为了实现段的共享，系统设一个 <strong>共享段表</strong>，记载各个共享段的使用情况，任何一个进程调用共享段时，系统都将访问该表</p>
<p><a href="http://narpro.top/img/image-20200407121124039.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407121124039" class="fancybox"><img alt="image-20200407121124039" title="image-20200407121124039" data-src="http://narpro.top/img/image-20200407121124039.png" class="lazyload"></a></p>
</blockquote>
<h2 id="5-7-基本段也是存储管理"><a href="#5-7-基本段也是存储管理" class="headerlink" title="5.7 基本段也是存储管理"></a>5.7 基本段也是存储管理</h2><h3 id="5-7-1-分段-VS-分页"><a href="#5-7-1-分段-VS-分页" class="headerlink" title="5.7.1 分段 VS 分页"></a>5.7.1 分段 <code>VS</code> 分页</h3><blockquote>
<ul>
<li>分页存储利于大津城装入，内存利用率高</li>
<li>但是页是物理页，页面共享不易实现</li>
<li>段是逻辑段，方便实现分段共享</li>
<li>但是外碎片的存在降低内存使用效率，且整理消除外碎片加大系统开销</li>
</ul>
</blockquote>
<h3 id="5-7-2-基本原理"><a href="#5-7-2-基本原理" class="headerlink" title="5.7.2 基本原理"></a>5.7.2 <strong>基本原理</strong></h3><blockquote>
<p>把分页和分段两者结合起来</p>
<ul>
<li>内存划分成大小相等的页框</li>
<li>用户的地址空间被程序员划分成许多段，每个段一次划分成许多固定大小的页，页的长度等于内存中页框的大小</li>
</ul>
</blockquote>
<h3 id="5-7-3-数据结构"><a href="#5-7-3-数据结构" class="headerlink" title="5.7.3 数据结构"></a>5.7.3 数据结构</h3><blockquote>
<ul>
<li>系统设一张位示图，记录内存各帧占用与否</li>
<li>内存为一个含有多分段的进程建立段表，记录各个分段对应段内页表的地址和长度</li>
<li>一个分段有一个段内页表，记录该段划分为多少也，每页分配的帧号是多少</li>
</ul>
<p><strong>段表和段内页表</strong>：</p>
<p><a href="http://narpro.top/img/image-20200407125102444.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407125102444" class="fancybox"><img alt="image-20200407125102444" title="image-20200407125102444" data-src="http://narpro.top/img/image-20200407125102444.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-7-4-地址形式"><a href="#5-7-4-地址形式" class="headerlink" title="5.7.4 地址形式"></a>5.7.4 地址形式</h3><blockquote>
<p>系统的硬件支持是在处理及内部设有段表控制寄存器及地址生成逻辑</p>
<ul>
<li>程序中的逻辑地址仍是二维地址 <code><段号，偏移量></code></li>
<li>每段装入时分页，地址部分被当作三维地址来处理 <code><段号，页号，页内偏移></code></li>
</ul>
</blockquote>
<h3 id="5-7-5-地址重定位"><a href="#5-7-5-地址重定位" class="headerlink" title="5.7.5 地址重定位"></a>5.7.5 地址重定位</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200407125614142.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407125614142" class="fancybox"><img alt="image-20200407125614142" title="image-20200407125614142" data-src="http://narpro.top/img/image-20200407125614142.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-7-6-地址保护"><a href="#5-7-6-地址保护" class="headerlink" title="5.7.6 地址保护"></a>5.7.6 地址保护</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200407125846580.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407125846580" class="fancybox"><img alt="image-20200407125846580" title="image-20200407125846580" data-src="http://narpro.top/img/image-20200407125846580.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-7-7-段页式地址字结构的计算"><a href="#5-7-7-段页式地址字结构的计算" class="headerlink" title="5.7.7 段页式地址字结构的计算"></a>5.7.7 段页式地址字结构的计算</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200407130039882.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407130012326" class="fancybox"><img alt="image-20200407130012326" title="image-20200407130012326" data-src="http://narpro.top/img/image-20200407130039882.png" class="lazyload"></a></p>
</blockquote>
<h2 id="5-8-多级页表相关计算"><a href="#5-8-多级页表相关计算" class="headerlink" title="5.8 多级页表相关计算"></a>5.8 多级页表相关计算</h2><h3 id="5-8-1-例题"><a href="#5-8-1-例题" class="headerlink" title="5.8.1 例题"></a>5.8.1 例题</h3><blockquote>
<p><strong>题一</strong>：</p>
<p><a href="http://narpro.top/img/image-20200407131916099.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407131916099" class="fancybox"><img alt="image-20200407131916099" title="image-20200407131916099" data-src="http://narpro.top/img/image-20200407131916099.png" class="lazyload"></a></p>
<p><strong>题二</strong>：</p>
<p><a href="http://narpro.top/img/image-20200407132044956.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407132044956" class="fancybox"><img alt="image-20200407132044956" title="image-20200407132044956" data-src="http://narpro.top/img/image-20200407132044956.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200407132208963.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407132208963" class="fancybox"><img alt="image-20200407132208963" title="image-20200407132208963" data-src="http://narpro.top/img/image-20200407132208963.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-8-2-多级页表的地址重定位"><a href="#5-8-2-多级页表的地址重定位" class="headerlink" title="5.8.2 多级页表的地址重定位"></a>5.8.2 多级页表的地址重定位</h3><blockquote>
<p>处理及中要设有外部页表寄存器，存放当前进程的外部页表首地址。系统根据指令给出逻辑地址</p>
<ul>
<li>用逻辑地址中的外层页号查找外层页表，得到内层页表首地址</li>
<li>用逻辑地址中的内层页号查找内层页表，得到数据帧号</li>
<li>将数据帧的首地址加上偏移地址得到物理地址</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407132940278.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407132940278" class="fancybox"><img alt="image-20200407132940278" title="image-20200407132940278" data-src="http://narpro.top/img/image-20200407132940278.png" class="lazyload"></a></p>
</blockquote>
<h2 id="5-9-快表"><a href="#5-9-快表" class="headerlink" title="5.9 快表"></a>5.9 快表</h2><blockquote>
<ul>
<li>存储在高速缓存</li>
<li>内容为页表中最近使用的页表项</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407133607087.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407133607087" class="fancybox"><img alt="image-20200407133607087" title="image-20200407133607087" data-src="http://narpro.top/img/image-20200407133607087.png" class="lazyload"></a></p>
</blockquote>
<h3 id="5-9-1-地址变换过程"><a href="#5-9-1-地址变换过程" class="headerlink" title="5.9.1 地址变换过程"></a>5.9.1 地址变换过程</h3><blockquote>
<ul>
<li>硬件逻辑中，将逻辑地址中的页号送入高速缓存，与快表中的所有页号进行比较，若找到相匹配的页号，读出该页面对应的帧号，与偏移量合成一个物理地址</li>
<li>若在快表中没有找到，系统需要再在访问内存中的页表，在页表中找到该页的帧号，与偏移量共同合成访问内存的物理地址</li>
<li>同时系统自动更新快表。快表中总是存放那些刚刚访问过的页表项</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407134104359.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407134104359" class="fancybox"><img alt="image-20200407134104359" title="image-20200407134104359" data-src="http://narpro.top/img/image-20200407134104359.png" class="lazyload"></a></p>
<p>设一次快存访问时间为 t1，一次内存访问时间为 t2</p>
<ul>
<li>如果查询快表能找到所用页，我们称作命中，此时的有效访存时间 t 为<ul>
<li><code>t = t1 + t2</code></li>
</ul>
</li>
<li>如果查询快表没有找到所用页，称作没有命中，此时有效访存时间 t 将是<ul>
<li><code>t = t1 + 2t2</code></li>
</ul>
</li>
</ul>
<p>设查询快表的命中率为 p，则平均内存有效访问时间 T 大约是</p>
<ul>
<li><code>T = p * (t1 + t2) + (1 - p) * (t1 + 2t2)</code></li>
</ul>
<p><a href="http://narpro.top/img/image-20200407135113454.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407135113454" class="fancybox"><img alt="image-20200407135113454" title="image-20200407135113454" data-src="http://narpro.top/img/image-20200407135113454.png" class="lazyload"></a></p>
</blockquote>
<h1 id="六、虚拟存储管理篇"><a href="#六、虚拟存储管理篇" class="headerlink" title="六、虚拟存储管理篇"></a>六、虚拟存储管理篇</h1><h2 id="6-1-主存扩充技术"><a href="#6-1-主存扩充技术" class="headerlink" title="6.1 主存扩充技术"></a>6.1 主存扩充技术</h2><blockquote>
<ul>
<li>覆盖技术</li>
<li>交换技术<ul>
<li>交换整个作业</li>
<li>交换整个进程</li>
<li>交换页面/段面</li>
</ul>
</li>
<li>虚拟存储技术<ul>
<li>交换页面/段面</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-1-1-实质"><a href="#6-1-1-实质" class="headerlink" title="6.1.1 实质"></a>6.1.1 实质</h3><blockquote>
<p><strong>目的</strong>：将小的实存储器扩充为大的虚存储器</p>
<p><strong>实质</strong>：将磁盘空间虚拟成内存使用</p>
<p><strong>结果</strong>：将进程的一部分装入内存即可运行</p>
</blockquote>
<h3 id="6-1-2-局部性原理"><a href="#6-1-2-局部性原理" class="headerlink" title="6.1.2 局部性原理"></a>6.1.2 局部性原理</h3><blockquote>
<ul>
<li>最近访问过的程序代码和数据结构很快又被访问（时间局部性）</li>
<li>某存储单元被使用之后，其相邻的存储单元也很快被使用（空间局部性）</li>
</ul>
<p>程序在执行过程中的一个较短时间内，所执行的指令地址或操作数地址分别局限于一定的存储区域中</p>
<p>实际上，在许多情况下不需要将整个程序放到内存，如：</p>
<ul>
<li>处理异常错误条件的代码</li>
<li>主程序先后调用的多个子进程</li>
</ul>
<p>所以可知，虚拟内存也是可行的</p>
<p><strong>虚拟内存</strong>：</p>
<p>允许进程的执行不必完全在内存中，程序可比物理内存大</p>
<ul>
<li>程序不再受现有的物理内存空间限制</li>
<li>更多程序可同时执行，<code>CPU</code> 利用率相应增加</li>
</ul>
</blockquote>
<h3 id="6-1-3-覆盖技术"><a href="#6-1-3-覆盖技术" class="headerlink" title="6.1.3 覆盖技术"></a>6.1.3 覆盖技术</h3><blockquote>
<p>程序在运行过程中，在不同时刻把同一存储区分配给不同程序段或数据段，实现存储区共享的一种内存分配技术</p>
<p>覆盖技术通常与单一连续区分配、固定多分区分配和动态多分区分配等存储管理技术配合使用</p>
<p>每一个用户程序被分成若干段：</p>
<ul>
<li><strong>非覆盖段</strong>：是经常要用的基本部分，作为常驻段</li>
<li><strong>可覆盖段</strong>：不经常使用，可以让他们在需要时临时装入，不同时使用的段可组为一组可覆盖段</li>
</ul>
</blockquote>
<h3 id="6-1-4-交换技术"><a href="#6-1-4-交换技术" class="headerlink" title="6.1.4 交换技术"></a>6.1.4 交换技术</h3><blockquote>
<p>将内存中某进程暂时不用的程序和数据写入外存交换区中，腾出来的内存空间供其他进程使用。待需要时或内存有空闲空间时，再将它从外存交换区装入内存</p>
<p>磁盘交换区时一个数据的暂存处。系统可根据内存的拥挤程度将信息调往交换区或者从交换区调入</p>
<p>于是磁盘就被分成文件区和交换区</p>
<ul>
<li>二者存储方式不同：文件区信息以文件形式存放，为了提高空间利用率，一般采取离散存储方式，交换区信息按字节流动方式存放，多采用连续存储方式</li>
<li>二者访问速度不同：为了提高检索效率一般通过建立目录，对文件实现访问，也就是间接地址访问，而交换区空间较小，可按外存地址直接访问，因此访问速度快</li>
<li>二者存储时间不同：文件区适合于长久的数据存储，而交换区作为临时数据的存放处，只存放短期的数据</li>
</ul>
<p><strong>交换方式</strong>：</p>
<ul>
<li>交换整个作业——用于单道系统（单道模拟多道）</li>
<li>交换整个进程——用于连续分区存储管理（进程挂起、激活，中级调度）</li>
<li>交换页面/段面——用于分页、分段存储管理技术（虚拟存储技术）</li>
</ul>
</blockquote>
<h3 id="6-1-5-虚拟存储技术"><a href="#6-1-5-虚拟存储技术" class="headerlink" title="6.1.5 虚拟存储技术"></a>6.1.5 虚拟存储技术</h3><blockquote>
<p>一个进程运行时，可不必将其全部装载到内存区中，只需把当前运行的部分程序和可能访问的数据块装入内存即可，随着进程运行的不断推进，其余部分程序和数据可随时装入，这样做可实现小内存运行大程序的设想</p>
<p>采用虚拟存储技术以后，从逻辑上说，系统拥有一个容量很大的存储器，这就是常说的虚拟存储器</p>
<p><strong>虚拟存储器的特性</strong>：</p>
<ul>
<li>离散性</li>
<li>多次性</li>
<li>对换性</li>
<li>虚拟性</li>
</ul>
<p><strong>实现技术</strong>：</p>
<ul>
<li>基于分页的虚拟存储：页面换入换出</li>
<li>基于分段的虚拟存储：段面换入换出</li>
<li>基于段页的虚拟存储：页面换入换出</li>
</ul>
</blockquote>
<h2 id="6-2-请求分页存储管理基本原理"><a href="#6-2-请求分页存储管理基本原理" class="headerlink" title="6.2 请求分页存储管理基本原理"></a>6.2 请求分页存储管理基本原理</h2><h3 id="6-2-1-要点"><a href="#6-2-1-要点" class="headerlink" title="6.2.1 要点"></a>6.2.1 要点</h3><blockquote>
<ul>
<li>内存分成大小相等的帧</li>
<li>进程按照帧的大小被分成若干页</li>
<li>进程仅装入部分页面即开始执行</li>
<li>在执行过程中访问的页若已存在，进行动态的地址重定位，执行指令</li>
<li>在执行过程中访问的页未装入内存时，产生缺页中断，进程阻塞，等待从磁盘动态装入页面</li>
<li>缺页装入以后，进程转入就绪，可参与调度继续执行</li>
<li>内存无空闲可用帧时，暂时不用的页面可换出到交换区</li>
<li>通过页面的换入换出实现小内存运行大进程</li>
</ul>
</blockquote>
<h3 id="6-2-2-页的位置"><a href="#6-2-2-页的位置" class="headerlink" title="6.2.2 页的位置"></a>6.2.2 页的位置</h3><blockquote>
<ul>
<li>内存</li>
<li>外存</li>
<li>交换区</li>
</ul>
</blockquote>
<h3 id="6-2-3-数据结构"><a href="#6-2-3-数据结构" class="headerlink" title="6.2.3 数据结构"></a>6.2.3 数据结构</h3><blockquote>
<p>页表：</p>
<ul>
<li>为一个进程设置一张页表，记录该进程分了多少页、每一页是否已装入内存、内/外存地址、访问权限等相关管理信息</li>
<li>与基本分页存储管理的页表相比，扩充页表的内容，增加驻留标志位和页面辅存的地址等信息</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407171806570.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407171806570" class="fancybox"><img alt="image-20200407171806570" title="image-20200407171806570" data-src="http://narpro.top/img/image-20200407171806570.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-2-4-地址重定位"><a href="#6-2-4-地址重定位" class="headerlink" title="6.2.4 地址重定位"></a>6.2.4 地址重定位</h3><blockquote>
<p>当一个进程调度时，系统将其页表首地址装入 <code>CPU</code> 中的页表控制寄存器。运行中用相对地址的高端部分作为页号区检索页表，看该页是否已在内存，如果存在则就绪，否则发生缺页中断，进程转入阻塞等待系统将所缺的页装入之后重新执行</p>
<p><a href="http://narpro.top/img/image-20200407172223508.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407172223508" class="fancybox"><img alt="image-20200407172223508" title="image-20200407172223508" data-src="http://narpro.top/img/image-20200407172223508.png" class="lazyload"></a></p>
</blockquote>
<h2 id="6-3-缺页中断与缺页中断处理过程"><a href="#6-3-缺页中断与缺页中断处理过程" class="headerlink" title="6.3 缺页中断与缺页中断处理过程"></a>6.3 缺页中断与缺页中断处理过程</h2><blockquote>
<p>缺页中断是指令执行过程中产生的中断，而非在一条指令执行完成后产生的</p>
</blockquote>
<h3 id="6-3-1-缺页中断的断点压入"><a href="#6-3-1-缺页中断的断点压入" class="headerlink" title="6.3.1 缺页中断的断点压入"></a>6.3.1 缺页中断的断点压入</h3><blockquote>
<ul>
<li>当 <code>CPU</code> 执行指令希望访问一个不在内存的页面时，将产生缺页中断，系统开始运行中断处理程序</li>
<li>此时指令计数器的值尚未来得及增加就被压入堆栈，因此压入的断电必然是本次被中断的地址，而非下一条指令的地址</li>
</ul>
</blockquote>
<h3 id="6-3-2-缺页中断处理过程"><a href="#6-3-2-缺页中断处理过程" class="headerlink" title="6.3.2 缺页中断处理过程"></a>6.3.2 缺页中断处理过程</h3><blockquote>
<ul>
<li>保留上下文</li>
<li>判断内存是否有空闲可用帧，有则获取一个帧号 <code>No</code>，转第四点，启动 <code>I/O</code> 过程，若无继续第三点</li>
<li>腾出一个空闲帧<ul>
<li>调用置换算法，选择一个淘汰页 <code>PTj</code></li>
<li><code>PTj = 0</code> // 驻留位置0</li>
<li><code>No = PTj(F)</code> // 取该页帧号</li>
<li>若该页曾被修改过<ul>
<li>请求外存交换区上的一个空闲区 B</li>
<li><code>PTj(D) = B</code> // 记录外存地址</li>
<li>启动 <code>I/O</code> 管理程序，将该页写到外存上</li>
</ul>
</li>
<li>按页表中提供的缺页外存位置启动 <code>I/O</code>，将缺页装入空闲帧 <code>No</code></li>
<li>修改页表中该页的驻留位和内存地址 <code>PTi(S) = 1; PT(i) = No</code></li>
<li>结束</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="6-4-页面分配算法与分配策略"><a href="#6-4-页面分配算法与分配策略" class="headerlink" title="6.4 页面分配算法与分配策略"></a>6.4 页面分配算法与分配策略</h2><blockquote>
<ul>
<li>实践证明，如果一个进程在内存中分配的帧数比较少，尽管有局部性原理，缺页率仍然相对较高</li>
<li>给特定进程分配的内存空间超过一定的大小后，由于局部性原理，该进程的缺页率没有明显的变化</li>
<li>分配给一个进程的帧数越多，在任何时候驻留在内存中的进程数就越少，从而降低了操作系统至少找到一个就绪进程的可能性，降低了 <code>CPU</code> 的利用率</li>
</ul>
</blockquote>
<h3 id="6-4-1-给特定进程分配合理的内存帧数"><a href="#6-4-1-给特定进程分配合理的内存帧数" class="headerlink" title="6.4.1 给特定进程分配合理的内存帧数"></a>6.4.1 给特定进程分配合理的内存帧数</h3><blockquote>
<p>目前流行的支持多字节指令的计算机系统中，一条指令需要对源操作数和目的操作数进行处理，那么一个进程的运行空间最好不小于 <code>6</code> 个页面</p>
<p>请求分页系统中的页面分配应当以减少缺页率位目标</p>
<p><strong>需要考虑的因素</strong>：</p>
<ul>
<li>指令格式</li>
<li>寻址方向</li>
<li>程序长度</li>
<li>页面走向</li>
<li>程序的工作集尺寸</li>
<li>多道并发度</li>
</ul>
</blockquote>
<h3 id="6-4-2-平均分配法"><a href="#6-4-2-平均分配法" class="headerlink" title="6.4.2 平均分配法"></a>6.4.2 平均分配法</h3><blockquote>
<p>系统的可用空间平均分配给所有进程，让他们都占有相等数量的帧</p>
<ul>
<li>这样分配对短作业来说时很有利的</li>
<li>对较大进程，缺页率必然居高不下</li>
</ul>
</blockquote>
<h3 id="6-4-3-优先权分配法"><a href="#6-4-3-优先权分配法" class="headerlink" title="6.4.3 优先权分配法"></a>6.4.3 优先权分配法</h3><blockquote>
<p>考虑进程的优先运行权，给高优先的进程分配较多的帧，使它的缺页率相对少一些</p>
<p>这里我们可把优先权理解为高响应比、高优先级、最短剩余时间优先等</p>
</blockquote>
<h3 id="6-4-4-比例分配法"><a href="#6-4-4-比例分配法" class="headerlink" title="6.4.4 比例分配法"></a>6.4.4 比例分配法</h3><blockquote>
<p>这种分配方法比较公平，小进程分配小空间，大进程分配大空间</p>
<ul>
<li>当可用空间为 M 帧，系统当前的进程数为 n，每个进程的页面数为 si，那么按比例分配发，应当分配给进程 i 的页数 pi 为：</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407221059368.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407221059368" class="fancybox"><img alt="image-20200407221059368" title="image-20200407221059368" data-src="http://narpro.top/img/image-20200407221059368.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-4-5-页面分配策略"><a href="#6-4-5-页面分配策略" class="headerlink" title="6.4.5 页面分配策略"></a>6.4.5 页面分配策略</h3><blockquote>
<ul>
<li>固定分配策略：为一个进程在内存中分配固定数目的页框用于执行时使用</li>
<li>可变分配策略：允许分配给一个进程的帧的数目在该进程的生命周期中不断地法神变化，缺页率高可增加分配地帧，缺页率很低时可适当减少分配的帧</li>
</ul>
</blockquote>
<h2 id="6-5-页面置换算法概述"><a href="#6-5-页面置换算法概述" class="headerlink" title="6.5 页面置换算法概述"></a>6.5 页面置换算法概述</h2><h3 id="6-5-1-页面置换"><a href="#6-5-1-页面置换" class="headerlink" title="6.5.1 页面置换"></a>6.5.1 页面置换</h3><blockquote>
<p>是指在内存空间没有空闲可用真而又要装入新页时，必须按某种算法将内存中的某页置换为一个新页</p>
<ul>
<li>换出的：从内存到外存（磁盘交换区或文件区）</li>
<li>换入的：从外存（磁盘交换区或文件区）换到内存</li>
</ul>
</blockquote>
<h3 id="6-5-2-页面置换策略"><a href="#6-5-2-页面置换策略" class="headerlink" title="6.5.2 页面置换策略"></a>6.5.2 页面置换策略</h3><blockquote>
<ul>
<li>局部置换策略：尽在产生这次缺页的进程的驻留页中选择并置换</li>
<li>全局置换策略：把内存中所有未被锁定的页都作为置换的候选页，不管他们属于哪一个进程</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th>局部置换</th>
<th>全局置换</th>
</tr>
</thead>
<tbody><tr>
<td align="center">固定分配</td>
<td>- 分配给一个进程的页框数是固定的<br>- 从分配给该进程的页框中选择被置换的页</td>
<td>无此方案</td>
</tr>
<tr>
<td align="center">可变分配</td>
<td>- 分配给一个进程的页框数可以变化<br>- 从分配给该进程页框中选择被置换的页</td>
<td>- 从内存中所有页框中学则被置换的页<br>- 这导致进程驻留集大小不断变化</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="6-5-3-页面置换要点"><a href="#6-5-3-页面置换要点" class="headerlink" title="6.5.3 页面置换要点"></a>6.5.3 页面置换要点</h3><blockquote>
<ul>
<li>策略前提：固定分配 + 局部置换</li>
<li>发生背景：发生缺页中断 + 内存无空闲可用帧</li>
<li>完成功能：从进程自己的驻留页中选择一页作为淘汰对象换出，然后换入所缺页</li>
<li>选择策略：页面置换算法</li>
</ul>
</blockquote>
<h3 id="6-5-4-常见的页面置换算法"><a href="#6-5-4-常见的页面置换算法" class="headerlink" title="6.5.4 常见的页面置换算法"></a>6.5.4 常见的页面置换算法</h3><blockquote>
<ul>
<li><code>OPT</code></li>
<li><code>FIFO</code></li>
<li><code>LRU</code></li>
<li><code>CLOCK</code></li>
<li>改进的 <code>CLOCK</code></li>
</ul>
</blockquote>
<h3 id="6-5-5-OPT-最佳置换算法"><a href="#6-5-5-OPT-最佳置换算法" class="headerlink" title="6.5.5 OPT 最佳置换算法"></a>6.5.5 <code>OPT</code> 最佳置换算法</h3><blockquote>
<p>该算法选择以后不再使用、或者要隔最长时间才能使用的页面予以淘汰</p>
<p><code>OPT</code> 算法尽量避免刚调出去又要立即调入，是一种理想化了的页面置换算法</p>
<p><a href="http://narpro.top/img/image-20200407231309478.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407231309478" class="fancybox"><img alt="image-20200407231309478" title="image-20200407231309478" data-src="http://narpro.top/img/image-20200407231309478.png" class="lazyload"></a>)<a href="http://narpro.top/img/image-20200407231624182.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407231624182" class="fancybox"><img alt="image-20200407231624182" title="image-20200407231624182" data-src="http://narpro.top/img/image-20200407231624182.png" class="lazyload"></a></p>
<ul>
<li><code>OPT</code> 算法在实际系统中不易实现</li>
<li><code>OPT</code> 算法用于衡量实际页面置换算法的性能</li>
</ul>
</blockquote>
<h3 id="6-5-6-FIFO-先进先出页面置换算法"><a href="#6-5-6-FIFO-先进先出页面置换算法" class="headerlink" title="6.5.6 FIFO 先进先出页面置换算法"></a>6.5.6 <code>FIFO</code> 先进先出页面置换算法</h3><blockquote>
<ul>
<li>系统选择驻留在内存中时间最长的页面作为被淘汰的对象</li>
<li>这种算法的出发点是局部性原理，但没有考虑现状如内存者有可能是主程序常驻模块</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407232002258.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407232002258" class="fancybox"><img alt="image-20200407232002258" title="image-20200407232002258" data-src="http://narpro.top/img/image-20200407232002258.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200407232255677.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407232255677" class="fancybox"><img alt="image-20200407232255677" title="image-20200407232255677" data-src="http://narpro.top/img/image-20200407232255677.png" class="lazyload"></a></p>
<ul>
<li>最先装入的不一定是以后不用的</li>
<li><code>FIFO</code> 算法容易理解和实现，性能并不总是很好</li>
</ul>
</blockquote>
<h3 id="6-5-7-LRU-最近最久未用算法"><a href="#6-5-7-LRU-最近最久未用算法" class="headerlink" title="6.5.7 LRU 最近最久未用算法"></a>6.5.7 <code>LRU</code> 最近最久未用算法</h3><blockquote>
<ul>
<li>系统选择内存中上次使用距当前最远的页予以淘汰</li>
<li>根据程序局部性原理，在较长时间里未被使用的页面，可能不会马上使用到</li>
<li>实现时通常使用栈来组织各个驻留页，通过调整、维护栈来记录各驻留页被访问的先后顺序</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407233117093.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407233117093" class="fancybox"><img alt="image-20200407233117093" title="image-20200407233117093" data-src="http://narpro.top/img/image-20200407233117093.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200407233437999.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407233437999" class="fancybox"><img alt="image-20200407233437999" title="image-20200407233437999" data-src="http://narpro.top/img/image-20200407233437999.png" class="lazyload"></a></p>
<ul>
<li>优点：缺页中断率接近 <code>OPT</code></li>
<li>缺点：几乎每一次页面访问都要调整栈，系统开销大</li>
</ul>
</blockquote>
<h3 id="6-5-8-Clock-算法"><a href="#6-5-8-Clock-算法" class="headerlink" title="6.5.8 Clock 算法"></a>6.5.8 <code>Clock</code> 算法</h3><blockquote>
<ul>
<li>这是一个建立在循环检查基础上的 <code>LRU</code> 近似算法，试图以较小的开销获得接近 <code>LRU</code> 的性能</li>
<li>该算法中将驻留页组织成一个循环对，并设一个循环移动指针</li>
</ul>
<p><strong>步骤</strong>：</p>
<ul>
<li>初始时，该指针指向循环队的头部</li>
<li>指针顺序搜索各页面，若页面访问位为 1，则将之改为 0</li>
<li>找到的第一个访问位为 0 的页面，淘汰，新换入的页面访问位置为 1</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407234031952.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407234031952" class="fancybox"><img alt="image-20200407234031952" title="image-20200407234031952" data-src="http://narpro.top/img/image-20200407234031952.png" class="lazyload"></a></p>
<p><strong>分析</strong>：</p>
<ul>
<li><code>Clock</code> 是近似的 <code>LRU</code>，理论上的缺页中断率肯定高于 <code>LRU</code>，但实际系统应用起来系统开销少，效果要由于 <code>LRU</code></li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>驻留页有被修改过的，也有未被修改过的，这两种页面被换出时的操作开销大为不同</li>
</ul>
</blockquote>
<h3 id="6-5-9-改进的-Clock-算法"><a href="#6-5-9-改进的-Clock-算法" class="headerlink" title="6.5.9 改进的 Clock 算法"></a>6.5.9 改进的 <code>Clock</code> 算法</h3><blockquote>
<p>除了访问位 <code>A</code> 之外为每个帧增设一个关联的修改位，记作 <code>M</code></p>
<ul>
<li>如果 <code>M = 1</code> 表示该帧中的页面被修改了，淘汰他意味着必须将之写到外存</li>
<li>如果 <code>M = 0</code> 表示该帧中的页面没有被修改，淘汰他意味着什么都不用做</li>
</ul>
<p><strong>过程</strong>：</p>
<ul>
<li>从指针当前位置开始，循环扫描候选帧，遇到的第一个 <code>A = 0</code> 且 <code>M = 0</code> 的帧，将该帧中的页面置换后返回</li>
<li>若循环一周没有找到可置换的帧，则继续循环扫描第二周，遇到的第一个 <code>A = 0</code> 且 <code>M = 1</code> 的帧，将该帧中的页面置换后返回。在这个过程中，没跳过一个镇就将他的访问位 <code>A</code> 设置为 0</li>
<li>若第二圈仍没有找到可置换的帧，则循环扫描第三圈，操作同第一圈</li>
<li>若第三圈没有找到可置换的帧，则循环扫描第四圈，操作同第二圈，必将找到一个可置换的帧</li>
</ul>
<p><a href="http://narpro.top/img/image-20200407235311204.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200407235311204" class="fancybox"><img alt="image-20200407235311204" title="image-20200407235311204" data-src="http://narpro.top/img/image-20200407235311204.png" class="lazyload"></a></p>
</blockquote>
<h2 id="6-6-关于页面调入的进一步讨论"><a href="#6-6-关于页面调入的进一步讨论" class="headerlink" title="6.6 关于页面调入的进一步讨论"></a>6.6 关于页面调入的进一步讨论</h2><h3 id="6-6-1-页面什么时候调入？"><a href="#6-6-1-页面什么时候调入？" class="headerlink" title="6.6.1 页面什么时候调入？"></a>6.6.1 页面什么时候调入？</h3><blockquote>
<p>在页面动态装入过程中有两个页面调入策略</p>
<ul>
<li>随用随调：法僧缺页中断时，缺哪页便调入哪页</li>
<li>预调页：使用第一页，发生缺页中断，在调入第一页时连同第二、三。。。页一起调入<ul>
<li><strong>优点</strong>：<ul>
<li>一次读多个连续的页面，可以减少磁头移动的时间，对系统效率提高有很大的好处</li>
<li>当发现缺页已在内存时，当前进程不必让出控制权，仅仅将缺页转移到用户区，修改页表后就可继续运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-6-2-页面从哪儿调入？"><a href="#6-6-2-页面从哪儿调入？" class="headerlink" title="6.6.2 页面从哪儿调入？"></a>6.6.2 页面从哪儿调入？</h3><blockquote>
<ul>
<li>从磁盘交换区调入</li>
<li>从磁盘文件区调入</li>
<li>从磁盘缓冲区调入</li>
</ul>
</blockquote>
<h3 id="6-6-3-页面调入需要多长时间？"><a href="#6-6-3-页面调入需要多长时间？" class="headerlink" title="6.6.3 页面调入需要多长时间？"></a>6.6.3 页面调入需要多长时间？</h3><blockquote>
<ul>
<li>从磁盘交换区调入<ul>
<li>调入时间主要是读磁盘扇区的时间，由磁盘寻道时间，盘片旋转延迟时间和数据传送时间三部分组成</li>
<li>通常调入时间约为数百微秒至数十毫秒</li>
</ul>
</li>
<li>从磁盘文件区调入<ul>
<li>对文件区的访问需要检索文件目录，找到文件以外的外存地址后再都磁盘扇区</li>
<li>其调入时间将数倍于从磁盘交换区中调入缺页的耗时，几十甚至几百毫秒</li>
</ul>
</li>
<li>从磁盘缓冲区调入<ul>
<li>系统允许采用提前读的访问策略时，用户程序运行中产生的缺页有可能已经驻留在内存的磁盘缓冲区内</li>
<li>从该缓冲区内调入缺页的时间大体为数百纳秒</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-7-页面访问时间"><a href="#6-7-页面访问时间" class="headerlink" title="6.7 页面访问时间"></a>6.7 页面访问时间</h3><h3 id="6-7-1-进程执行过程中要访问的页面有几种情况？"><a href="#6-7-1-进程执行过程中要访问的页面有几种情况？" class="headerlink" title="6.7.1 进程执行过程中要访问的页面有几种情况？"></a>6.7.1 进程执行过程中要访问的页面有几种情况？</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408002741589.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408002741589" class="fancybox"><img alt="image-20200408002741589" title="image-20200408002741589" data-src="http://narpro.top/img/image-20200408002741589.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-7-2-访问页面需要多长时间？"><a href="#6-7-2-访问页面需要多长时间？" class="headerlink" title="6.7.2 访问页面需要多长时间？"></a>6.7.2 访问页面需要多长时间？</h3><blockquote>
<ul>
<li>在基本分页存储管理中，所有页面已在内存里<ul>
<li>进行地址重定位</li>
<li>设 t1 为访问一次快存的时间，t2 为访问一次内存的时间，p 是访问快表命中率，则有效访存时间为<ul>
<li><code>t = (1 - p) * (t1 + 2t2) + p * (t1 + t2)</code></li>
</ul>
</li>
</ul>
</li>
<li>在请求分页存储管理中，页面分两种情况计算<ul>
<li>在请求分页存储管理中，不发生缺页时的这个访存时间 t 称为一个内存周期为 ma<ul>
<li><code>ma = t = (1 - p) * (t1 + 2t2) + p * (t1 + t2)</code></li>
</ul>
</li>
<li>假定系统的一个内存周期为 ma，调入缺页的时间为 la，缺页率为 p，那么<ul>
<li><code>T = (1 - p) * ma + p * (la + ma)</code></li>
<li><code>T = ma - p * ma + p * la + p * ma</code></li>
<li><code>T = ma + pa * la</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408005001312.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408005001312" class="fancybox"><img alt="image-20200408005001312" title="image-20200408005001312" data-src="http://narpro.top/img/image-20200408005001312.png" class="lazyload"></a></p>
</blockquote>
<h2 id="6-8-驻留集，工作集与抖动的预防"><a href="#6-8-驻留集，工作集与抖动的预防" class="headerlink" title="6.8 驻留集，工作集与抖动的预防"></a>6.8 驻留集，工作集与抖动的预防</h2><h3 id="6-8-1-驻留集"><a href="#6-8-1-驻留集" class="headerlink" title="6.8.1 驻留集"></a>6.8.1 驻留集</h3><blockquote>
<ul>
<li>进程已装入内存的页面的集合——与系统采用的页面装入和页面置换算法有关</li>
</ul>
<p><strong>驻留集尺寸</strong>：</p>
<ul>
<li>进程驻留在内存中的页面数量——与系统采用的页面分配策略有关</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408005358339.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408005358339" class="fancybox"><img alt="image-20200408005358339" title="image-20200408005358339" data-src="http://narpro.top/img/image-20200408005358339.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-8-2-工作集"><a href="#6-8-2-工作集" class="headerlink" title="6.8.2 工作集"></a>6.8.2 工作集</h3><blockquote>
<ul>
<li>在某一段时间间隔内进程运行所需访问的页面的集合</li>
<li>一个进程的工作集 <code>W(i, t)</code> 表示在时间 <code>i - t</code> 到 i 之间进程引用的一串页面，工作集的尺寸记作 <code>s(i, t)</code>，指的是 <code>W(i, t)</code> 中的页面数</li>
<li>在进程执行期间可以很容易的确定该进程对存储空间的需求，也就是它的工作集尺寸</li>
<li>操作系统可以用这种方法决定给谁分配更多的帧，以及哪个进程应当让出一些帧</li>
<li>工作集可用于指导驻留集的大小</li>
</ul>
<p><strong>策略</strong>：</p>
<ul>
<li>监视每个进程的工作集</li>
<li>周期性地从一个进程地驻留集中移去那些不在它的工作集中的页</li>
<li>只有当一个进程的工作集在内存中时，才可以执行</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>通过工作集调整驻留集，可降低缺页率</li>
<li>通过工作集尺寸调整驻留集尺寸，可提高内存利用率</li>
<li>优先调度工作集包含于驻留集的进程，提高 <code>CPU</code> 利用率</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>根据过去预测将来的不准确性</li>
<li>为每个进程真实的测量工作集是不实际的</li>
<li>t 的最优值是未知的，并且它在任何 情况下都会变化</li>
</ul>
</blockquote>
<h3 id="6-8-3-抖动"><a href="#6-8-3-抖动" class="headerlink" title="6.8.3 抖动"></a>6.8.3 抖动</h3><blockquote>
<p>又称颠簸，指刚调出去的页需要马上被调回，刚调回不久又要被调出。频繁调入调出，使系统的大部分时间都花费在内存和外存之间的来回折腾上</p>
<p>抖动主要表现为磁盘 <code>I/O</code> 极度繁忙，而处理及大量时间空闲，<code>CPU</code> 有效利用率降低</p>
<p><a href="http://narpro.top/img/image-20200408011644440.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408011644440" class="fancybox"><img alt="image-20200408011644440" title="image-20200408011644440" data-src="http://narpro.top/img/image-20200408011644440.png" class="lazyload"></a></p>
<p><strong>预防措施</strong>：</p>
<ul>
<li>在处理机调度中引入工作集策略</li>
<li>采用局部置换策略防止抖动扩散</li>
<li>挂起部分进程</li>
<li><code>L = S</code> 准则（L 是产生缺页的平均时间，S 是系统处理缺页的平均时间，理论证明，当 <code>L = S</code> 时处理及的利用率最高，在实际系统中很难实现）</li>
</ul>
</blockquote>
<h2 id="6-9-请求分段与请求段页式存储管理"><a href="#6-9-请求分段与请求段页式存储管理" class="headerlink" title="6.9 请求分段与请求段页式存储管理"></a>6.9 请求分段与请求段页式存储管理</h2><h3 id="6-9-1-请求分段存储管理的基本原理"><a href="#6-9-1-请求分段存储管理的基本原理" class="headerlink" title="6.9.1 请求分段存储管理的基本原理"></a>6.9.1 请求分段存储管理的基本原理</h3><blockquote>
<ul>
<li>进程按照逻辑结构分段，每一段装入内存一块连续存储区，各段离散存储</li>
<li>每个进程装入部分段面，即可以开始运行</li>
<li>运行过程中，发生缺段，进程阻塞，通过缺段中断动态调入所缺段，进程转入就绪可参与调度继续之心</li>
</ul>
</blockquote>
<h3 id="6-9-2-请求分段存储管理的数据结构"><a href="#6-9-2-请求分段存储管理的数据结构" class="headerlink" title="6.9.2 请求分段存储管理的数据结构"></a>6.9.2 请求分段存储管理的数据结构</h3><blockquote>
<ul>
<li><code>MAT</code> 表</li>
<li>空闲分区表</li>
<li>段表：为了是实现段的动态管理，为每个进程设置一个段表，并在段表中设置一些 <strong>控制位</strong> 记录该段的控制信息</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408012711225.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408012711225" class="fancybox"><img alt="image-20200408012711225" title="image-20200408012711225" data-src="http://narpro.top/img/image-20200408012711225.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-9-3-请求分段存储管理的地址重定位"><a href="#6-9-3-请求分段存储管理的地址重定位" class="headerlink" title="6.9.3 请求分段存储管理的地址重定位"></a>6.9.3 请求分段存储管理的地址重定位</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408012901742.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408012901742" class="fancybox"><img alt="image-20200408012901742" title="image-20200408012901742" data-src="http://narpro.top/img/image-20200408012901742.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-9-4-缺段中断机制"><a href="#6-9-4-缺段中断机制" class="headerlink" title="6.9.4 缺段中断机制"></a>6.9.4 缺段中断机制</h3><blockquote>
<p>缺段中断也是指令执行过程中产生的中断，进程执行一条产生缺段中断时，压入堆栈的断电是当前指令的地址。当缺段被装入内存后，该段变成了 <strong>实段</strong>，进程再次恢复运行时，<code>CPU</code> 将重新执行这条指令</p>
</blockquote>
<h3 id="6-9-5-缺段中断处理程序"><a href="#6-9-5-缺段中断处理程序" class="headerlink" title="6.9.5 缺段中断处理程序"></a>6.9.5 缺段中断处理程序</h3><blockquote>
<p>当第 i 段时一个缺段，则缺段中断处理过程为：</p>
<ul>
<li>阻塞进程</li>
<li>Length = ST<del>i</del>（长度）</li>
<li>检索内存分配表，若存在 <code>一个独立的内存块长度 > Length</code>，则：<ul>
<li>将该内存块分配给进程</li>
<li>首地址计入 B0，转第六点</li>
</ul>
</li>
<li>若 <code>内存可用空间总和 < Length</code>，则：<ul>
<li>调用某种置换算法，选择一个内存中的段</li>
<li>若该段被修改过，则将它写回外存</li>
<li>修改内存分配表、段表等数据结构</li>
<li>转第三步</li>
</ul>
</li>
<li>内存各进程浮动，拼接出一个足够大的内存空间，将该内存块分配给进程，首地址 B0</li>
<li>从外存读入缺段，存入 B0</li>
<li>ST<del>i</del>(B) = B0，ST<del>i</del>(S) = 1</li>
<li>修改内存分配表</li>
<li>唤醒进程</li>
<li>结束</li>
</ul>
</blockquote>
<h3 id="6-9-6-请求段页式存储管理基本原理"><a href="#6-9-6-请求段页式存储管理基本原理" class="headerlink" title="6.9.6 请求段页式存储管理基本原理"></a>6.9.6 请求段页式存储管理基本原理</h3><blockquote>
<ul>
<li>请求分段加请求分页，把段划分为若干个页面进行离散存储，系统将一个段的当前页调入内存，其余的仍驻留在外存上，随时需要随时通过缺页中断装入</li>
</ul>
<p><strong>硬件支持</strong>：处理机中设有段表控制寄存器参与地址映射，存放的内容时段表起始地址和段表长度。在地址结构方面，页面长度和分段长度由系统对控制寄存器的安排来决定</p>
<p><strong>软件支持</strong>：在请求段页式管理系统中，缺页置换算法是必须的，而且与纯粹请求分页管理机制中采用的算法相同</p>
</blockquote>
<h3 id="6-9-7-请求段页式地址重定位"><a href="#6-9-7-请求段页式地址重定位" class="headerlink" title="6.9.7 请求段页式地址重定位"></a>6.9.7 请求段页式地址重定位</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408014245864.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408014245864" class="fancybox"><img alt="image-20200408014245864" title="image-20200408014245864" data-src="http://narpro.top/img/image-20200408014245864.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-9-8-请求段页式存储管理的优缺点"><a href="#6-9-8-请求段页式存储管理的优缺点" class="headerlink" title="6.9.8 请求段页式存储管理的优缺点"></a>6.9.8 请求段页式存储管理的优缺点</h3><blockquote>
<p><strong>优点</strong>：具有虚拟存储器的功能，并保持了段页式管理的优点，既体现段的独立性，又纳入了页的离散分配，使系统更加灵活</p>
<p><strong>缺点</strong>：增加了硬件的成本，系统复杂性提高，而且段表和页表的存储与检索问题突出，对处理机的运行速度影响较大</p>
</blockquote>
<h2 id="6-10-与地址有关的计算"><a href="#6-10-与地址有关的计算" class="headerlink" title="6.10 与地址有关的计算"></a>6.10 与地址有关的计算</h2><h3 id="6-10-1-题一"><a href="#6-10-1-题一" class="headerlink" title="6.10.1 题一"></a>6.10.1 题一</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408141337828.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408141337828" class="fancybox"><img alt="image-20200408141337828" title="image-20200408141337828" data-src="http://narpro.top/img/image-20200408141337828.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-10-2-题二"><a href="#6-10-2-题二" class="headerlink" title="6.10.2 题二"></a>6.10.2 题二</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408141440002.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408141440002" class="fancybox"><img alt="image-20200408141440002" title="image-20200408141440002" data-src="http://narpro.top/img/image-20200408141440002.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-10-3-题三"><a href="#6-10-3-题三" class="headerlink" title="6.10.3 题三"></a>6.10.3 题三</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408141647605.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408141647605" class="fancybox"><img alt="image-20200408141647605" title="image-20200408141647605" data-src="http://narpro.top/img/image-20200408141647605.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200408141859539.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408141859539" class="fancybox"><img alt="image-20200408141859539" title="image-20200408141859539" data-src="http://narpro.top/img/image-20200408141859539.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-10-4-题四"><a href="#6-10-4-题四" class="headerlink" title="6.10.4 题四"></a>6.10.4 题四</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408142016711.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408142016711" class="fancybox"><img alt="image-20200408142016711" title="image-20200408142016711" data-src="http://narpro.top/img/image-20200408142016711.png" class="lazyload"></a></p>
<ul>
<li>页内偏移 10 位，页号 3 位，故空一填 13</li>
<li>32块物理地址，需 5 位表示帧号，帧内偏移还是 10 位，故空二填 15</li>
</ul>
</blockquote>
<h3 id="6-10-5-题五"><a href="#6-10-5-题五" class="headerlink" title="6.10.5 题五"></a>6.10.5 题五</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408142324621.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408142324621" class="fancybox"><img alt="image-20200408142324621" title="image-20200408142324621" data-src="http://narpro.top/img/image-20200408142324621.png" class="lazyload"></a></p>
<ul>
<li>一</li>
<li>二</li>
</ul>
</blockquote>
<h3 id="6-10-6-题六"><a href="#6-10-6-题六" class="headerlink" title="6.10.6 题六"></a>6.10.6 题六</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408142444917.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408142444917" class="fancybox"><img alt="image-20200408142444917" title="image-20200408142444917" data-src="http://narpro.top/img/image-20200408142444917.png" class="lazyload"></a></p>
<p>页表：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
</tbody></table>
<ul>
<li>1011<ul>
<li>页号：1011 / 1024 = 0</li>
<li>偏移：1011 % 1024 = 1011</li>
<li>按页号查找帧，并计算出物理地址</li>
<li>2 * 1024 + 1011 = 3059</li>
</ul>
</li>
<li>2148<ul>
<li>页号：2148 / 1024 = 2</li>
<li>偏移：2148 % 1024 = 100</li>
<li>按页号查找帧，计算出物理地址</li>
<li>1 * 1024 + 100 = 1240</li>
</ul>
</li>
<li>5012<ul>
<li>页号：5012 / 1024 = 4</li>
<li>不存在 4 号页</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-10-7-题七"><a href="#6-10-7-题七" class="headerlink" title="6.10.7 题七"></a>6.10.7 题七</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408143317093.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408143317093" class="fancybox"><img alt="image-20200408143317093" title="image-20200408143317093" data-src="http://narpro.top/img/image-20200408143317093.png" class="lazyload"></a></p>
</blockquote>
<h3 id="6-10-8-题八"><a href="#6-10-8-题八" class="headerlink" title="6.10.8 题八"></a>6.10.8 题八</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408144154284.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408144154284" class="fancybox"><img alt="image-20200408144154284" title="image-20200408144154284" data-src="http://narpro.top/img/image-20200408144154284.png" class="lazyload"></a></p>
<ul>
<li>1052<ul>
<li>页号：1052 / 1024 = 1</li>
<li>偏移：1052 % 1024 = 28</li>
<li>按页号找到对应帧，并计算出物理地址</li>
<li>7 * 1024 + 28</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="七、设备管理篇"><a href="#七、设备管理篇" class="headerlink" title="七、设备管理篇"></a>七、设备管理篇</h1><h2 id="7-1-设备管理概述"><a href="#7-1-设备管理概述" class="headerlink" title="7.1 设备管理概述"></a>7.1 设备管理概述</h2><blockquote>
<p>在计算机系统中，用来担负数据输入输出的部件称作外部设备，它们是计算机与外部世界进行信息沟通的桥梁</p>
</blockquote>
<h3 id="7-1-1-分类"><a href="#7-1-1-分类" class="headerlink" title="7.1.1 分类"></a>7.1.1 分类</h3><blockquote>
<ul>
<li><code>I/O</code> 设备<ul>
<li>人可读</li>
<li>机器可读</li>
<li>通信</li>
</ul>
</li>
<li>外存储设备<ul>
<li>数据速率</li>
<li>应用</li>
<li>控制的复杂性</li>
<li>传送单位</li>
<li>数据表示</li>
<li>错误条件</li>
</ul>
</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408145548402.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408145548402" class="fancybox"><img alt="image-20200408145548402" title="image-20200408145548402" data-src="http://narpro.top/img/image-20200408145548402.png" class="lazyload"></a></p>
<p><strong>按数据传输单位分</strong></p>
<p><a href="http://narpro.top/img/image-20200408145702277.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408145702277" class="fancybox"><img alt="image-20200408145702277" title="image-20200408145702277" data-src="http://narpro.top/img/image-20200408145702277.png" class="lazyload"></a></p>
<p><strong>按共享特性分</strong>：</p>
<ul>
<li>独享设备<ul>
<li>输入输出速度比较低，在使用的某个环节中需要人工进行干预</li>
<li>在多进程并发运行的系统中，独享设备一般由一个作业独占，知道改作业使用完为止</li>
<li>常见的独享设备有打印机、绘图仪、终端机，以及早期计算机上使用的卡片输入输出机、穿孔机和广电阅读机等</li>
<li>从工作方式上说，大部分独享设备的输入输出操作都是按字符的方式进行传送的，因此这种设备又称为字符设备</li>
</ul>
</li>
<li>共享设备<ul>
<li>操作速度较快，允许多个作业以共享方式使用</li>
<li>共享设备可以供多个进程共同进行存入和读出，一次传输若干数据，也被称作块设备</li>
<li>磁盘是最常见的共享设备</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-1-2-设备管理目标"><a href="#7-1-2-设备管理目标" class="headerlink" title="7.1.2 设备管理目标"></a>7.1.2 设备管理目标</h3><blockquote>
<ul>
<li>方便用户使用</li>
<li>提高设备利用率</li>
<li>通过管理调度提高 <code>I/O</code> 效率</li>
<li>通过软件方法扩充设备的功能</li>
</ul>
</blockquote>
<h3 id="7-1-3-设备管理功能"><a href="#7-1-3-设备管理功能" class="headerlink" title="7.1.3 设备管理功能"></a>7.1.3 设备管理功能</h3><blockquote>
<ul>
<li>设备分配、回收</li>
<li>设备无关性（设备独立性）</li>
<li>缓冲区的设置和管理</li>
<li>设备的驱动与调度</li>
<li>设备的虚拟扩充</li>
</ul>
</blockquote>
<h3 id="7-1-4-设备管理系统的构成"><a href="#7-1-4-设备管理系统的构成" class="headerlink" title="7.1.4 设备管理系统的构成"></a>7.1.4 设备管理系统的构成</h3><blockquote>
<ul>
<li>逻辑 <code>I/O</code> 层</li>
<li>设备 <code>I/O</code> 层</li>
<li>设备调度与驱动控制器</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408151030377.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408151030377" class="fancybox"><img alt="image-20200408151030377" title="image-20200408151030377" data-src="http://narpro.top/img/image-20200408151030377.png" class="lazyload"></a></p>
<p>分别指：一般 <code>I/O</code> 设备系统、网络系统、文件系统</p>
</blockquote>
<h3 id="7-1-5-逻辑外部设备"><a href="#7-1-5-逻辑外部设备" class="headerlink" title="7.1.5 逻辑外部设备"></a>7.1.5 逻辑外部设备</h3><blockquote>
<p><strong>逻辑 <code>I/O</code> 层</strong></p>
<ul>
<li>负责设备的分配和回收，通过设置和维护数据结构，对设备数据进行登记和管理</li>
<li>负责对用户的访问需求进行合法性检查，若此次访问不合法将拒绝访问</li>
<li>负责随时接受下层的处理结果，整理后反馈给用户，处理结果中包含成功或失败信息</li>
</ul>
<p><strong>物理 <code>I/O</code> 层</strong></p>
<ul>
<li>管理内存中的设备缓冲区，负责缓冲区的分配和回收</li>
<li>实现数据的装入与提取，比如从上层软件送来的一行数据填入缓冲区或者从缓冲区取出一行数据送给用户。同时要实现诸多用户对缓冲区访问的并发控制</li>
<li>根据用户请求产生一个具体的 <code>I/O</code> 任务快 <code>IOB</code>，挂到相关设备的任务队列上，并启动下层软件<ul>
<li><strong>IOB块</strong><ul>
<li>是一种动态数据结构</li>
<li>每个 <code>IOB</code> 用于描述一项输入输出任务</li>
<li>当系统收到一个 <code>I/O</code> 请求时就构造一个 <code>IOB</code>，并按 <code>IOB</code> 的信息进行传输控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408152108560.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408152108560" class="fancybox"><img alt="image-20200408152108560" title="image-20200408152108560" data-src="http://narpro.top/img/image-20200408152108560.png" class="lazyload"></a></p>
<p><strong>设备调度与驱动层</strong></p>
<ul>
<li>设备调度，如磁盘 <code>I/O</code> 调度</li>
<li>构造通道程序</li>
<li>启动 <code>I/O</code> 设备完成输入输出</li>
<li>对于设备 <code>I/O</code> 的情况进行收集并交给上层软件</li>
</ul>
</blockquote>
<h2 id="7-2-设备的分配"><a href="#7-2-设备的分配" class="headerlink" title="7.2 设备的分配"></a>7.2 设备的分配</h2><h3 id="7-2-1-设备分配对象"><a href="#7-2-1-设备分配对象" class="headerlink" title="7.2.1 设备分配对象"></a>7.2.1 设备分配对象</h3><blockquote>
<ul>
<li>共享设备是允许多用户穿插访问的设备，此类设备不能分给某个用户独占</li>
<li>设备分配时用户对独享设备的使用方式，用户分得一台共享设备后可以自由的使用，直到使用完毕将设备释放为止</li>
</ul>
</blockquote>
<h3 id="7-2-2-设备分配"><a href="#7-2-2-设备分配" class="headerlink" title="7.2.2 设备分配"></a>7.2.2 设备分配</h3><blockquote>
<ul>
<li>当用户请求进行 <code>I/O</code> 操作时，不但要分配设备，还要分配有关的数据传输通路，也就是分配通道和控制器</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408152859099.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408152859099" class="fancybox"><img alt="image-20200408152859099" title="image-20200408152859099" data-src="http://narpro.top/img/image-20200408152859099.png" class="lazyload"></a></p>
</blockquote>
<h3 id="7-2-3-系统设备分配表-SDT"><a href="#7-2-3-系统设备分配表-SDT" class="headerlink" title="7.2.3 系统设备分配表 SDT"></a>7.2.3 系统设备分配表 <code>SDT</code></h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408153012312.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408153012312" class="fancybox"><img alt="image-20200408153012312" title="image-20200408153012312" data-src="http://narpro.top/img/image-20200408153012312.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200408153214379.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408153214379" class="fancybox"><img alt="image-20200408153214379" title="image-20200408153214379" data-src="http://narpro.top/img/image-20200408153214379.png" class="lazyload"></a></p>
<ul>
<li>系统设置一张 <code>SDT</code>，登记系统拥有的所有设备类型，一行等级一类设备的管理信息</li>
</ul>
</blockquote>
<h3 id="7-2-4-设备控制表-DCT"><a href="#7-2-4-设备控制表-DCT" class="headerlink" title="7.2.4 设备控制表 DCT"></a>7.2.4 设备控制表 <code>DCT</code></h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408153251587.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408153251587" class="fancybox"><img alt="image-20200408153251587" title="image-20200408153251587" data-src="http://narpro.top/img/image-20200408153251587.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200408153431573.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408153431573" class="fancybox"><img alt="image-20200408153431573" title="image-20200408153431573" data-src="http://narpro.top/img/image-20200408153431573.png" class="lazyload"></a></p>
<ul>
<li>系统设置一张 <code>DCT</code>，登记所有外部设备，一行登记一台设备的管理信息</li>
</ul>
</blockquote>
<h3 id="7-2-5-控制器控制表-CCT"><a href="#7-2-5-控制器控制表-CCT" class="headerlink" title="7.2.5 控制器控制表 CCT"></a>7.2.5 控制器控制表 <code>CCT</code></h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408153823575.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408153823575" class="fancybox"><img alt="image-20200408153823575" title="image-20200408153823575" data-src="http://narpro.top/img/image-20200408153823575.png" class="lazyload"></a></p>
</blockquote>
<h3 id="7-2-6-通道控制器-CHT"><a href="#7-2-6-通道控制器-CHT" class="headerlink" title="7.2.6 通道控制器 CHT"></a>7.2.6 通道控制器 <code>CHT</code></h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408153922896.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408153922896" class="fancybox"><img alt="image-20200408153922896" title="image-20200408153922896" data-src="http://narpro.top/img/image-20200408153922896.png" class="lazyload"></a></p>
</blockquote>
<h3 id="7-2-7-逻辑设备映射表-LUT"><a href="#7-2-7-逻辑设备映射表-LUT" class="headerlink" title="7.2.7 逻辑设备映射表 LUT"></a>7.2.7 逻辑设备映射表 <code>LUT</code></h3><blockquote>
<p>上述的分配结果记入每个进程的 <code>PCB</code>，称作 <code>LUT</code></p>
<ul>
<li>逻辑设备名</li>
<li>物理设备标识</li>
</ul>
</blockquote>
<h3 id="7-2-8-设备分配过程"><a href="#7-2-8-设备分配过程" class="headerlink" title="7.2.8 设备分配过程"></a>7.2.8 设备分配过程</h3><blockquote>
<ul>
<li>根据用户提出的逻辑设备名称，从 <code>SDT</code> 中找到相应类型的逻辑设备，并获取该类型设备的可用数量 <code>N</code>，据此进行安全检测（银行家算法），如果检验不通过，则将进程阻塞</li>
<li>从 <code>SDT</code> 中取出 <code>DCT</code>，找到一台可用的外部设备，将设备分配给进程，在该进程的 <code>PCB</code> 中建立一个设备映射表 <code>LUT</code>，将用户的逻辑设备名称和对应的物理设备标识对应起来</li>
</ul>
</blockquote>
<h3 id="7-2-9-设备无关性"><a href="#7-2-9-设备无关性" class="headerlink" title="7.2.9 设备无关性"></a>7.2.9 设备无关性</h3><blockquote>
<p> 又称设备独立性，指的是应用程序所涉及的逻辑设备与系统中具体使用的物理设备是互相无关的</p>
<p> 用户写程序时使用逻辑设备名，执行时由系统分配物理设备</p>
<p> <strong>优点</strong>：</p>
<ul>
<li>设备分配的灵活性提高，进程使用逻辑设备名提出请求，系统可以从当前空闲的物理设备中任选一台分给用户</li>
<li>易于实现 <code>I/O</code> 重定向，系统可以在不更改应用程序代码的前提下，让程序中 <code>I/O</code> 命令所涉及的逻辑设备名映射到另外的物理设备上</li>
</ul>
</blockquote>
<h2 id="7-3-缓冲区的设置与管理"><a href="#7-3-缓冲区的设置与管理" class="headerlink" title="7.3 缓冲区的设置与管理"></a>7.3 缓冲区的设置与管理</h2><h3 id="7-3-1-什么是缓冲区"><a href="#7-3-1-什么是缓冲区" class="headerlink" title="7.3.1 什么是缓冲区"></a>7.3.1 什么是缓冲区</h3><blockquote>
<p>是位于内存中的一块临时存储区，作为内存呢和外部设备之间数据传送的桥梁</p>
<p><a href="http://narpro.top/img/image-20200408155207804.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408155207804" class="fancybox"><img alt="image-20200408155207804" title="image-20200408155207804" data-src="http://narpro.top/img/image-20200408155207804.png" class="lazyload"></a></p>
</blockquote>
<h3 id="7-3-2-设置缓冲区的目的"><a href="#7-3-2-设置缓冲区的目的" class="headerlink" title="7.3.2 设置缓冲区的目的"></a>7.3.2 设置缓冲区的目的</h3><blockquote>
<ul>
<li>改善中央处理器与外围设备之间速度不匹配的矛盾</li>
<li>协调逻辑记录大小与物理记录大小不一致</li>
<li>提高 <code>CPU</code> 和 <code>I/O</code> 设备的并行性</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>减少设备驱动次数</li>
<li>可以缓解 <code>I/O</code> 操作对缺页置换策略的干扰</li>
<li>缓解 <code>CPU</code> 与外部设备速度不匹配的矛盾，使数据处理的速度提高</li>
</ul>
<p><strong>过程</strong></p>
<ul>
<li>进程执行写操纵输出数据时，向系统申请一个缓冲区，若为顺序写请求，则不断把数据填到缓冲区，知道被装满</li>
<li>此后进程继续它的计算，系统将缓冲区内容 <code>I/O</code> 设备上</li>
<li>在输出数据时，只有在系统还来不及腾空缓冲而进程又要写数据时，它才需要等待</li>
<li>大部分时间，进程的计算和输出是可以并行的</li>
</ul>
</blockquote>
<h3 id="7-3-4-设置缓冲区的方法"><a href="#7-3-4-设置缓冲区的方法" class="headerlink" title="7.3.4 设置缓冲区的方法"></a>7.3.4 设置缓冲区的方法</h3><blockquote>
<p><strong>单缓冲</strong>：</p>
<p><a href="http://narpro.top/img/image-20200408155538803.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408155538803" class="fancybox"><img alt="image-20200408155538803" title="image-20200408155538803" data-src="http://narpro.top/img/image-20200408155538803.png" class="lazyload"></a></p>
<p><strong>双缓冲</strong>：</p>
<p><a href="http://narpro.top/img/image-20200408155614308.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408155614308" class="fancybox"><img alt="image-20200408155614308" title="image-20200408155614308" data-src="http://narpro.top/img/image-20200408155614308.png" class="lazyload"></a></p>
<p><strong>多缓冲</strong>：</p>
<p><a href="http://narpro.top/img/image-20200408155702436.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408155702436" class="fancybox"><img alt="image-20200408155702436" title="image-20200408155702436" data-src="http://narpro.top/img/image-20200408155702436.png" class="lazyload"></a></p>
</blockquote>
<h3 id="7-3-5-缓冲池"><a href="#7-3-5-缓冲池" class="headerlink" title="7.3.5 缓冲池"></a>7.3.5 缓冲池</h3><blockquote>
<p>当一个进程要写数据时，向缓冲池申请一个缓冲块</p>
<ul>
<li>空闲缓冲队列</li>
<li>输入队列</li>
<li>输出队列</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408160629753.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408160629753" class="fancybox"><img alt="image-20200408160629753" title="image-20200408160629753" data-src="http://narpro.top/img/image-20200408160629753.png" class="lazyload"></a></p>
<p><strong>四个系统进程</strong></p>
<ul>
<li>收容输入</li>
<li>提取输入</li>
<li>收容输出</li>
<li>提取输出</li>
</ul>
</blockquote>
<h2 id="7-4-磁盘读写速度分析"><a href="#7-4-磁盘读写速度分析" class="headerlink" title="7.4 磁盘读写速度分析"></a>7.4 磁盘读写速度分析</h2><blockquote>
<p><a href="http://narpro.top/img/image-20200408163116602.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408163116602" class="fancybox"><img alt="image-20200408163116602" title="image-20200408163116602" data-src="http://narpro.top/img/image-20200408163116602.png" class="lazyload"></a></p>
</blockquote>
<h3 id="7-4-1-性能参数"><a href="#7-4-1-性能参数" class="headerlink" title="7.4.1 性能参数"></a>7.4.1 性能参数</h3><blockquote>
<p><strong>寻道时间 t<del>s</del></strong>：将磁头臂移到指定刺刀所需要的时间</p>
<p><a href="http://narpro.top/img/image-20200408163713171.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408163713171" class="fancybox"><img alt="image-20200408163713171" title="image-20200408163713171" data-src="http://narpro.top/img/image-20200408163713171.png" class="lazyload"></a></p>
<p><strong>旋转延迟时间 t<del>r</del></strong>：将磁盘的待访问地址区域旋转到读/写磁头可访问的位置所需要的时间</p>
<p><a href="http://narpro.top/img/image-20200408163744443.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408163744443" class="fancybox"><img alt="image-20200408163744443" title="image-20200408163744443" data-src="http://narpro.top/img/image-20200408163744443.png" class="lazyload"></a></p>
<p><strong>传输时间 t<del>i</del></strong>：读或写操作的数据传输所需的时间</p>
<p><a href="http://narpro.top/img/image-20200408163812152.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408163812152" class="fancybox"><img alt="image-20200408163812152" title="image-20200408163812152" data-src="http://narpro.top/img/image-20200408163812152.png" class="lazyload"></a></p>
<p>T = t <del>s</del> + t <del>r</del> + t <del>i</del></p>
<p><a href="http://narpro.top/img/image-20200408164038205.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408164038205" class="fancybox"><img alt="image-20200408164038205" title="image-20200408164038205" data-src="http://narpro.top/img/image-20200408164038205.png" class="lazyload"></a></p>
</blockquote>
<h2 id="7-5-磁盘调度算法"><a href="#7-5-磁盘调度算法" class="headerlink" title="7.5 磁盘调度算法"></a>7.5 磁盘调度算法</h2><blockquote>
<p><strong>衡量算法的性能</strong>：</p>
<p>磁盘调度程序的目标是指定一种访问策略，使磁头臂移动较少的距离就可完成磁盘访问</p>
<p>对于 <code>r</code> 次磁盘访问请求 <code>q1，q2，...，qr</code> 应用某种磁盘调度算法得到一个依次满足各次请求的顺序，期间磁臂总共跨越的道数为 n </p>
<p><code>平均寻道长度 = n / r</code></p>
</blockquote>
<h3 id="7-5-1-先来先服务-FCFS"><a href="#7-5-1-先来先服务-FCFS" class="headerlink" title="7.5.1 先来先服务 FCFS"></a>7.5.1 先来先服务 <code>FCFS</code></h3><blockquote>
<p>按磁盘访问请求到来的先后顺序进行服务</p>
<p><strong>优点</strong>：比较公平，实现简单</p>
<p><strong>缺点</strong>：不考虑调用效率</p>
</blockquote>
<h3 id="7-5-2-最短寻道优先-SSTF"><a href="#7-5-2-最短寻道优先-SSTF" class="headerlink" title="7.5.2 最短寻道优先 SSTF"></a>7.5.2 最短寻道优先 <code>SSTF</code></h3><blockquote>
<p>从当前磁头位置选择最短寻道时间的请求，即选择与当前磁头位置最近的待处理请求</p>
<p><strong>优点</strong>：较 <code>FCFS</code> 提高了性能</p>
<p><strong>缺点</strong>：有可能出现 <strong>粘着</strong> 现象，系统比较繁忙时，可能出现饥饿现象，且磁臂转向也需要时间开销</p>
</blockquote>
<h3 id="7-5-3-扫描算法-SCAN"><a href="#7-5-3-扫描算法-SCAN" class="headerlink" title="7.5.3 扫描算法 SCAN"></a>7.5.3 扫描算法 <code>SCAN</code></h3><blockquote>
<p>又成为电梯调度，沿磁臂当前移动方向由近及远一次满足此怕能访问请求，至当前方向再无请求时磁盘转向，继续由近及远一次满足访问请求</p>
<p><strong>优点</strong>：较 <code>SSTF</code> 大大减少了磁臂转向次数，尽管平均寻道时间长度增大，但在实际系统中效率较好</p>
<p><strong>缺点</strong>：系统比较繁忙时，仍可能出现饥饿现象</p>
</blockquote>
<h3 id="7-5-4-循环扫描算法-CSCAN"><a href="#7-5-4-循环扫描算法-CSCAN" class="headerlink" title="7.5.4 循环扫描算法 CSCAN"></a>7.5.4 循环扫描算法 <code>CSCAN</code></h3><blockquote>
<p>在一个移动方向上，随着移动不断处理请求，反向时空档返回，知道最远请求，然后转向移动时再处理请求</p>
<p><strong>优点</strong>：较之 <code>SCAN</code> 算法减少了现象的出现</p>
<p><strong>缺点</strong>：空档返回增加了平均寻道时间</p>
</blockquote>
<h2 id="7-6-通道控制下的-I-O"><a href="#7-6-通道控制下的-I-O" class="headerlink" title="7.6 通道控制下的 I/O"></a>7.6 通道控制下的 <code>I/O</code></h2><blockquote>
<p>计算机系统中的 <code>I/O</code> 控制是与硬件的配置紧密相关的</p>
<ul>
<li>程序查询控制方式</li>
<li>中断控制方式</li>
<li><code>DMA</code> 控制方式</li>
<li>通道控制方式</li>
</ul>
</blockquote>
<h3 id="7-6-1-中断类别"><a href="#7-6-1-中断类别" class="headerlink" title="7.6.1 中断类别"></a>7.6.1 中断类别</h3><blockquote>
<p><strong>自愿性中断</strong>：</p>
<ul>
<li>访管中断</li>
<li>人为设置中断</li>
</ul>
<p><strong>非自愿性中断</strong>：</p>
<ul>
<li><code>I/O</code> 中断</li>
<li>硬件故障置中断</li>
<li>程序出错中断</li>
<li>外部事件中断</li>
</ul>
</blockquote>
<h3 id="7-6-2-中断处理程序的处理过程"><a href="#7-6-2-中断处理程序的处理过程" class="headerlink" title="7.6.2 中断处理程序的处理过程"></a>7.6.2 中断处理程序的处理过程</h3><blockquote>
<ul>
<li>关中断</li>
<li>保护进程上下文<ul>
<li>被中断的程序，除了 <code>PSW</code> 和 <code>PC</code> 中的信息已被硬件机制压栈，其余寄存器中尚有一部分残留数据</li>
<li>而中断处理程序运行时可能要用到其中一部分寄存器，因此需要将中断程序中涉及到的寄存器内容保存起来，通常也压入系统栈中</li>
</ul>
</li>
<li>设备中断处理（不同的设备有不同的设备中断处理程序）<ul>
<li>在处理期间，处理机要检查相关设备控制器的状态，判断本次传输是否正常完成。</li>
<li>若正常完成，可将设备传送来的数据转交到用户区，并唤醒等待该数据的进程，或者将下一批要传送出去的数据传送到设备控制器中，重新启动设备，若为非正常完成，可根据发生的情况进行异常处理</li>
</ul>
</li>
<li>恢复被中断的程序<ul>
<li>首先将保存在栈中的寄存器内容弹出来，置入处理机的相关寄存器中。然后从栈中弹出 <code>PSW</code> 和 <code>PC</code> 的值，置入处理机中。这就意味着，被中断的程序又恢复了运行</li>
</ul>
</li>
<li>开中断</li>
</ul>
</blockquote>
<h3 id="7-6-3-通道"><a href="#7-6-3-通道" class="headerlink" title="7.6.3 通道"></a>7.6.3 通道</h3><blockquote>
<p><code>I/O</code> 处理机，处理 <code>I/O</code> 过程的指令，通常被置于内存的约定地址中，作为实施数据传送控制的依据，通道程序的编制主要依赖 <code>SDT</code>、<code>DCT</code>、<code>IOB</code> 中的信息</p>
<p><a href="http://narpro.top/img/image-20200408173407336.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408173407336" class="fancybox"><img alt="image-20200408173407336" title="image-20200408173407336" data-src="http://narpro.top/img/image-20200408173407336.png" class="lazyload"></a></p>
</blockquote>
<h2 id="7-7-虚拟设备"><a href="#7-7-虚拟设备" class="headerlink" title="7.7 虚拟设备"></a>7.7 虚拟设备</h2><blockquote>
<p>操作系统的设备管理模块通过软件方法扩充设备功能，获得虚拟设备</p>
<p><strong>包括</strong>：</p>
<ul>
<li>将一台设备虚拟成多台设备</li>
<li>将低速设备虚拟成快速设备</li>
<li>将不能共享的设备虚拟成共享设备</li>
</ul>
</blockquote>
<h3 id="7-7-1-Spooling-技术"><a href="#7-7-1-Spooling-技术" class="headerlink" title="7.7.1 Spooling 技术"></a>7.7.1 <code>Spooling</code> 技术</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408174046430.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408174046430" class="fancybox"><img alt="image-20200408174046430" title="image-20200408174046430" data-src="http://narpro.top/img/image-20200408174046430.png" class="lazyload"></a></p>
<p><code>Spooling</code> 是 <strong>联机外设并行访问 <code>(Simultaneous Peripheral Operations On Line)</code></strong> 的缩写，是指将磁盘空间虚拟成 <code>I/O</code> 设备的一种技术</p>
<p><strong>实质</strong>：</p>
<p>利用高速共享设备（通常是磁鼓或者磁盘）将低速的独享设备模拟为高速的共享设备，这样从逻辑上将，计算机系统为每一个用户都配备了一台高速独享设备</p>
<ul>
<li>是操作系统用于管理低速外部设备的一种实用技术</li>
<li>是将独享设备模拟成共享设备的一种技术</li>
</ul>
<p><strong>要点</strong>：</p>
<ul>
<li>外存上设输入井、输出井</li>
<li>内存设输入缓冲区、输出缓冲区</li>
<li>系统设与输入程序和缓输出程序</li>
<li>对于输入输出井的使用，系统设四个系统进程<ul>
<li>收容输入：负责启动输入设备，将数据从输入设备都进来，在文件管理系统的支持下，把数据存放到外存的输入井上</li>
<li>提取输入：从输入井上提取数据，送入内存的用户区，供进程使用</li>
<li>收容输出：将用户进程需要输出的数据从其用户区取出来，送到输出井</li>
<li>提取输出：到外存上取出输出井上的数据，输出到设备上</li>
</ul>
</li>
</ul>
<p><strong>输入过程</strong></p>
<p><a href="http://narpro.top/img/image-20200408175532201.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408175532201" class="fancybox"><img alt="image-20200408175532201" title="image-20200408175532201" data-src="http://narpro.top/img/image-20200408175532201.png" class="lazyload"></a></p>
<p><strong>输出过程</strong></p>
<p><a href="http://narpro.top/img/image-20200408175711934.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408175711934" class="fancybox"><img alt="image-20200408175711934" title="image-20200408175711934" data-src="http://narpro.top/img/image-20200408175711934.png" class="lazyload"></a></p>
</blockquote>
<h1 id="八、文件管理篇"><a href="#八、文件管理篇" class="headerlink" title="八、文件管理篇"></a>八、文件管理篇</h1><h2 id="8-1-文件与文件管理概述"><a href="#8-1-文件与文件管理概述" class="headerlink" title="8.1 文件与文件管理概述"></a>8.1 文件与文件管理概述</h2><h3 id="8-1-1-什么是文件"><a href="#8-1-1-什么是文件" class="headerlink" title="8.1.1 什么是文件"></a>8.1.1 什么是文件</h3><blockquote>
<ul>
<li>文件是在逻辑上具有完整意义的一组相关信息的集合</li>
<li>它可以使一组相关的字符流集合，也可以是一组相关的记录集合</li>
<li>通常被保存在外存储器上</li>
</ul>
</blockquote>
<h3 id="8-1-2-文件的内部形式"><a href="#8-1-2-文件的内部形式" class="headerlink" title="8.1.2 文件的内部形式"></a>8.1.2 文件的内部形式</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408180425394.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408180425394" class="fancybox"><img alt="image-20200408180425394" title="image-20200408180425394" data-src="http://narpro.top/img/image-20200408180425394.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-1-3-文件管理系统-FMS"><a href="#8-1-3-文件管理系统-FMS" class="headerlink" title="8.1.3 文件管理系统 FMS"></a>8.1.3 文件管理系统 <code>FMS</code></h3><blockquote>
<ul>
<li><code>FMS</code> 是操作系统的一个组成部分</li>
<li>负责实现文件管理有关功能的管理模块</li>
<li>管理对象：文件、目录、文件存储空间、用户</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408181158015.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408181158015" class="fancybox"><img alt="image-20200408181158015" title="image-20200408181158015" data-src="http://narpro.top/img/image-20200408181158015.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-1-4-文件管理系统的目标"><a href="#8-1-4-文件管理系统的目标" class="headerlink" title="8.1.4 文件管理系统的目标"></a>8.1.4 文件管理系统的目标</h3><blockquote>
<ul>
<li>方便用户</li>
<li>提高磁盘空间利用率</li>
<li>文件操作便捷且存取效率高</li>
<li>实现逻辑文件与物理文件的组织和转换</li>
</ul>
</blockquote>
<h3 id="8-1-5-文件管理系统的管理功能"><a href="#8-1-5-文件管理系统的管理功能" class="headerlink" title="8.1.5 文件管理系统的管理功能"></a>8.1.5 文件管理系统的管理功能</h3><blockquote>
<ul>
<li>按名存取</li>
<li>文件组织（逻辑文件与物理文件的转换）</li>
<li>存储空间管理</li>
<li>文件共享和保护</li>
<li>文件操作</li>
</ul>
</blockquote>
<h3 id="8-1-6-公认一个好的-FMS-应具有以下特点"><a href="#8-1-6-公认一个好的-FMS-应具有以下特点" class="headerlink" title="8.1.6 公认一个好的 FMS 应具有以下特点"></a>8.1.6 公认一个好的 <code>FMS</code> 应具有以下特点</h3><blockquote>
<ul>
<li>使用的方便性：按名存取的实现，使文件的物理结构和存放的物理位置对于用户都成了透明的</li>
<li>数据的安全性：提供有效的保护措施，以保证文件信息的安全</li>
<li>接口的统一性：用户可以使用统一的广义指令或系统调用来存取各种介质上的文件，这样做简单、只管，而且摆脱了对存储介质特性的依赖以及使用 <code>I/O</code> 指令所作的繁琐处理<ul>
<li>操作员接口，如各种菜单命令</li>
<li>程序员接口，如 <code>fopen()</code> 等文件操作系统调用</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="8-2-文件、目录、文件目录、目录文件"><a href="#8-2-文件、目录、文件目录、目录文件" class="headerlink" title="8.2 文件、目录、文件目录、目录文件"></a>8.2 文件、目录、文件目录、目录文件</h2><blockquote>
<p><strong>目录与文件</strong>：</p>
<ul>
<li>目录也是文件</li>
<li>目录是一种特殊的文件</li>
<li>目录的内容是另一些文件的管理信息</li>
</ul>
<p><strong>目录文件与文件目录</strong>：</p>
<ul>
<li>目录是文件的一种，叫目录文件</li>
<li>文件目录是目录文件中记录的一条信息</li>
</ul>
</blockquote>
<h3 id="8-2-1-DOS-目录文件"><a href="#8-2-1-DOS-目录文件" class="headerlink" title="8.2.1 DOS 目录文件"></a>8.2.1 <code>DOS</code> 目录文件</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408200546582.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408200546582" class="fancybox"><img alt="image-20200408200546582" title="image-20200408200546582" data-src="http://narpro.top/img/image-20200408200546582.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-2-1-Unix-目录文件"><a href="#8-2-1-Unix-目录文件" class="headerlink" title="8.2.1 Unix 目录文件"></a>8.2.1 <code>Unix</code> 目录文件</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408200642459.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408200642459" class="fancybox"><img alt="image-20200408200642459" title="image-20200408200642459" data-src="http://narpro.top/img/image-20200408200642459.png" class="lazyload"></a></p>
<p><strong>为什么要引入索引节点</strong>：</p>
<ul>
<li>在多级目录结构中，目录也是以文件形式存储在磁盘上</li>
<li>如果目录项内容比较多，则目录文件要占用大量的盘块</li>
<li>查找文件要先查找它所在的目录</li>
<li>目录文件太大，查找效率就会比较低</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408201348952.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408201348952" class="fancybox"><img alt="image-20200408201348952" title="image-20200408201348952" data-src="http://narpro.top/img/image-20200408201348952.png" class="lazyload"></a></p>
</blockquote>
<h2 id="8-3-文件的逻辑结构"><a href="#8-3-文件的逻辑结构" class="headerlink" title="8.3 文件的逻辑结构"></a>8.3 文件的逻辑结构</h2><blockquote>
<p>指呈现在用户面前的文件结构，是文件逻辑上的组织形式</p>
<ul>
<li>流式结构</li>
<li>记录式结构</li>
</ul>
</blockquote>
<h3 id="8-3-1-流式文件"><a href="#8-3-1-流式文件" class="headerlink" title="8.3.1 流式文件"></a>8.3.1 流式文件</h3><blockquote>
<p>是指文件内的数据是一个完整的字符流，不可以进一步细分</p>
<p><strong>例如</strong>：</p>
<ul>
<li>源程序文件</li>
<li>可执行文件</li>
<li>文本文件</li>
<li>图片文件</li>
<li>音频文件</li>
<li>.etc</li>
</ul>
<p>对流式文件，用户常常以长度来指定所需存取的信息，也可以通过插入特殊符号来标识存取的界限</p>
</blockquote>
<h3 id="8-3-2-记录式文件"><a href="#8-3-2-记录式文件" class="headerlink" title="8.3.2 记录式文件"></a>8.3.2 记录式文件</h3><blockquote>
<p>在逻辑上可看成是一组记录的集合，每个记录由彼此相关的若干个数据项组成</p>
<p><strong>例如</strong>：</p>
<ul>
<li>统计表文件</li>
<li>数据库文件</li>
<li>.etc</li>
</ul>
</blockquote>
<h2 id="8-4-文件的物理结构"><a href="#8-4-文件的物理结构" class="headerlink" title="8.4 文件的物理结构"></a>8.4 文件的物理结构</h2><blockquote>
<p>指文件在存储介质上的存储结构，是文件在外存空间上的组织形式</p>
<ul>
<li>顺序结构</li>
<li>链式结构</li>
<li>索引结构</li>
</ul>
<p><strong>分类</strong>：</p>
<ul>
<li><strong>连续存储结构</strong>：文件体在磁盘上占用连续的存储空间</li>
<li><strong>非连续存储结构</strong>：文件体在磁盘上占用不连续的存储空间<ul>
<li>链接存储<ul>
<li>显示链接存储</li>
<li>隐式链接存储</li>
</ul>
</li>
<li>索引存储</li>
</ul>
</li>
</ul>
<p><strong>文件的存取方式</strong></p>
<ul>
<li>文件的顺序存取：按照文件的逻辑地址顺序存取。在记录式文件中，这种操作体现为按照记录的排列顺序来进行存取</li>
<li>文件的随机存取：随机存取是指允许用户按照记录编号或者某一数据项的值随机存取任意记录</li>
</ul>
</blockquote>
<h3 id="8-4-1-顺序存储结构"><a href="#8-4-1-顺序存储结构" class="headerlink" title="8.4.1 顺序存储结构"></a>8.4.1 顺序存储结构</h3><blockquote>
<ul>
<li>文件信息占用一组连续的盘块，文件在外存上顺序存放</li>
<li>文件目录中登记起始盘块和所占块数</li>
</ul>
<p>顺序存储的文件称为连续文件，这种文件不仅在逻辑上是连续的，在外存上存放的空间也是连续的</p>
<p><a href="http://narpro.top/img/image-20200408204513042.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408204513042" class="fancybox"><img alt="image-20200408204513042" title="image-20200408204513042" data-src="http://narpro.top/img/image-20200408204513042.png" class="lazyload"></a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>管理简单</li>
<li>存取速度快</li>
<li>既适合顺序存取，也适合随机存取</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>外存空间利用率低</li>
<li>必须预先知道文件的长度</li>
<li>不便于文件的扩展</li>
</ul>
</blockquote>
<h3 id="8-4-2-隐式链式存储结构"><a href="#8-4-2-隐式链式存储结构" class="headerlink" title="8.4.2 隐式链式存储结构"></a>8.4.2 隐式链式存储结构</h3><blockquote>
<p>每个文件占用不连续的盘块，文件目录只登记起始盘块和末盘块号，其他盘块好均由链接指针记录</p>
<p><a href="http://narpro.top/img/image-20200408205137328.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408205137328" class="fancybox"><img alt="image-20200408205137328" title="image-20200408205137328" data-src="http://narpro.top/img/image-20200408205137328.png" class="lazyload"></a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>采用离散分配方式</li>
<li>易于文件增长或收缩</li>
<li>减少了外存空间出现外碎片的现象</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>只能顺序存取</li>
<li>该指针本身需占用存储空间</li>
<li>链接指针的可靠性是个问题</li>
</ul>
</blockquote>
<h3 id="8-4-3-显式链接存储方式"><a href="#8-4-3-显式链接存储方式" class="headerlink" title="8.4.3 显式链接存储方式"></a>8.4.3 显式链接存储方式</h3><blockquote>
<p>将用于链接文件各个盘块的指针显示的存放在外存的一张链接表中</p>
<p>该表在整个磁盘仅设置一张，登记了分配给文件的所有盘块的链接关系，故将该表称为文件分配表 <code>FAT</code></p>
<p><a href="http://narpro.top/img/image-20200408205757034.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408205757034" class="fancybox"><img alt="image-20200408205757034" title="image-20200408205757034" data-src="http://narpro.top/img/image-20200408205757034.png" class="lazyload"></a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>采用离散存储方式</li>
<li>易于文件增长或收缩</li>
<li>减少了外存空间出现外碎片的现象</li>
<li>既可以顺序存取，又可以随机存取</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><code>FAT</code> 表占用较大的存储容量</li>
<li><code>FAT</code> 表使用时，占用较大内存空间</li>
<li><code>FAT</code> 表的读取、维护加大了系统开销</li>
</ul>
</blockquote>
<h3 id="8-4-4-索引存储结构"><a href="#8-4-4-索引存储结构" class="headerlink" title="8.4.4 索引存储结构"></a>8.4.4 索引存储结构</h3><blockquote>
<p>为每个文件分配一个索引块，在索引块中登记其各个逻辑块与外存物理块的对应关系，并在文件 <code>FCB</code> 中登记该文件索引块的地址</p>
<p><a href="http://narpro.top/img/image-20200408210355958.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408210355958" class="fancybox"><img alt="image-20200408210355958" title="image-20200408210355958" data-src="http://narpro.top/img/image-20200408210355958.png" class="lazyload"></a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>离散存储</li>
<li>既适合顺序存取，也方便随机存取</li>
<li>索引结构容易实现记录的增删</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>索引块实际是存储开销</li>
<li>一个索引块能存放的盘快好有限，所以一级索引存储限制了文件的容量</li>
</ul>
<p>假设一个盘块号用 4 个字节标识，盘块尺寸为 4KB，那么一个索引块可存放多少个文件块块号</p>
<p><code>4KB / 4B = 1K</code> </p>
</blockquote>
<h3 id="8-4-5-二级索引存储结构"><a href="#8-4-5-二级索引存储结构" class="headerlink" title="8.4.5 二级索引存储结构"></a>8.4.5 二级索引存储结构</h3><blockquote>
<p>将索引表离散存储，即：将索引表本身分为若干个逻辑块，存储在若干物理盘块中，将索引表所占的个盘块记入另一个索引表——索引表的索引表</p>
<p>这种结构就称二级索引结构</p>
<p><a href="http://narpro.top/img/image-20200408212358130.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408212358130" class="fancybox"><img alt="image-20200408212358130" title="image-20200408212358130" data-src="http://narpro.top/img/image-20200408212358130.png" class="lazyload"></a></p>
<p><strong>一级索引</strong>：</p>
<p><a href="http://narpro.top/img/image-20200408212526387.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408212526387" class="fancybox"><img alt="image-20200408212526387" title="image-20200408212526387" data-src="http://narpro.top/img/image-20200408212526387.png" class="lazyload"></a></p>
<p><strong>多级索引</strong>：</p>
<p><a href="http://narpro.top/img/image-20200408212627157.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408212627157" class="fancybox"><img alt="image-20200408212627157" title="image-20200408212627157" data-src="http://narpro.top/img/image-20200408212627157.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-4-6-多级混合索引结构"><a href="#8-4-6-多级混合索引结构" class="headerlink" title="8.4.6 多级混合索引结构"></a>8.4.6 多级混合索引结构</h3><blockquote>
<p>它将直接寻址、一级索引、二级索引和三级索引融为一体，规定每个文件的索引节点使用 13 个地址登记项</p>
<ul>
<li>前 10 个登记项直接指出存放文件信息的盘块号，属直接寻址</li>
<li>前 11 个登记项指向一级索引块，内含若干一级索引存储块</li>
<li>第 12 个登记项和第 13 个登记项分别实现二、三级索引</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408213202672.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408213202672" class="fancybox"><img alt="image-20200408213202672" title="image-20200408213202672" data-src="http://narpro.top/img/image-20200408213202672.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-4-7-Unix-中的一个文件"><a href="#8-4-7-Unix-中的一个文件" class="headerlink" title="8.4.7 Unix 中的一个文件"></a>8.4.7 <code>Unix</code> 中的一个文件</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408213714949.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408213714949" class="fancybox"><img alt="image-20200408213714949" title="image-20200408213714949" data-src="http://narpro.top/img/image-20200408213714949.png" class="lazyload"></a></p>
</blockquote>
<h2 id="8-5-文件目录的管理与查询"><a href="#8-5-文件目录的管理与查询" class="headerlink" title="8.5 文件目录的管理与查询"></a>8.5 文件目录的管理与查询</h2><blockquote>
<p>是一种数据结构，由若干目录项组成，每个目录项对应其中一个文件的 <code>FCB</code> 包括：</p>
<ul>
<li>文件的存取控制信息</li>
<li>文件的结构信息</li>
<li>文件的管理信息</li>
</ul>
</blockquote>
<h3 id="8-5-1-文件目录内容"><a href="#8-5-1-文件目录内容" class="headerlink" title="8.5.1 文件目录内容"></a>8.5.1 文件目录内容</h3><blockquote>
<ul>
<li><strong>文件存取控制信息</strong>：用户名、文件名、文件类型、文件访问权限 .etc</li>
<li><strong>文件结构信息</strong>：文件的逻辑结构、物理结构、文件位置、长度 .etc</li>
<li><strong>文件管理信息</strong>：文件的建立日期、被修改的日期、保留日期、记账信息 .etc</li>
</ul>
</blockquote>
<h3 id="8-5-2-文件目录管理的主要目的"><a href="#8-5-2-文件目录管理的主要目的" class="headerlink" title="8.5.2 文件目录管理的主要目的"></a>8.5.2 文件目录管理的主要目的</h3><blockquote>
<ul>
<li>合理组织目录结构，提高对目录的检索速度</li>
<li>允许文件重名</li>
<li>实现按名存取</li>
<li>允许文件共享以节约外存空间</li>
</ul>
</blockquote>
<h3 id="8-5-3-单级文件目录"><a href="#8-5-3-单级文件目录" class="headerlink" title="8.5.3 单级文件目录"></a>8.5.3 单级文件目录</h3><blockquote>
<p>每个系统只设置一张文件目录表，集中存放文件存储器上所有文件的 <code>FCB</code></p>
<p><a href="http://narpro.top/img/image-20200408214427236.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408214427236" class="fancybox"><img alt="image-20200408214427236" title="image-20200408214427236" data-src="http://narpro.top/img/image-20200408214427236.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-5-4-两级文件目录"><a href="#8-5-4-两级文件目录" class="headerlink" title="8.5.4 两级文件目录"></a>8.5.4 两级文件目录</h3><blockquote>
<ul>
<li>主文件目录 <code>MFD</code></li>
<li>用户文件目录 <code>UFD</code></li>
</ul>
<p><a href="http://narpro.top/img/image-20200408214558820.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408214558820" class="fancybox"><img alt="image-20200408214558820" title="image-20200408214558820" data-src="http://narpro.top/img/image-20200408214558820.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-5-5-多级文件目录"><a href="#8-5-5-多级文件目录" class="headerlink" title="8.5.5 多级文件目录"></a>8.5.5 多级文件目录</h3><blockquote>
<p><a href="http://narpro.top/img/image-20200408214710073.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408214710073" class="fancybox"><img alt="image-20200408214710073" title="image-20200408214710073" data-src="http://narpro.top/img/image-20200408214710073.png" class="lazyload"></a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>层次清楚，便于文件分类</li>
<li>提高了文件检索速度</li>
<li>解决了重名问题</li>
<li>便于进行存取权限的控制</li>
</ul>
</blockquote>
<h2 id="8-6-文件存储空间的管理"><a href="#8-6-文件存储空间的管理" class="headerlink" title="8.6 文件存储空间的管理"></a>8.6 文件存储空间的管理</h2><blockquote>
<p>文件存储空间——磁盘，是系统与多个用户共享的</p>
<p>用户对文件只要求按名存取，不需要关心文件在外存上具体的存放位置、存取如何实现</p>
<p>文件存储空间的管理由文件存储管理模块负责</p>
</blockquote>
<h3 id="8-6-1-具体功能"><a href="#8-6-1-具体功能" class="headerlink" title="8.6.1 具体功能"></a>8.6.1 具体功能</h3><blockquote>
<ul>
<li><strong>数据结构</strong>：记录磁盘空间使用情况</li>
<li><strong>分配</strong>：查找空闲的磁盘空间分配给文件</li>
<li><strong>回收</strong>：将文件占用的磁盘空间交还给系统</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408215556553.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408215556553" class="fancybox"><img alt="image-20200408215556553" title="image-20200408215556553" data-src="http://narpro.top/img/image-20200408215556553.png" class="lazyload"></a></p>
<ul>
<li>盘片：两个盘面</li>
<li>磁道：柱面</li>
<li>扇区：最小存储单位</li>
<li>磁盘块：相邻的扇区</li>
<li>簇：相邻的盘块</li>
</ul>
</blockquote>
<h3 id="8-6-2-分配和回收"><a href="#8-6-2-分配和回收" class="headerlink" title="8.6.2 分配和回收"></a>8.6.2 分配和回收</h3><blockquote>
<ul>
<li>创建文件或者文件动态增长的时候，查找空闲的盘块，分配给文件</li>
<li>删除文件内容或者删除整个文件时，将文件所占盘块回收</li>
</ul>
<p>哪些盘块是空闲可分配的，回收回来的盘块又记录在哪里，<code>FMS</code> 需要建立和为何相应的数据结构来描述磁盘空间使用情况</p>
</blockquote>
<h3 id="8-6-3-空闲区表-链"><a href="#8-6-3-空闲区表-链" class="headerlink" title="8.6.3 空闲区表/链"></a>8.6.3 空闲区表/链</h3><blockquote>
<p>磁盘上连续的空闲盘块组成一个空闲区，系统为磁盘上所有的空闲区建立一张 <strong>空闲区表</strong>，每个空闲区对应一个表项。若各空闲区使用链，链接起来，称之为 <strong>空闲链区</strong></p>
</blockquote>
<h3 id="8-6-4-空闲块链"><a href="#8-6-4-空闲块链" class="headerlink" title="8.6.4 空闲块链"></a>8.6.4 空闲块链</h3><blockquote>
<p>建立一个链表，将文件存储空间中所有空闲块顺序链接在一起，链中每一节点记录一个空闲块的物理块号，同时记录下一空闲块的指针，称为 <strong>空闲块链</strong></p>
</blockquote>
<h3 id="8-6-5-位示图"><a href="#8-6-5-位示图" class="headerlink" title="8.6.5 位示图"></a>8.6.5 位示图</h3><blockquote>
<p>系统划出若干字节，为每个文件存储设备建立一张位示图，位示图中的一个位对应文件存储空间的一个物理块，若该位为 1，表示对应块被占用，若该位为 0，表示对应物理块空闲</p>
<p><a href="http://narpro.top/img/image-20200408220543741.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408220543741" class="fancybox"><img alt="image-20200408220543741" title="image-20200408220543741" data-src="http://narpro.top/img/image-20200408220543741.png" class="lazyload"></a></p>
<ul>
<li><code>k = i * L + j</code></li>
<li><code>i = [k / L]</code></li>
<li><code>j = k % L</code></li>
</ul>
</blockquote>
<h3 id="8-6-6-成组链接存储方式"><a href="#8-6-6-成组链接存储方式" class="headerlink" title="8.6.6 成组链接存储方式"></a>8.6.6 成组链接存储方式</h3><blockquote>
<p>以 <strong>内存 + 外存</strong> 的混合方式设计数据结构，用于记录和管理磁盘上的空闲盘块</p>
<ul>
<li>磁盘文件区中的所有空闲盘块，100 个盘块为一组，被分成若干组<ul>
<li>假设文件区上共有 4999 个盘块，则被分成 50 个组，N001<del>N100 为第一组，N101</del>N200 为第二组，以此类推，N4901~N5000 为第50组</li>
</ul>
</li>
<li>每一组的最后一个盘块，记录着下一组 100 个空闲盘块的盘块号。这样各组的最后一个盘块就链接成一个链表</li>
<li>盘块 N4900 中记录最后一组 99 个盘块的盘块号，剩余的一个表项存放 0，作为空闲盘块链的结束标志</li>
<li>分配时内存中设置空闲盘块号栈，将第一组空闲盘块的盘块数和盘块号记入其中，作为当前可供分配的盘块号</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408221740024.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408221740024" class="fancybox"><img alt="image-20200408221740024" title="image-20200408221740024" data-src="http://narpro.top/img/image-20200408221740024.png" class="lazyload"></a></p>
<p><strong>分配</strong>：从空闲盘块号栈顶开始，依次分配，分配到栈底盘块即一组的最后一个盘块时，将下一组空闲盘块号以及盘块数写入空闲盘块号栈，继续从栈顶分配</p>
<p><a href="http://narpro.top/img/image-20200408222350096.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408222350096" class="fancybox"><img alt="image-20200408222350096" title="image-20200408222350096" data-src="http://narpro.top/img/image-20200408222350096.png" class="lazyload"></a></p>
<p><strong>回收</strong>：回收的盘块号依次入栈，当栈满即一组集满 100 块时，将这一组盘块号写入写一个回收来的盘块，清空空闲盘块号栈，刚刚写入内容的盘块号入栈，作为占地，也就是下一组的第一个盘块</p>
<p><a href="http://narpro.top/img/image-20200408222600878.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408222600878" class="fancybox"><img alt="image-20200408222600878" title="image-20200408222600878" data-src="http://narpro.top/img/image-20200408222600878.png" class="lazyload"></a></p>
<p><a href="http://narpro.top/img/image-20200408222635474.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408222635474" class="fancybox"><img alt="image-20200408222635474" title="image-20200408222635474" data-src="http://narpro.top/img/image-20200408222635474.png" class="lazyload"></a></p>
</blockquote>
<h2 id="8-7-文件共享、保护与保密"><a href="#8-7-文件共享、保护与保密" class="headerlink" title="8.7 文件共享、保护与保密"></a>8.7 文件共享、保护与保密</h2><blockquote>
<ul>
<li>共享：指允许不同的用户共同使用同一个文件</li>
<li>保护：指防止文件被有意或无意地破坏</li>
<li>保密：指防止文件未经授权而被非法窃取</li>
</ul>
</blockquote>
<h3 id="8-7-1-静态共享"><a href="#8-7-1-静态共享" class="headerlink" title="8.7.1 静态共享"></a>8.7.1 静态共享</h3><blockquote>
<p>多个用户共享同一个物理文件，通过信息文件指针地链接实现。不同用户、不同文件名，但其 <code>FCB</code> 中的物理地址都是相同的，都指向文件存储空间中相同的物理信息</p>
<p><strong>实现方法</strong></p>
<ul>
<li><p>绕弯路法</p>
<ul>
<li>当前目录为 <code>program</code>：<code>./AA/f3</code></li>
<li>当前目录为 <code>AA</code>：<code>./f3</code></li>
<li>当前目录为 <code>document</code>：<code>http://narpro.top/program/AA/f3</code></li>
</ul>
<p><a href="http://narpro.top/img/image-20200408223541965.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408223541965" class="fancybox"><img alt="image-20200408223541965" title="image-20200408223541965" data-src="http://narpro.top/img/image-20200408223541965.png" class="lazyload"></a></p>
</li>
<li><p>基于索引结点共享法</p>
</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408223854254.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408223854254" class="fancybox"><img alt="image-20200408223854254" title="image-20200408223854254" data-src="http://narpro.top/img/image-20200408223854254.png" class="lazyload"></a></p>
<ul>
<li>基于基本目录共享法</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408223812246.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408223812246" class="fancybox"><img alt="image-20200408223812246" title="image-20200408223812246" data-src="http://narpro.top/img/image-20200408223812246.png" class="lazyload"></a></p>
<ul>
<li>基于符号链共享法：基于符号链的文件共享是建立一种特殊的链接文件，内容为需要共享的文件的路径和名字，访问该文件时，根据路径找到共享的文件</li>
</ul>
</blockquote>
<h3 id="8-7-2-动态共享"><a href="#8-7-2-动态共享" class="headerlink" title="8.7.2 动态共享"></a>8.7.2 动态共享</h3><blockquote>
<p>多个进程并发的访问同一文件，这种共享关系只有当用户进程存在时才可能存在，一旦用户进程消亡，其共享消息也就自动消失</p>
<ul>
<li>指系统中不同的用户或同一用户的不同进程并发地访问同一文件</li>
<li>多个进程对已打开文件的共享</li>
<li>这种共享关系只有当用户进程存在时才可能存在，一旦用户进程消亡，其共享关系也就自动消失</li>
</ul>
<p><a href="http://narpro.top/img/image-20200408224235424.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408224235424" class="fancybox"><img alt="image-20200408224235424" title="image-20200408224235424" data-src="http://narpro.top/img/image-20200408224235424.png" class="lazyload"></a></p>
</blockquote>
<h3 id="8-7-3-文件保护"><a href="#8-7-3-文件保护" class="headerlink" title="8.7.3 文件保护"></a>8.7.3 文件保护</h3><blockquote>
<ul>
<li><p>防止系统故障造成破坏，常采用的措施</p>
<ul>
<li>定时转储</li>
<li>建立副本</li>
<li>后备系统</li>
<li>磁盘容错技术<ul>
<li>一级容错：写后读校验</li>
<li>二级容错：磁盘镜像</li>
<li>三级容错：磁盘双工</li>
</ul>
</li>
</ul>
</li>
<li><p>防止人为因素造成破坏</p>
<ul>
<li><p>设置基于目录的存取权限</p>
</li>
<li><p>建立基于文件的存取权限</p>
</li>
<li><p>存取控制矩阵</p>
<p><a href="http://narpro.top/img/image-20200408224807759.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200408224807759" class="fancybox"><img alt="image-20200408224807759" title="image-20200408224807759" data-src="http://narpro.top/img/image-20200408224807759.png" class="lazyload"></a></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-7-4-文件保密"><a href="#8-7-4-文件保密" class="headerlink" title="8.7.4 文件保密"></a>8.7.4 文件保密</h3><blockquote>
<ul>
<li>文件保密是指防止文件未经授权而被非法窃取</li>
<li>文件保护只要求文件信息不被破坏，而文件保密则要求文件不仅不被破坏，而且害不能被非法盗用</li>
<li>规定文件的使用权限可以实现文件保护，也可以在一定程度上起到文件保密的作用。但是文件使用权限可以由用户设定或修改，因而单靠这一方法不足以保障文件安全</li>
</ul>
<p><strong>常用保密措施</strong></p>
<ul>
<li>设置口令</li>
<li>隐藏文件目录</li>
<li>加密与解密技术</li>
</ul>
</blockquote>
<h3 id="8-7-5-系统安全"><a href="#8-7-5-系统安全" class="headerlink" title="8.7.5 系统安全"></a>8.7.5 系统安全</h3><blockquote>
<ul>
<li>系统级：登录、注册</li>
<li>用户级：不同用户级别享有不同权限</li>
<li>目录级：使用权限设在目录级上</li>
<li>文件级：使用权限设在文件级上</li>
</ul>
</blockquote>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cying-承影</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cyingk.github.io/2020/04/08/Operating-System/">http://cyingk.github.io/2020/04/08/Operating-System/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS    </a></div><div class="post_share"><div class="social-share" data-image="http://narpro.top/img/os.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/04/05/SpringBoot/"><img class="next_cover lazyload" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4157804759,1050439081&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>SpringBoot</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Cying-承影</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">自从厌倦于追寻，我已学会一觅即中；自从一股逆风袭来，我已能抗御八面来风,驾舟而行。</div><div class="icp"><a href="http://narpro.top" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>